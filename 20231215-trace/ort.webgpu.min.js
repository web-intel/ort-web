/*!
 * ONNX Runtime Web v1.17.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";var ort=(()=>{var Dn=Object.defineProperty;var Ul=Object.getOwnPropertyDescriptor;var Vl=Object.getOwnPropertyNames;var Gl=Object.prototype.hasOwnProperty;var F=(e,t)=>()=>(e&&(t=e(e=0)),t);var qt=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Dt=(e,t)=>{for(var r in t)Dn(e,r,{get:t[r],enumerable:!0})},Ll=(e,t,r,a)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Vl(t))!Gl.call(e,n)&&n!==r&&Dn(e,n,{get:()=>t[n],enumerable:!(a=Ul(t,n))||a.enumerable});return e};var St=e=>Ll(Dn({},"__esModule",{value:!0}),e);var Lr,Mt,gt,Fr,Hr=F(()=>{Lr=new Map,Mt=[],gt=(e,t,r)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){let a=Lr.get(e);if(a===void 0)Lr.set(e,{backend:t,priority:r});else{if(a.priority>r)return;if(a.priority===r&&a.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${r}`)}if(r>=0){let n=Mt.indexOf(e);n!==-1&&Mt.splice(n,1);for(let s=0;s<Mt.length;s++)if(Lr.get(Mt[s]).priority<=r){Mt.splice(s,0,e);return}Mt.push(e)}return}throw new TypeError("not a valid backend")},Fr=async e=>{let t=e.length===0?Mt:e,r=[];for(let a of t){let n=Lr.get(a);if(n){if(n.initialized)return n.backend;if(n.aborted)continue;let s=!!n.initPromise;try{return s||(n.initPromise=n.backend.init()),await n.initPromise,n.initialized=!0,n.backend}catch(u){s||r.push({name:a,err:u}),n.aborted=!0}finally{delete n.initPromise}}}throw new Error(`no available backend found. ERR: ${r.map(a=>`[${a.name}] ${a.err}`).join(", ")}`)}});var Ja=F(()=>{Hr()});var Za,Qa=F(()=>{Za="1.17.0"});var eo,Mn,to=F(()=>{Qa();eo="warning",Mn={wasm:{},webgl:{},webgpu:{},versions:{common:Za},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);eo=e}},get logLevel(){return eo}};Object.defineProperty(Mn,"logLevel",{enumerable:!0})});var Ie,ro=F(()=>{to();Ie=Mn});var no,ao,oo=F(()=>{no=(e,t)=>{let r=document.createElement("canvas");r.width=e.dims[3],r.height=e.dims[2];let a=r.getContext("2d");if(a!=null){let n,s;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(n=e.dims[2],s=e.dims[3]):(n=e.dims[3],s=e.dims[2]);let u=t?.format!==void 0?t.format:"RGB",l=t?.norm,o,p;l===void 0||l.mean===void 0?o=[255,255,255,255]:typeof l.mean=="number"?o=[l.mean,l.mean,l.mean,l.mean]:(o=[l.mean[0],l.mean[1],l.mean[2],0],l.mean[3]!==void 0&&(o[3]=l.mean[3])),l===void 0||l.bias===void 0?p=[0,0,0,0]:typeof l.bias=="number"?p=[l.bias,l.bias,l.bias,l.bias]:(p=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(p[3]=l.bias[3]));let m=s*n,w=0,g=m,y=m*2,$=-1;u==="RGBA"?(w=0,g=m,y=m*2,$=m*3):u==="RGB"?(w=0,g=m,y=m*2):u==="RBG"&&(w=0,y=m,g=m*2);for(let v=0;v<s;v++)for(let S=0;S<n;S++){let C=(e.data[w++]-p[0])*o[0],T=(e.data[g++]-p[1])*o[1],P=(e.data[y++]-p[2])*o[2],B=$===-1?255:(e.data[$++]-p[3])*o[3];a.fillStyle="rgba("+C+","+T+","+P+","+B+")",a.fillRect(S,v,1,1)}return r.toDataURL()}else throw new Error("Can not access image data")},ao=(e,t)=>{let r=document.createElement("canvas").getContext("2d"),a;if(r!=null){let n,s,u;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(n=e.dims[2],s=e.dims[1],u=e.dims[3]):(n=e.dims[3],s=e.dims[2],u=e.dims[1]);let l=t!==void 0&&t.format!==void 0?t.format:"RGB",o=t?.norm,p,m;o===void 0||o.mean===void 0?p=[255,255,255,255]:typeof o.mean=="number"?p=[o.mean,o.mean,o.mean,o.mean]:(p=[o.mean[0],o.mean[1],o.mean[2],255],o.mean[3]!==void 0&&(p[3]=o.mean[3])),o===void 0||o.bias===void 0?m=[0,0,0,0]:typeof o.bias=="number"?m=[o.bias,o.bias,o.bias,o.bias]:(m=[o.bias[0],o.bias[1],o.bias[2],0],o.bias[3]!==void 0&&(m[3]=o.bias[3]));let w=s*n;if(t!==void 0&&(t.format!==void 0&&u===4&&t.format!=="RGBA"||u===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let g=4,y=0,$=1,v=2,S=3,C=0,T=w,P=w*2,B=-1;l==="RGBA"?(C=0,T=w,P=w*2,B=w*3):l==="RGB"?(C=0,T=w,P=w*2):l==="RBG"&&(C=0,P=w,T=w*2),a=r.createImageData(n,s);for(let z=0;z<s*n;y+=g,$+=g,v+=g,S+=g,z++)a.data[y]=(e.data[C++]-m[0])*p[0],a.data[$]=(e.data[T++]-m[1])*p[1],a.data[v]=(e.data[P++]-m[2])*p[2],a.data[S]=B===-1?255:(e.data[B++]-m[3])*p[3]}else throw new Error("Can not access image data");return a}});var zn,io,so,uo,lo,co=F(()=>{jr();zn=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:r,width:a}=t,n=t.norm??{mean:255,bias:0},s,u;typeof n.mean=="number"?s=[n.mean,n.mean,n.mean,n.mean]:s=[n.mean[0],n.mean[1],n.mean[2],n.mean[3]??255],typeof n.bias=="number"?u=[n.bias,n.bias,n.bias,n.bias]:u=[n.bias[0],n.bias[1],n.bias[2],n.bias[3]??0];let l=t.format!==void 0?t.format:"RGBA",o=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",p=r*a,m=o==="RGBA"?new Float32Array(p*4):new Float32Array(p*3),w=4,g=0,y=1,$=2,v=3,S=0,C=p,T=p*2,P=-1;l==="RGB"&&(w=3,g=0,y=1,$=2,v=-1),o==="RGBA"?P=p*3:o==="RBG"?(S=0,T=p,C=p*2):o==="BGR"&&(T=0,C=p,S=p*2);for(let z=0;z<p;z++,g+=w,$+=w,y+=w,v+=w)m[S++]=(e[g]+u[0])/s[0],m[C++]=(e[y]+u[1])/s[1],m[T++]=(e[$]+u[2])/s[2],P!==-1&&v!==-1&&(m[P++]=(e[v]+u[3])/s[3]);return o==="RGBA"?new Le("float32",m,[1,4,r,a]):new Le("float32",m,[1,3,r,a])},io=async(e,t)=>{let r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,a=typeof ImageData<"u"&&e instanceof ImageData,n=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,s=typeof e=="string",u,l=t??{};if(r){let o=document.createElement("canvas");o.width=e.width,o.height=e.height;let p=o.getContext("2d");if(p!=null){let m=e.height,w=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(m=t.resizedHeight,w=t.resizedWidth),t!==void 0){if(l=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");l.tensorFormat="RGBA",l.height=m,l.width=w}else l.tensorFormat="RGBA",l.height=m,l.width=w;p.drawImage(e,0,0),u=p.getImageData(0,0,w,m).data}else throw new Error("Can not access image data")}else if(a){let o,p;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(o=t.resizedHeight,p=t.resizedWidth):(o=e.height,p=e.width),t!==void 0&&(l=t),l.format="RGBA",l.height=o,l.width=p,t!==void 0){let m=document.createElement("canvas");m.width=p,m.height=o;let w=m.getContext("2d");if(w!=null)w.putImageData(e,0,0),u=w.getImageData(0,0,p,o).data;else throw new Error("Can not access image data")}else u=e.data}else if(n){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");let o=document.createElement("canvas");o.width=e.width,o.height=e.height;let p=o.getContext("2d");if(p!=null){let m=e.height,w=e.width;return p.drawImage(e,0,0,w,m),u=p.getImageData(0,0,w,m).data,l.height=m,l.width=w,zn(u,l)}else throw new Error("Can not access image data")}else{if(s)return new Promise((o,p)=>{let m=document.createElement("canvas"),w=m.getContext("2d");if(!e||!w)return p();let g=new Image;g.crossOrigin="Anonymous",g.src=e,g.onload=()=>{m.width=g.width,m.height=g.height,w.drawImage(g,0,0,m.width,m.height);let y=w.getImageData(0,0,m.width,m.height);l.height=m.height,l.width=m.width,o(zn(y.data,l))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(u!==void 0)return zn(u,l);throw new Error("Input data provided is not supported - aborted tensor creation")},so=(e,t)=>{let{width:r,height:a,download:n,dispose:s}=t,u=[1,a,r,4];return new Le({location:"texture",type:"float32",texture:e,dims:u,download:n,dispose:s})},uo=(e,t)=>{let{dataType:r,dims:a,download:n,dispose:s}=t;return new Le({location:"gpu-buffer",type:r??"float32",gpuBuffer:e,dims:a,download:n,dispose:s})},lo=(e,t,r)=>new Le({location:"cpu-pinned",type:e,data:t,dims:r??[t.length]})});var fr,qr,po,fo,mo=F(()=>{fr=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),qr=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),po=!1,fo=()=>{if(!po){po=!0;let e=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",t=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";e&&(fr.set("int64",BigInt64Array),qr.set(BigInt64Array,"int64")),t&&(fr.set("uint64",BigUint64Array),qr.set(BigUint64Array,"uint64"))}}});var ho,go,yo=F(()=>{jr();ho=e=>{let t=1;for(let r=0;r<e.length;r++){let a=e[r];if(typeof a!="number"||!Number.isSafeInteger(a))throw new TypeError(`dims[${r}] must be an integer, got: ${a}`);if(a<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${a}`);t*=a}return t},go=(e,t)=>{switch(e.location){case"cpu":return new Le(e.type,e.data,t);case"cpu-pinned":return new Le({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new Le({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new Le({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}});var Le,jr=F(()=>{oo();co();mo();yo();Le=class{constructor(t,r,a){fo();let n,s;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,n=t.type,s=t.dims,t.location){case"cpu-pinned":{let l=fr.get(n);if(!l)throw new TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(t.data instanceof l))throw new TypeError(`buffer should be of type ${l.name}`);this.cpuData=t.data;break}case"texture":{if(n!=="float32")throw new TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(n!=="float32"&&n!=="float16"&&n!=="int32"&&n!=="int64"&&n!=="uint32"&&n!=="bool")throw new TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let l,o;if(typeof t=="string")if(n=t,o=a,t==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");l=r}else{let p=fr.get(t);if(p===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(r)){if(t==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");t==="uint64"||t==="int64"?l=p.from(r,BigInt):l=p.from(r)}else if(r instanceof p)l=r;else throw new TypeError(`A ${n} tensor's data must be type of ${p}`)}else if(o=r,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let p=typeof t[0];if(p==="string")n="string",l=t;else if(p==="boolean")n="bool",l=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${p}.`)}else{let p=qr.get(t.constructor);if(p===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);n=p,l=t}if(o===void 0)o=[l.length];else if(!Array.isArray(o))throw new TypeError("A tensor's dims must be a number array");s=o,this.cpuData=l,this.dataLocation="cpu"}let u=ho(s);if(this.cpuData&&u!==this.cpuData.length)throw new Error(`Tensor's size(${u}) does not match data length(${this.cpuData.length}).`);this.type=n,this.dims=s,this.size=u}static async fromImage(t,r){return io(t,r)}static fromTexture(t,r){return so(t,r)}static fromGpuBuffer(t,r){return uo(t,r)}static fromPinnedBuffer(t,r,a){return lo(t,r,a)}toDataURL(t){return no(this,t)}toImageData(t){return ao(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,t&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return go(this,t)}}});var Ve,Kr=F(()=>{jr();Ve=Le});var bo,Yr,mr,wo,je,qe,Wn=F(()=>{Yr=e=>{bo=e},mr=(e,t)=>{console.timeStamp(`${e}::ORT::${t}`)},wo=(e,t)=>{let r=new Error().stack?.split(/\r\n|\r|\n/g)||[],a=!1;for(let n=0;n<r.length;n++){if(a&&!r[n].includes("TRACE_FUNC")){let s=`FUNC_${e}::${r[n].trim().split(" ")[1]}`;t&&(s+=`::${t}`),mr("CPU",s);return}r[n].includes("TRACE_FUNC")&&(a=!0)}},je=e=>{wo("BEGIN",e)},qe=e=>{wo("END",e)}});var Xr,vo=F(()=>{Hr();Kr();Wn();Xr=class e{constructor(t){this.handler=t}async run(t,r,a){je();let n={},s={};if(typeof t!="object"||t===null||t instanceof Ve||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let u=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof Ve)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");u=!1;for(let p of r){if(typeof p!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(p)===-1)throw new RangeError(`'fetches' contains invalid output name: ${p}.`);n[p]=null}if(typeof a=="object"&&a!==null)s=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let p=!1,m=Object.getOwnPropertyNames(r);for(let w of this.outputNames)if(m.indexOf(w)!==-1){let g=r[w];(g===null||g instanceof Ve)&&(p=!0,u=!1,n[w]=g)}if(p){if(typeof a=="object"&&a!==null)s=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else s=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let p of this.inputNames)if(typeof t[p]>"u")throw new Error(`input '${p}' is missing in 'feeds'.`);if(u)for(let p of this.outputNames)n[p]=null;let l=await this.handler.run(t,n,s),o={};for(let p in l)if(Object.hasOwnProperty.call(l,p)){let m=l[p];m instanceof Ve?o[p]=m:o[p]=new Ve(m.type,m.data,m.dims)}return qe(),o}async release(){return this.handler.dispose()}static async create(t,r,a,n){je();let s,u={};if(typeof t=="string"){if(s=t,typeof r=="object"&&r!==null)u=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(s=t,typeof r=="object"&&r!==null)u=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){let w=t,g=0,y=t.byteLength;if(typeof r=="object"&&r!==null)u=r;else if(typeof r=="number"){if(g=r,!Number.isSafeInteger(g))throw new RangeError("'byteOffset' must be an integer.");if(g<0||g>=w.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${w.byteLength}).`);if(y=t.byteLength-g,typeof a=="number"){if(y=a,!Number.isSafeInteger(y))throw new RangeError("'byteLength' must be an integer.");if(y<=0||g+y>w.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${w.byteLength-g}].`);if(typeof n=="object"&&n!==null)u=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(typeof a<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof r<"u")throw new TypeError("'options' must be an object.");s=new Uint8Array(w,g,y)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let o=(u.executionProviders||[]).map(w=>typeof w=="string"?w:w.name),m=await(await Fr(o)).createInferenceSessionHandler(s,u);return qe(),new e(m)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var $o,xo=F(()=>{vo();$o=Xr});var So=F(()=>{});var Fl,Jr,Co=F(()=>{Hr();Kr();Fl="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",Jr=class e{constructor(t){this.handler=t}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}static async create(t,r){let a=t.evalModel||"",n=t.optimizerModel||"",s=r||{},l=(s.executionProviders||[]).map(p=>typeof p=="string"?p:p.name),o=await Fr(l);if(o.createTrainingSessionHandler){let p=await o.createTrainingSessionHandler(t.checkpointState,t.trainModel,a,n,s);return new e(p)}else throw new Error(Fl)}typeNarrowingForRunStep(t,r,a){let n={},s={};if(typeof t!="object"||t===null||t instanceof Ve||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let u=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof Ve)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");u=!1;for(let l of r){if(typeof l!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(l)===-1)throw new RangeError(`'fetches' contains invalid output name: ${l}.`);n[l]=null}if(typeof a=="object"&&a!==null)s=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let l=!1,o=Object.getOwnPropertyNames(r);for(let p of this.outputNames)if(o.indexOf(p)!==-1){let m=r[p];(m===null||m instanceof Ve)&&(l=!0,u=!1,n[p]=m)}if(l){if(typeof a=="object"&&a!==null)s=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else s=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let l of this.inputNames)if(typeof t[l]>"u")throw new Error(`input '${l}' is missing in 'feeds'.`);if(u)for(let l of this.outputNames)n[l]=null;return[n,s]}convertHandlerReturnTypeToMapOfTensors(t){let r={};for(let a in t)if(Object.hasOwnProperty.call(t,a)){let n=t[a];n instanceof Ve?r[a]=n:r[a]=new Ve(n.type,n.data,n.dims)}return r}async runTrainStep(t,r,a){let[n,s]=this.typeNarrowingForRunStep(t,r,a),u=await this.handler.runTrainStep(t,n,s);return this.convertHandlerReturnTypeToMapOfTensors(u)}async loadParametersBuffer(t,r){throw new Error("Method not implemented.")}async getContiguousParameters(t){throw new Error("Method not implemented.")}async release(){return this.handler.dispose()}}});var Io,Ao=F(()=>{Co();Io=Jr});var Nn={};Dt(Nn,{InferenceSession:()=>$o,TRACE:()=>mr,TRACE_FUNC_BEGIN:()=>je,TRACE_FUNC_END:()=>qe,Tensor:()=>Ve,TrainingSession:()=>Io,configureTrace:()=>Yr,env:()=>Ie,registerBackend:()=>gt});var ot=F(()=>{Ja();ro();xo();Kr();Wn();So();Ao()});var Un={};Dt(Un,{readFile:()=>Hl});var Hl,Vn=F(()=>{Hl=void 0});var Gn={};Dt(Gn,{join:()=>jl});var jl,Ln=F(()=>{jl=void 0});var To=qt((Oo,Fn)=>{"use strict";var _o=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,a,n;r.ready=new Promise((d,f)=>{a=d,n=f}),r.jsepInit=(d,f,b,I,A,V,N,ae)=>{r.Za=d,r.Oa=f,r.Qa=b,r.Ja=I,r.Pa=A,r.ra=V,r.Ra=N,r.Sa=ae,f=(K,Q,J)=>(...ce)=>{let me=Je,_=Q?.();ce=K(...ce);let te=Q?.();return _!==te&&(K=te,J(_),Q=J=null),Je!=me?Pr():ce},b=K=>async(...Q)=>{try{if(r.Da)throw Error("Session already started");let J=r.Da={Ta:Q[0],errors:[]},ce=await K(...Q);if(r.Da!==J)throw Error("Session mismatch");d.flush();let me=J.errors;if(0<me.length){let _=await Promise.all(me);if(_=_.filter(te=>te),0<_.length)throw Error(_.join(`
`))}return ce}finally{r.Da=null}},r._OrtRun=b(f(r._OrtRun,()=>r._OrtRun,K=>r._OrtRun=K)),r._OrtRunWithBinding=b(f(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,K=>r._OrtRunWithBinding=K)),r._OrtBindInput=f(r._OrtBindInput,()=>r._OrtBindInput,K=>r._OrtBindInput=K),r.jsepRegisterBuffer=(K,Q,J,ce)=>d.registerBuffer(K,Q,J,ce),r.jsepUnregisterBuffers=K=>{d.unregisterBuffers(K)},r.jsepGetBuffer=K=>d.getBuffer(K),r.jsepCreateDownloader=(K,Q,J)=>d.createDownloader(K,Q,J)};var s=Object.assign({},r),u="./this.program",l=(d,f)=>{throw f},o=typeof window=="object",p=typeof importScripts=="function",m=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",w="",g,y,$;if(m){var v=(Vn(),St(Un)),S=(Ln(),St(Gn));w=p?S.dirname(w)+"/":__dirname+"/",g=(d,f)=>(d=d.startsWith("file://")?new URL(d):S.normalize(d),v.readFileSync(d,f?void 0:"utf8")),$=d=>(d=g(d,!0),d.buffer||(d=new Uint8Array(d)),d),y=(d,f,b,I=!0)=>{d=d.startsWith("file://")?new URL(d):S.normalize(d),v.readFile(d,I?void 0:"utf8",(A,V)=>{A?b(A):f(I?V.buffer:V)})},!r.thisProgram&&1<process.argv.length&&(u=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),l=(d,f)=>{throw process.exitCode=d,f},r.inspect=()=>"[Emscripten Module object]"}else(o||p)&&(p?w=self.location.href:typeof document<"u"&&document.currentScript&&(w=document.currentScript.src),e&&(w=e),w.indexOf("blob:")!==0?w=w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):w="",g=d=>{var f=new XMLHttpRequest;return f.open("GET",d,!1),f.send(null),f.responseText},p&&($=d=>{var f=new XMLHttpRequest;return f.open("GET",d,!1),f.responseType="arraybuffer",f.send(null),new Uint8Array(f.response)}),y=(d,f,b)=>{var I=new XMLHttpRequest;I.open("GET",d,!0),I.responseType="arraybuffer",I.onload=()=>{I.status==200||I.status==0&&I.response?f(I.response):b()},I.onerror=b,I.send(null)});var C=r.print||console.log.bind(console),T=r.printErr||console.error.bind(console);Object.assign(r,s),s=null,r.thisProgram&&(u=r.thisProgram),r.quit&&(l=r.quit);var P;r.wasmBinary&&(P=r.wasmBinary);var B=r.noExitRuntime||!0;typeof WebAssembly!="object"&&Ye("no native wasm support detected");var z,k,W=!1,H,X,le,D,q,xe,ie;function we(){var d=z.buffer;r.HEAP8=X=new Int8Array(d),r.HEAP16=new Int16Array(d),r.HEAP32=D=new Int32Array(d),r.HEAPU8=le=new Uint8Array(d),r.HEAPU16=new Uint16Array(d),r.HEAPU32=q=new Uint32Array(d),r.HEAPF32=xe=new Float32Array(d),r.HEAPF64=ie=new Float64Array(d)}var j=[],Se=[],Te=[];function Ee(){var d=r.preRun.shift();j.unshift(d)}var Ce=0,wt=null,Fe=null;function Ye(d){throw r.onAbort&&r.onAbort(d),d="Aborted("+d+")",T(d),W=!0,H=1,d=new WebAssembly.RuntimeError(d+". Build with -sASSERTIONS for more info."),n(d),d}function G(d){return d.startsWith("data:application/octet-stream;base64,")}var de;if(de="ort-wasm-simd.wasm",!G(de)){var pe=de;de=r.locateFile?r.locateFile(pe,w):w+pe}function Ne(d){if(d==de&&P)return new Uint8Array(P);if($)return $(d);throw"both async and sync fetching of the wasm failed"}function He(d){if(!P&&(o||p)){if(typeof fetch=="function"&&!d.startsWith("file://"))return fetch(d,{credentials:"same-origin"}).then(f=>{if(!f.ok)throw"failed to load wasm binary file at '"+d+"'";return f.arrayBuffer()}).catch(()=>Ne(d));if(y)return new Promise((f,b)=>{y(d,I=>f(new Uint8Array(I)),b)})}return Promise.resolve().then(()=>Ne(d))}function Oe(d,f,b){return He(d).then(I=>WebAssembly.instantiate(I,f)).then(I=>I).then(b,I=>{T("failed to asynchronously prepare wasm: "+I),Ye(I)})}function ze(d,f){var b=de;return P||typeof WebAssembly.instantiateStreaming!="function"||G(b)||b.startsWith("file://")||m||typeof fetch!="function"?Oe(b,d,f):fetch(b,{credentials:"same-origin"}).then(I=>WebAssembly.instantiateStreaming(I,d).then(f,function(A){return T("wasm streaming compile failed: "+A),T("falling back to ArrayBuffer instantiation"),Oe(b,d,f)}))}var Ge,rt={913120:d=>{r.ra("Abs",d,void 0)},913171:d=>{r.ra("Neg",d,void 0)},913222:d=>{r.ra("Floor",d,void 0)},913275:d=>{r.ra("Ceil",d,void 0)},913327:d=>{r.ra("Reciprocal",d,void 0)},913385:d=>{r.ra("Sqrt",d,void 0)},913437:d=>{r.ra("Exp",d,void 0)},913488:d=>{r.ra("Erf",d,void 0)},913539:d=>{r.ra("Sigmoid",d,void 0)},913594:d=>{r.ra("Log",d,void 0)},913645:d=>{r.ra("Sin",d,void 0)},913696:d=>{r.ra("Cos",d,void 0)},913747:d=>{r.ra("Tan",d,void 0)},913798:d=>{r.ra("Asin",d,void 0)},913850:d=>{r.ra("Acos",d,void 0)},913902:d=>{r.ra("Atan",d,void 0)},913954:d=>{r.ra("Sinh",d,void 0)},914006:d=>{r.ra("Cosh",d,void 0)},914058:d=>{r.ra("Asinh",d,void 0)},914111:d=>{r.ra("Acosh",d,void 0)},914164:d=>{r.ra("Atanh",d,void 0)},914217:d=>{r.ra("Tanh",d,void 0)},914269:d=>{r.ra("Not",d,void 0)},914320:(d,f,b)=>{r.ra("Clip",d,{min:f,max:b})},914389:d=>{r.ra("Clip",d,void 0)},914441:(d,f)=>{r.ra("Elu",d,{alpha:f})},914499:d=>{r.ra("Relu",d,void 0)},914551:(d,f)=>{r.ra("LeakyRelu",d,{alpha:f})},914615:(d,f)=>{r.ra("ThresholdedRelu",d,{alpha:f})},914685:(d,f)=>{r.ra("Cast",d,{to:f})},914743:d=>{r.ra("Add",d,void 0)},914794:d=>{r.ra("Sub",d,void 0)},914845:d=>{r.ra("Mul",d,void 0)},914896:d=>{r.ra("Div",d,void 0)},914947:d=>{r.ra("Pow",d,void 0)},914998:d=>{r.ra("Equal",d,void 0)},915051:d=>{r.ra("Greater",d,void 0)},915106:d=>{r.ra("GreaterOrEqual",d,void 0)},915168:d=>{r.ra("Less",d,void 0)},915220:d=>{r.ra("LessOrEqual",d,void 0)},915279:(d,f,b,I,A)=>{r.ra("ReduceMean",d,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:I?Array.from(D.subarray(A>>>0,A+I>>>0)):[]})},915443:(d,f,b,I,A)=>{r.ra("ReduceMax",d,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:I?Array.from(D.subarray(A>>>0,A+I>>>0)):[]})},915606:(d,f,b,I,A)=>{r.ra("ReduceMin",d,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:I?Array.from(D.subarray(A>>>0,A+I>>>0)):[]})},915769:(d,f,b,I,A)=>{r.ra("ReduceProd",d,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:I?Array.from(D.subarray(A>>>0,A+I>>>0)):[]})},915933:(d,f,b,I,A)=>{r.ra("ReduceSum",d,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:I?Array.from(D.subarray(A>>>0,A+I>>>0)):[]})},916096:(d,f,b,I,A)=>{r.ra("ReduceL1",d,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:I?Array.from(D.subarray(A>>>0,A+I>>>0)):[]})},916258:(d,f,b,I,A)=>{r.ra("ReduceL2",d,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:I?Array.from(D.subarray(A>>>0,A+I>>>0)):[]})},916420:(d,f,b,I,A)=>{r.ra("ReduceLogSum",d,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:I?Array.from(D.subarray(A>>>0,A+I>>>0)):[]})},916586:(d,f,b,I,A)=>{r.ra("ReduceSumSquare",d,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:I?Array.from(D.subarray(A>>>0,A+I>>>0)):[]})},916755:(d,f,b,I,A)=>{r.ra("ReduceLogSumExp",d,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:I?Array.from(D.subarray(A>>>0,A+I>>>0)):[]})},916924:d=>{r.ra("Where",d,void 0)},916977:(d,f,b)=>{r.ra("Transpose",d,{perm:f?Array.from(D.subarray(b>>>0,b+f>>>0)):[]})},917090:(d,f,b,I,A,V,N,ae,K,Q,J,ce,me,_,te)=>{r.ra("ConvTranspose",d,{format:K?"NHWC":"NCHW",autoPad:f,dilations:[b],group:I,kernel_shape:[A],pads:[V,N],strides:[ae],wIsConst:()=>!!X[Q>>>0],outputPadding:J?Array.from(D.subarray(ce>>>0,ce+J>>>0)):[],outputShape:me?Array.from(D.subarray(_>>>0,_+me>>>0)):[],activation:Re(te)})},917504:(d,f,b,I,A,V,N,ae,K,Q,J,ce,me,_)=>{r.ra("ConvTranspose",d,{format:ae?"NHWC":"NCHW",autoPad:f,dilations:Array.from(D.subarray(b>>>0,b+2>>>0)),group:I,kernelShape:Array.from(D.subarray(A>>>0,A+2>>>0)),pads:Array.from(D.subarray(V>>>0,V+4>>>0)),strides:Array.from(D.subarray(N>>>0,N+2>>>0)),wIsConst:()=>!!X[K>>>0],outputPadding:0<Q?Array.from(D.subarray(J>>>0,J+Q>>>0)):[],outputShape:0<ce?Array.from(D.subarray(me>>>0,me+ce>>>0)):[],activation:Re(_)})},918061:(d,f,b,I,A,V,N,ae,K,Q,J,ce,me,_,te)=>{r.ra("ConvTranspose",d,{format:K?"NHWC":"NCHW",autoPad:f,dilations:[b],group:I,kernel_shape:[A],pads:[V,N],strides:[ae],wIsConst:()=>!!X[Q>>>0],outputPadding:J?Array.from(D.subarray(ce>>>0,ce+J>>>0)):[],outputShape:me?Array.from(D.subarray(_>>>0,_+me>>>0)):[],activation:Re(te)})},918475:(d,f,b,I,A,V,N,ae,K,Q,J,ce,me,_)=>{r.ra("ConvTranspose",d,{format:ae?"NHWC":"NCHW",autoPad:f,dilations:Array.from(D.subarray(b>>>0,b+2>>>0)),group:I,kernelShape:Array.from(D.subarray(A>>>0,A+2>>>0)),pads:Array.from(D.subarray(V>>>0,V+4>>>0)),strides:Array.from(D.subarray(N>>>0,N+2>>>0)),wIsConst:()=>!!X[K>>>0],outputPadding:0<Q?Array.from(D.subarray(J>>>0,J+Q>>>0)):[],outputShape:0<ce?Array.from(D.subarray(me>>>0,me+ce>>>0)):[],activation:Re(_)})},919032:(d,f)=>{r.ra("GlobalAveragePool",d,{format:f?"NHWC":"NCHW"})},919123:(d,f,b,I,A,V,N,ae,K,Q,J,ce,me,_,te,fe)=>{r.ra("AveragePool",d,{format:fe?"NHWC":"NCHW",auto_pad:f,ceil_mode:b,count_include_pad:I,storage_order:A,dilations:[V,N],kernel_shape:[ae,K],pads:[Q,J,ce,me],strides:[_,te]})},919407:(d,f)=>{r.ra("GlobalAveragePool",d,{format:f?"NHWC":"NCHW"})},919498:(d,f,b,I,A,V,N,ae,K,Q,J,ce,me,_,te,fe)=>{r.ra("AveragePool",d,{format:fe?"NHWC":"NCHW",auto_pad:f,ceil_mode:b,count_include_pad:I,storage_order:A,dilations:[V,N],kernel_shape:[ae,K],pads:[Q,J,ce,me],strides:[_,te]})},919782:(d,f)=>{r.ra("GlobalMaxPool",d,{format:f?"NHWC":"NCHW"})},919869:(d,f,b,I,A,V,N,ae,K,Q,J,ce,me,_,te,fe)=>{r.ra("MaxPool",d,{format:fe?"NHWC":"NCHW",auto_pad:f,ceil_mode:b,count_include_pad:I,storage_order:A,dilations:[V,N],kernel_shape:[ae,K],pads:[Q,J,ce,me],strides:[_,te]})},920149:(d,f)=>{r.ra("GlobalMaxPool",d,{format:f?"NHWC":"NCHW"})},920236:(d,f,b,I,A,V,N,ae,K,Q,J,ce,me,_,te,fe)=>{r.ra("MaxPool",d,{format:fe?"NHWC":"NCHW",auto_pad:f,ceil_mode:b,count_include_pad:I,storage_order:A,dilations:[V,N],kernel_shape:[ae,K],pads:[Q,J,ce,me],strides:[_,te]})},920516:(d,f,b,I,A)=>{r.ra("Gemm",d,{alpha:f,beta:b,transA:I,transB:A})},920620:d=>{r.ra("MatMul",d,void 0)},920674:(d,f,b,I)=>{r.ra("ArgMax",d,{keepDims:!!f,selectLastIndex:!!b,axis:I})},920782:(d,f,b,I)=>{r.ra("ArgMin",d,{keepDims:!!f,selectLastIndex:!!b,axis:I})},920890:(d,f)=>{r.ra("Softmax",d,{axis:f})},920953:(d,f)=>{r.ra("Concat",d,{axis:f})},921013:(d,f,b,I,A)=>{r.ra("Split",d,{axis:f,numOutputs:b,splitSizes:I?Array.from(D.subarray(A>>>0,A+I>>>0)):[]})},921158:d=>{r.ra("Expand",d,void 0)},921212:(d,f)=>{r.ra("Gather",d,{axis:Number(f)})},921283:(d,f)=>{r.ra("GatherElements",d,{axis:Number(f)})},921362:(d,f,b,I,A,V,N,ae,K,Q,J)=>{r.ra("Resize",d,{antialias:f,axes:b?Array.from(D.subarray(I>>>0,I+b>>>0)):[],coordinateTransformMode:Re(A),cubicCoeffA:V,excludeOutside:N,extrapolationValue:ae,keepAspectRatioPolicy:Re(K),mode:Re(Q),nearestMode:Re(J)})},921713:(d,f,b,I,A,V,N)=>{r.ra("Slice",d,{starts:f?Array.from(D.subarray(b>>>0,b+f>>>0)):[],ends:I?Array.from(D.subarray(A>>>0,A+I>>>0)):[],axes:V?Array.from(D.subarray(N>>>0,N+V>>>0)):[]})},921944:d=>{r.ra("Tile",d,void 0)},921996:(d,f,b)=>{r.ra("LayerNormalization",d,{axis:Number(f),epsilon:Number(b)})},922103:(d,f,b)=>{r.ra("InstanceNormalization",d,{epsilon:f,format:b?"NHWC":"NCHW"})},922217:(d,f,b)=>{r.ra("InstanceNormalization",d,{epsilon:f,format:b?"NHWC":"NCHW"})},922331:d=>{r.ra("Range",d,void 0)},922384:(d,f)=>{r.ra("Einsum",d,{equation:Re(f)})},922465:(d,f,b,I,A)=>{r.ra("Pad",d,{mode:f,value:b,pads:I?Array.from(D.subarray(A>>>0,A+I>>>0)):[]})},922597:(d,f,b,I,A,V)=>{r.ra("BatchNormalization",d,{epsilon:f,momentum:b,spatial:!!A,trainingMode:!!I,format:V?"NHWC":"NCHW"})},922766:(d,f,b,I,A,V)=>{r.ra("BatchNormalization",d,{epsilon:f,momentum:b,spatial:!!A,trainingMode:!!I,format:V?"NHWC":"NCHW"})},922935:(d,f,b)=>{r.ra("CumSum",d,{exclusive:Number(f),reverse:Number(b)})},923032:(d,f,b,I,A,V,N,ae,K)=>{r.ra("Attention",d,{numHeads:f,isUnidirectional:b,maskFilterValue:I,scale:A,doRotary:V,qkvHiddenSizes:N?Array.from(D.subarray(Number(ae)>>>0,Number(ae)+N>>>0)):[],pastPresentShareBuffer:!!K})},923304:d=>{r.ra("Gelu",d,void 0)},923356:(d,f,b,I,A,V)=>{r.ra("MultiHeadAttention",d,{numHeads:f,isUnidirectional:b,maskFilterValue:I,scale:A,doRotary:V})},923515:d=>{r.ra("BiasAdd",d,void 0)},923570:d=>{r.ra("BiasSplitGelu",d,void 0)},923631:(d,f)=>{r.ra("SkipLayerNormalization",d,{epsilon:f})},923712:(d,f,b,I,A,V,N,ae,K,Q,J,ce,me)=>{r.ra("Conv",d,{format:K?"NHWC":"NCHW",auto_pad:f,dilations:[b],group:I,kernel_shape:[A],pads:V?Array.from(D.subarray(N>>>0,N+V>>>0)):[],strides:[ae],w_is_const:()=>!!X[Q>>>0],activation:Re(J),activation_params:ce?Array.from(xe.subarray(me>>>0,me+ce>>>0)):[]})},924093:(d,f,b,I,A,V,N,ae,K,Q,J,ce,me,_,te,fe)=>{r.ra("Conv",d,{format:ce?"NHWC":"NCHW",auto_pad:f,dilations:[b,I],group:A,kernel_shape:[V,N],pads:ae?Array.from(D.subarray(K>>>0,K+ae>>>0)):[],strides:[Q,J],w_is_const:()=>!!X[me>>>0],activation:Re(_),activation_params:te?Array.from(xe.subarray(fe>>>0,fe+te>>>0)):[]})},924495:d=>{r.Ra(d)},924529:(d,f)=>r.Sa(d,f,r.Da.Ta,r.Da.errors),924641:d=>r.Oa(d),924674:d=>r.Qa(d),924706:(d,f,b)=>{r.Ja(d,f,b,!0)},924745:(d,f,b)=>{r.Ja(d,f,b)}};function Xe(d){this.name="ExitStatus",this.message=`Program terminated with exit(${d})`,this.status=d}var _t=d=>{for(;0<d.length;)d.shift()(r)};function Ot(d){this.Ha=d-24,this.Ma=function(f){q[this.Ha+4>>2>>>0]=f},this.La=function(f){q[this.Ha+8>>2>>>0]=f},this.Ya=function(f,b){this.Ka(),this.Ma(f),this.La(b)},this.Ka=function(){q[this.Ha+16>>2>>>0]=0}}var Xt=0,Ar=0,Qe=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Jt=(d,f,b)=>{f>>>=0;var I=f+b;for(b=f;d[b]&&!(b>=I);)++b;if(16<b-f&&d.buffer&&Qe)return Qe.decode(d.subarray(f,b));for(I="";f<b;){var A=d[f++];if(A&128){var V=d[f++]&63;if((A&224)==192)I+=String.fromCharCode((A&31)<<6|V);else{var N=d[f++]&63;A=(A&240)==224?(A&15)<<12|V<<6|N:(A&7)<<18|V<<12|N<<6|d[f++]&63,65536>A?I+=String.fromCharCode(A):(A-=65536,I+=String.fromCharCode(55296|A>>10,56320|A&1023))}}else I+=String.fromCharCode(A)}return I},Re=(d,f)=>(d>>>=0)?Jt(le,d,f):"",Ut=d=>{for(var f=0,b=0;b<d.length;++b){var I=d.charCodeAt(b);127>=I?f++:2047>=I?f+=2:55296<=I&&57343>=I?(f+=4,++b):f+=3}return f},Zt=(d,f,b,I)=>{if(b>>>=0,!(0<I))return 0;var A=b;I=b+I-1;for(var V=0;V<d.length;++V){var N=d.charCodeAt(V);if(55296<=N&&57343>=N){var ae=d.charCodeAt(++V);N=65536+((N&1023)<<10)|ae&1023}if(127>=N){if(b>=I)break;f[b++>>>0]=N}else{if(2047>=N){if(b+1>=I)break;f[b++>>>0]=192|N>>6}else{if(65535>=N){if(b+2>=I)break;f[b++>>>0]=224|N>>12}else{if(b+3>=I)break;f[b++>>>0]=240|N>>18,f[b++>>>0]=128|N>>12&63}f[b++>>>0]=128|N>>6&63}f[b++>>>0]=128|N&63}}return f[b>>>0]=0,b-A},pt=d=>d%4===0&&(d%100!==0||d%400===0),Er=[0,31,60,91,121,152,182,213,244,274,305,335],ft=[0,31,59,90,120,151,181,212,243,273,304,334],Vt=d=>{var f=Ut(d)+1,b=Ht(f);return b&&Zt(d,le,b,f),b},vt=[],Gt=(d,f)=>{vt.length=0;var b;for(f>>=2;b=le[d++>>>0];)f+=b!=105&f,vt.push(b==105?D[f>>>0]:ie[f++>>>1]),++f;return vt},Lt={},Qt=()=>{if(!Ft){var d={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:u||"./this.program"},f;for(f in Lt)Lt[f]===void 0?delete d[f]:d[f]=Lt[f];var b=[];for(f in d)b.push(`${f}=${d[f]}`);Ft=b}return Ft},Ft,_r=[null,[],[]],Ue=[31,29,31,30,31,30,31,31,30,31,30,31],er=[31,28,31,30,31,30,31,31,30,31,30,31];function tr(d){var f=Array(Ut(d)+1);return Zt(d,f,0,f.length),f}function ne(d,f,b,I){function A(_,te,fe){for(_=typeof _=="number"?_.toString():_||"";_.length<te;)_=fe[0]+_;return _}function V(_,te){return A(_,te,"0")}function N(_,te){function fe(pr){return 0>pr?-1:0<pr?1:0}var ht;return(ht=fe(_.getFullYear()-te.getFullYear()))===0&&(ht=fe(_.getMonth()-te.getMonth()))===0&&(ht=fe(_.getDate()-te.getDate())),ht}function ae(_){switch(_.getDay()){case 0:return new Date(_.getFullYear()-1,11,29);case 1:return _;case 2:return new Date(_.getFullYear(),0,3);case 3:return new Date(_.getFullYear(),0,2);case 4:return new Date(_.getFullYear(),0,1);case 5:return new Date(_.getFullYear()-1,11,31);case 6:return new Date(_.getFullYear()-1,11,30)}}function K(_){var te=_.Ba;for(_=new Date(new Date(_.Ca+1900,0,1).getTime());0<te;){var fe=_.getMonth(),ht=(pt(_.getFullYear())?Ue:er)[fe];if(te>ht-_.getDate())te-=ht-_.getDate()+1,_.setDate(1),11>fe?_.setMonth(fe+1):(_.setMonth(0),_.setFullYear(_.getFullYear()+1));else{_.setDate(_.getDate()+te);break}}return fe=new Date(_.getFullYear()+1,0,4),te=ae(new Date(_.getFullYear(),0,4)),fe=ae(fe),0>=N(te,_)?0>=N(fe,_)?_.getFullYear()+1:_.getFullYear():_.getFullYear()-1}d>>>=0,f>>>=0,b>>>=0,I>>>=0;var Q=D[I+40>>2>>>0];I={Wa:D[I>>2>>>0],Va:D[I+4>>2>>>0],Ea:D[I+8>>2>>>0],Ia:D[I+12>>2>>>0],Fa:D[I+16>>2>>>0],Ca:D[I+20>>2>>>0],wa:D[I+24>>2>>>0],Ba:D[I+28>>2>>>0],$a:D[I+32>>2>>>0],Ua:D[I+36>>2>>>0],Xa:Q?Re(Q):""},b=Re(b),Q={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var J in Q)b=b.replace(new RegExp(J,"g"),Q[J]);var ce="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),me="January February March April May June July August September October November December".split(" ");Q={"%a":_=>ce[_.wa].substring(0,3),"%A":_=>ce[_.wa],"%b":_=>me[_.Fa].substring(0,3),"%B":_=>me[_.Fa],"%C":_=>V((_.Ca+1900)/100|0,2),"%d":_=>V(_.Ia,2),"%e":_=>A(_.Ia,2," "),"%g":_=>K(_).toString().substring(2),"%G":_=>K(_),"%H":_=>V(_.Ea,2),"%I":_=>(_=_.Ea,_==0?_=12:12<_&&(_-=12),V(_,2)),"%j":_=>{for(var te=0,fe=0;fe<=_.Fa-1;te+=(pt(_.Ca+1900)?Ue:er)[fe++]);return V(_.Ia+te,3)},"%m":_=>V(_.Fa+1,2),"%M":_=>V(_.Va,2),"%n":()=>`
`,"%p":_=>0<=_.Ea&&12>_.Ea?"AM":"PM","%S":_=>V(_.Wa,2),"%t":()=>"	","%u":_=>_.wa||7,"%U":_=>V(Math.floor((_.Ba+7-_.wa)/7),2),"%V":_=>{var te=Math.floor((_.Ba+7-(_.wa+6)%7)/7);if(2>=(_.wa+371-_.Ba-2)%7&&te++,te)te==53&&(fe=(_.wa+371-_.Ba)%7,fe==4||fe==3&&pt(_.Ca)||(te=1));else{te=52;var fe=(_.wa+7-_.Ba-1)%7;(fe==4||fe==5&&pt(_.Ca%400-1))&&te++}return V(te,2)},"%w":_=>_.wa,"%W":_=>V(Math.floor((_.Ba+7-(_.wa+6)%7)/7),2),"%y":_=>(_.Ca+1900).toString().substring(2),"%Y":_=>_.Ca+1900,"%z":_=>{_=_.Ua;var te=0<=_;return _=Math.abs(_)/60,(te?"+":"-")+("0000"+(_/60*100+_%60)).slice(-4)},"%Z":_=>_.Xa,"%%":()=>"%"},b=b.replace(/%%/g,"\0\0");for(J in Q)b.includes(J)&&(b=b.replace(new RegExp(J,"g"),Q[J](I)));return b=b.replace(/\0\0/g,"%"),J=tr(b),J.length>f?0:(X.set(J,d>>>0),J.length-1)}function mt(d){try{d()}catch(f){Ye(f)}}function Or(d){var f={},b;for(b in d)(function(I){var A=d[I];f[I]=typeof A=="function"?function(){Tt.push(I);try{return A.apply(null,arguments)}finally{W||(Tt.pop()===I||Ye(),Je&&nt===1&&Tt.length===0&&(nt=0,mt(dr),typeof Fibers<"u"&&Fibers.ab()))}}:A})(b);return f}var nt=0,Je=null,Tr=0,Tt=[],rr={},nr={},Rr=0,Rt=null,kr=[];function Pr(){return new Promise((d,f)=>{Rt={resolve:d,reject:f}})}function Br(){var d=Ht(65548),f=d+12;q[d>>2>>>0]=f,q[d+4>>2>>>0]=f+65536,f=Tt[0];var b=rr[f];return b===void 0&&(b=Rr++,rr[f]=b,nr[b]=f),D[d+8>>2>>>0]=b,d}function Dr(d){if(!W){if(nt===0){var f=!1,b=!1;d((I=0)=>{if(!W&&(Tr=I,f=!0,b)){nt=2,mt(()=>jt(Je)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),I=!1;try{var A=(0,k[nr[D[Je+8>>2>>>0]]])()}catch(ae){A=ae,I=!0}var V=!1;if(!Je){var N=Rt;N&&(Rt=null,(I?N.reject:N.resolve)(A),V=!0)}if(I&&!V)throw A}}),b=!0,f||(nt=1,Je=Br(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),mt(()=>lr(Je)))}else nt===2?(nt=0,mt(kt),ar(Je),Je=null,kr.forEach(I=>{if(!W)try{if(I(),!B)try{H=H=I=H,B||(r.onExit&&r.onExit(I),W=!0),l(I,new Xe(I))}catch(A){A instanceof Xe||A=="unwind"||l(1,A)}}catch(A){A instanceof Xe||A=="unwind"||l(1,A)}})):Ye(`invalid state: ${nt}`);return Tr}}function Mr(d){return Dr(f=>{d().then(f)})}var zr={n:function(d,f,b){return Mr(async()=>{await r.Pa(d,f,b)})},a:function(d,f,b){throw d>>>=0,new Ot(d).Ya(f>>>0,b>>>0),Xt=d,Ar++,Xt},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(d,f,b){d=f+2097152>>>0<4194305-!!d?(d>>>0)+4294967296*f:NaN,b>>>=0,d=new Date(1e3*d),D[b>>2>>>0]=d.getUTCSeconds(),D[b+4>>2>>>0]=d.getUTCMinutes(),D[b+8>>2>>>0]=d.getUTCHours(),D[b+12>>2>>>0]=d.getUTCDate(),D[b+16>>2>>>0]=d.getUTCMonth(),D[b+20>>2>>>0]=d.getUTCFullYear()-1900,D[b+24>>2>>>0]=d.getUTCDay(),D[b+28>>2>>>0]=(d.getTime()-Date.UTC(d.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(d,f,b){d=f+2097152>>>0<4194305-!!d?(d>>>0)+4294967296*f:NaN,b>>>=0,d=new Date(1e3*d),D[b>>2>>>0]=d.getSeconds(),D[b+4>>2>>>0]=d.getMinutes(),D[b+8>>2>>>0]=d.getHours(),D[b+12>>2>>>0]=d.getDate(),D[b+16>>2>>>0]=d.getMonth(),D[b+20>>2>>>0]=d.getFullYear()-1900,D[b+24>>2>>>0]=d.getDay(),D[b+28>>2>>>0]=(pt(d.getFullYear())?Er:ft)[d.getMonth()]+d.getDate()-1|0,D[b+36>>2>>>0]=-(60*d.getTimezoneOffset()),f=new Date(d.getFullYear(),6,1).getTimezoneOffset();var I=new Date(d.getFullYear(),0,1).getTimezoneOffset();D[b+32>>2>>>0]=(f!=I&&d.getTimezoneOffset()==Math.min(I,f))|0},s:function(d){d>>>=0;var f=new Date(D[d+20>>2>>>0]+1900,D[d+16>>2>>>0],D[d+12>>2>>>0],D[d+8>>2>>>0],D[d+4>>2>>>0],D[d>>2>>>0],0),b=D[d+32>>2>>>0],I=f.getTimezoneOffset(),A=new Date(f.getFullYear(),6,1).getTimezoneOffset(),V=new Date(f.getFullYear(),0,1).getTimezoneOffset(),N=Math.min(V,A);return 0>b?D[d+32>>2>>>0]=+(A!=V&&N==I):0<b!=(N==I)&&(A=Math.max(V,A),f.setTime(f.getTime()+6e4*((0<b?N:A)-I))),D[d+24>>2>>>0]=f.getDay(),D[d+28>>2>>>0]=(pt(f.getFullYear())?Er:ft)[f.getMonth()]+f.getDate()-1|0,D[d>>2>>>0]=f.getSeconds(),D[d+4>>2>>>0]=f.getMinutes(),D[d+8>>2>>>0]=f.getHours(),D[d+12>>2>>>0]=f.getDate(),D[d+16>>2>>>0]=f.getMonth(),D[d+20>>2>>>0]=f.getYear(),d=f.getTime()/1e3,or((Ge=d,1<=+Math.abs(Ge)?0<Ge?+Math.floor(Ge/4294967296)>>>0:~~+Math.ceil((Ge-+(~~Ge>>>0))/4294967296)>>>0:0)),d>>>0},o:function(){return-52},p:function(){},v:function(d,f,b){function I(K){return(K=K.toTimeString().match(/\(([A-Za-z ]+)\)$/))?K[1]:"GMT"}b>>>=0;var A=new Date().getFullYear(),V=new Date(A,0,1),N=new Date(A,6,1);A=V.getTimezoneOffset();var ae=N.getTimezoneOffset();q[d>>>0>>2>>>0]=60*Math.max(A,ae),D[f>>>0>>2>>>0]=+(A!=ae),d=I(V),f=I(N),d=Vt(d),f=Vt(f),ae<A?(q[b>>2>>>0]=d,q[b+4>>2>>>0]=f):(q[b>>2>>>0]=f,q[b+4>>2>>>0]=d)},e:()=>{Ye("")},b:function(d,f,b){return d>>>=0,f=Gt(f>>>0,b>>>0),rt[d].apply(null,f)},i:function(d,f,b){return d>>>=0,f=Gt(f>>>0,b>>>0),rt[d].apply(null,f)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(d,f,b){return f>>>=0,le.copyWithin(d>>>0>>>0,f>>>0,f+(b>>>0)>>>0)},u:function(d){d>>>=0;var f=le.length;if(4294901760<d)return!1;for(var b=1;4>=b;b*=2){var I=f*(1+.2/b);I=Math.min(I,d+100663296);var A=Math;I=Math.max(d,I);e:{A=A.min.call(A,4294901760,I+(65536-I%65536)%65536)-z.buffer.byteLength+65535>>>16;try{z.grow(A),we();var V=1;break e}catch{}V=void 0}if(V)return!0}return!1},D:function(d,f){d>>>=0,f>>>=0;var b=0;return Qt().forEach(function(I,A){var V=f+b;for(A=q[d+4*A>>2>>>0]=V,V=0;V<I.length;++V)X[A++>>0>>>0]=I.charCodeAt(V);X[A>>0>>>0]=0,b+=I.length+1}),0},E:function(d,f){d>>>=0,f>>>=0;var b=Qt();q[d>>2>>>0]=b.length;var I=0;return b.forEach(function(A){I+=A.length+1}),q[f>>2>>>0]=I,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(d,f,b,I){f>>>=0,b>>>=0,I>>>=0;for(var A=0,V=0;V<b;V++){var N=q[f>>2>>>0],ae=q[f+4>>2>>>0];f+=8;for(var K=0;K<ae;K++){var Q=le[N+K>>>0],J=_r[d];Q===0||Q===10?((d===1?C:T)(Jt(J,0)),J.length=0):J.push(Q)}A+=ae}return q[I>>2>>>0]=A,0},F:ne,d:function(d,f,b,I){return ne(d>>>0,f>>>0,b>>>0,I>>>0)}};(function(){function d(b){if(b=b.exports,b=Or(b),k=b=$t(b),z=k.M,we(),Se.unshift(k.N),Ce--,r.monitorRunDependencies&&r.monitorRunDependencies(Ce),Ce==0&&(wt!==null&&(clearInterval(wt),wt=null),Fe)){var I=Fe;Fe=null,I()}return b}var f={a:zr};if(Ce++,r.monitorRunDependencies&&r.monitorRunDependencies(Ce),r.instantiateWasm)try{return r.instantiateWasm(f,d)}catch(b){T("Module.instantiateWasm callback failed with error: "+b),n(b)}return ze(f,function(b){d(b.instance)}).catch(n),{}})(),r._OrtInit=(d,f)=>(r._OrtInit=k.O)(d,f),r._OrtGetLastError=(d,f)=>(r._OrtGetLastError=k.P)(d,f),r._OrtCreateSessionOptions=(d,f,b,I,A,V,N,ae,K,Q)=>(r._OrtCreateSessionOptions=k.Q)(d,f,b,I,A,V,N,ae,K,Q),r._OrtAppendExecutionProvider=(d,f)=>(r._OrtAppendExecutionProvider=k.R)(d,f),r._OrtAddFreeDimensionOverride=(d,f,b)=>(r._OrtAddFreeDimensionOverride=k.S)(d,f,b),r._OrtAddSessionConfigEntry=(d,f,b)=>(r._OrtAddSessionConfigEntry=k.T)(d,f,b),r._OrtReleaseSessionOptions=d=>(r._OrtReleaseSessionOptions=k.U)(d),r._OrtCreateSession=(d,f,b)=>(r._OrtCreateSession=k.V)(d,f,b),r._OrtReleaseSession=d=>(r._OrtReleaseSession=k.W)(d),r._OrtGetInputOutputCount=(d,f,b)=>(r._OrtGetInputOutputCount=k.X)(d,f,b),r._OrtGetInputName=(d,f)=>(r._OrtGetInputName=k.Y)(d,f),r._OrtGetOutputName=(d,f)=>(r._OrtGetOutputName=k.Z)(d,f),r._OrtFree=d=>(r._OrtFree=k._)(d),r._OrtCreateTensor=(d,f,b,I,A,V)=>(r._OrtCreateTensor=k.$)(d,f,b,I,A,V),r._OrtGetTensorData=(d,f,b,I,A)=>(r._OrtGetTensorData=k.aa)(d,f,b,I,A),r._OrtReleaseTensor=d=>(r._OrtReleaseTensor=k.ba)(d),r._OrtCreateRunOptions=(d,f,b,I)=>(r._OrtCreateRunOptions=k.ca)(d,f,b,I),r._OrtAddRunConfigEntry=(d,f,b)=>(r._OrtAddRunConfigEntry=k.da)(d,f,b),r._OrtReleaseRunOptions=d=>(r._OrtReleaseRunOptions=k.ea)(d),r._OrtCreateBinding=d=>(r._OrtCreateBinding=k.fa)(d),r._OrtBindInput=(d,f,b)=>(r._OrtBindInput=k.ga)(d,f,b),r._OrtBindOutput=(d,f,b,I)=>(r._OrtBindOutput=k.ha)(d,f,b,I),r._OrtClearBoundOutputs=d=>(r._OrtClearBoundOutputs=k.ia)(d),r._OrtReleaseBinding=d=>(r._OrtReleaseBinding=k.ja)(d),r._OrtRunWithBinding=(d,f,b,I,A)=>(r._OrtRunWithBinding=k.ka)(d,f,b,I,A),r._OrtRun=(d,f,b,I,A,V,N,ae)=>(r._OrtRun=k.la)(d,f,b,I,A,V,N,ae),r._OrtEndProfiling=d=>(r._OrtEndProfiling=k.ma)(d),r._JsepOutput=(d,f,b)=>(r._JsepOutput=k.na)(d,f,b),r._JsepGetNodeName=d=>(r._JsepGetNodeName=k.oa)(d);var Ht=r._malloc=d=>(Ht=r._malloc=k.pa)(d),ar=r._free=d=>(ar=r._free=k.qa)(d),or=d=>(or=k.sa)(d),ir=()=>(ir=k.ta)(),sr=d=>(sr=k.ua)(d),ur=d=>(ur=k.va)(d),lr=d=>(lr=k.xa)(d),dr=()=>(dr=k.ya)(),jt=d=>(jt=k.za)(d),kt=()=>(kt=k.Aa)();r.___start_em_js=924778,r.___stop_em_js=924939;function $t(d){d=Object.assign({},d);var f=I=>()=>I()>>>0,b=I=>A=>I(A)>>>0;return d.__errno_location=f(d.__errno_location),d.malloc=b(d.malloc),d.stackSave=f(d.stackSave),d.stackAlloc=b(d.stackAlloc),d}r.stackAlloc=ur,r.stackSave=ir,r.stackRestore=sr,r.UTF8ToString=Re,r.stringToUTF8=(d,f,b)=>Zt(d,le,f,b),r.lengthBytesUTF8=Ut;var Pt;Fe=function d(){Pt||cr(),Pt||(Fe=d)};function cr(){function d(){if(!Pt&&(Pt=!0,r.calledRun=!0,!W)){if(_t(Se),a(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var f=r.postRun.shift();Te.unshift(f)}_t(Te)}}if(!(0<Ce)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)Ee();_t(j),0<Ce||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),d()},1)):d())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return cr(),t.ready}})();typeof Oo=="object"&&typeof Fn=="object"?Fn.exports=_o:typeof define=="function"&&define.amd&&define([],()=>_o)});var Ro=qt(()=>{});var ko=qt(()=>{});var Po={};Dt(Po,{cpus:()=>ql});var ql,Bo=F(()=>{ql=void 0});var zo=qt((Mo,Hn)=>{"use strict";var Do=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return we.buffer!=Ce.buffer&&pe(),Ce}function a(){return we.buffer!=Ce.buffer&&pe(),wt}function n(){return we.buffer!=Ce.buffer&&pe(),Fe}function s(){return we.buffer!=Ce.buffer&&pe(),Ye}function u(){return we.buffer!=Ce.buffer&&pe(),G}function l(){return we.buffer!=Ce.buffer&&pe(),de}var o=t,p,m;o.ready=new Promise((i,c)=>{p=i,m=c}),o.jsepInit=(i,c,h,x,E,R,U,oe)=>{o.Qb=i,o.wb=c,o.yb=h,o.jb=x,o.xb=E,o.Ea=R,o.zb=U,o.Ab=oe,c=(ee,Z,re)=>(...he)=>{let be=at,O=Z?.();he=ee(...he);let ue=Z?.();return O!==ue&&(ee=ue,re(O),Z=re=null),at!=be?kl():he},h=ee=>async(...Z)=>{try{if(o.bb)throw Error("Session already started");let re=o.bb={Fb:Z[0],errors:[]},he=await ee(...Z);if(o.bb!==re)throw Error("Session mismatch");i.flush();let be=re.errors;if(0<be.length){let O=await Promise.all(be);if(O=O.filter(ue=>ue),0<O.length)throw Error(O.join(`
`))}return he}finally{o.bb=null}},o._OrtRun=h(c(o._OrtRun,()=>o._OrtRun,ee=>o._OrtRun=ee)),o._OrtRunWithBinding=h(c(o._OrtRunWithBinding,()=>o._OrtRunWithBinding,ee=>o._OrtRunWithBinding=ee)),o._OrtBindInput=c(o._OrtBindInput,()=>o._OrtBindInput,ee=>o._OrtBindInput=ee),o.jsepRegisterBuffer=(ee,Z,re,he)=>i.registerBuffer(ee,Z,re,he),o.jsepUnregisterBuffers=ee=>{i.unregisterBuffers(ee)},o.jsepGetBuffer=ee=>i.getBuffer(ee),o.jsepCreateDownloader=(ee,Z,re)=>i.createDownloader(ee,Z,re)};var w=Object.assign({},o),g="./this.program",y=(i,c)=>{throw c},$=typeof window=="object",v=typeof importScripts=="function",S=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",C=o.ENVIRONMENT_IS_PTHREAD||!1,T="";function P(i){return o.locateFile?o.locateFile(i,T):T+i}var B,z,k;if(S){var W=(Vn(),St(Un)),H=(Ln(),St(Gn));T=v?H.dirname(T)+"/":__dirname+"/",B=(c,h)=>(c=c.startsWith("file://")?new URL(c):H.normalize(c),W.readFileSync(c,h?void 0:"utf8")),k=c=>(c=B(c,!0),c.buffer||(c=new Uint8Array(c)),c),z=(c,h,x,E=!0)=>{c=c.startsWith("file://")?new URL(c):H.normalize(c),W.readFile(c,E?void 0:"utf8",(R,U)=>{R?x(R):h(E?U.buffer:U)})},!o.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),y=(c,h)=>{throw process.exitCode=c,h},o.inspect=()=>"[Emscripten Module object]";let i;try{i=Ro()}catch(c){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),c}global.Worker=i.Worker}else($||v)&&(v?T=self.location.href:typeof document<"u"&&document.currentScript&&(T=document.currentScript.src),typeof e<"u"&&e&&(T=e),T.indexOf("blob:")!==0?T=T.substr(0,T.replace(/[?#].*/,"").lastIndexOf("/")+1):T="",S||(B=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.send(null),c.responseText},v&&(k=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.responseType="arraybuffer",c.send(null),new Uint8Array(c.response)}),z=(i,c,h)=>{var x=new XMLHttpRequest;x.open("GET",i,!0),x.responseType="arraybuffer",x.onload=()=>{x.status==200||x.status==0&&x.response?c(x.response):h()},x.onerror=h,x.send(null)}));S&&typeof performance>"u"&&(global.performance=ko().performance);var X=console.log.bind(console),le=console.error.bind(console);S&&(X=(...i)=>W.writeSync(1,i.join(" ")+`
`),le=(...i)=>W.writeSync(2,i.join(" ")+`
`));var D=o.print||X,q=o.printErr||le;Object.assign(o,w),w=null,o.thisProgram&&(g=o.thisProgram),o.quit&&(y=o.quit);var xe;o.wasmBinary&&(xe=o.wasmBinary);var ie=o.noExitRuntime||!0;typeof WebAssembly!="object"&&Qe("no native wasm support detected");var we,j,Se,Te=!1,Ee,Ce,wt,Fe,Ye,G,de;function pe(){var i=we.buffer;o.HEAP8=Ce=new Int8Array(i),o.HEAP16=new Int16Array(i),o.HEAP32=Fe=new Int32Array(i),o.HEAPU8=wt=new Uint8Array(i),o.HEAPU16=new Uint16Array(i),o.HEAPU32=Ye=new Uint32Array(i),o.HEAPF32=G=new Float32Array(i),o.HEAPF64=de=new Float64Array(i)}var Ne=o.INITIAL_MEMORY||16777216;if(5242880<=Ne||Qe("INITIAL_MEMORY should be larger than STACK_SIZE, was "+Ne+"! (STACK_SIZE=5242880)"),C)we=o.wasmMemory;else if(o.wasmMemory)we=o.wasmMemory;else if(we=new WebAssembly.Memory({initial:Ne/65536,maximum:65536,shared:!0}),!(we.buffer instanceof SharedArrayBuffer))throw q("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),S&&q("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");pe(),Ne=we.buffer.byteLength;var He=[],Oe=[],ze=[],Ge=0;function rt(){return ie||0<Ge}var Xe=0,_t=null,Ot=null;function Xt(){Xe++,o.monitorRunDependencies&&o.monitorRunDependencies(Xe)}function Ar(){if(Xe--,o.monitorRunDependencies&&o.monitorRunDependencies(Xe),Xe==0&&(_t!==null&&(clearInterval(_t),_t=null),Ot)){var i=Ot;Ot=null,i()}}function Qe(i){throw o.onAbort&&o.onAbort(i),i="Aborted("+i+")",q(i),Te=!0,Ee=1,i=new WebAssembly.RuntimeError(i+". Build with -sASSERTIONS for more info."),m(i),i}function Jt(i){return i.startsWith("data:application/octet-stream;base64,")}var Re;Re="ort-wasm-simd-threaded.wasm",Jt(Re)||(Re=P(Re));function Ut(i){if(i==Re&&xe)return new Uint8Array(xe);if(k)return k(i);throw"both async and sync fetching of the wasm failed"}function Zt(i){if(!xe&&($||v)){if(typeof fetch=="function"&&!i.startsWith("file://"))return fetch(i,{credentials:"same-origin"}).then(c=>{if(!c.ok)throw"failed to load wasm binary file at '"+i+"'";return c.arrayBuffer()}).catch(()=>Ut(i));if(z)return new Promise((c,h)=>{z(i,x=>c(new Uint8Array(x)),h)})}return Promise.resolve().then(()=>Ut(i))}function pt(i,c,h){return Zt(i).then(x=>WebAssembly.instantiate(x,c)).then(x=>x).then(h,x=>{q("failed to asynchronously prepare wasm: "+x),Qe(x)})}function Er(i,c){var h=Re;return xe||typeof WebAssembly.instantiateStreaming!="function"||Jt(h)||h.startsWith("file://")||S||typeof fetch!="function"?pt(h,i,c):fetch(h,{credentials:"same-origin"}).then(x=>WebAssembly.instantiateStreaming(x,i).then(c,function(E){return q("wasm streaming compile failed: "+E),q("falling back to ArrayBuffer instantiation"),pt(h,i,c)}))}var ft,Vt={1427128:i=>{o.Ea("Abs",i,void 0)},1427179:i=>{o.Ea("Neg",i,void 0)},1427230:i=>{o.Ea("Floor",i,void 0)},1427283:i=>{o.Ea("Ceil",i,void 0)},1427335:i=>{o.Ea("Reciprocal",i,void 0)},1427393:i=>{o.Ea("Sqrt",i,void 0)},1427445:i=>{o.Ea("Exp",i,void 0)},1427496:i=>{o.Ea("Erf",i,void 0)},1427547:i=>{o.Ea("Sigmoid",i,void 0)},1427602:i=>{o.Ea("Log",i,void 0)},1427653:i=>{o.Ea("Sin",i,void 0)},1427704:i=>{o.Ea("Cos",i,void 0)},1427755:i=>{o.Ea("Tan",i,void 0)},1427806:i=>{o.Ea("Asin",i,void 0)},1427858:i=>{o.Ea("Acos",i,void 0)},1427910:i=>{o.Ea("Atan",i,void 0)},1427962:i=>{o.Ea("Sinh",i,void 0)},1428014:i=>{o.Ea("Cosh",i,void 0)},1428066:i=>{o.Ea("Asinh",i,void 0)},1428119:i=>{o.Ea("Acosh",i,void 0)},1428172:i=>{o.Ea("Atanh",i,void 0)},1428225:i=>{o.Ea("Tanh",i,void 0)},1428277:i=>{o.Ea("Not",i,void 0)},1428328:(i,c,h)=>{o.Ea("ClipV10",i,{min:c,max:h})},1428400:i=>{o.Ea("Clip",i,void 0)},1428452:(i,c)=>{o.Ea("Elu",i,{alpha:c})},1428510:i=>{o.Ea("Relu",i,void 0)},1428562:(i,c)=>{o.Ea("LeakyRelu",i,{alpha:c})},1428626:(i,c)=>{o.Ea("ThresholdedRelu",i,{alpha:c})},1428696:i=>{o.zb(i)},1428730:(i,c)=>o.Ab(i,c,o.bb.Fb,o.bb.errors),1428842:(i,c)=>{o.Ea("Cast",i,{to:c})},1428900:i=>{o.Ea("Add",i,void 0)},1428951:i=>{o.Ea("Sub",i,void 0)},1429002:i=>{o.Ea("Mul",i,void 0)},1429053:i=>{o.Ea("Div",i,void 0)},1429104:i=>{o.Ea("Pow",i,void 0)},1429155:i=>{o.Ea("Equal",i,void 0)},1429208:i=>{o.Ea("Greater",i,void 0)},1429263:i=>{o.Ea("GreaterOrEqual",i,void 0)},1429325:i=>{o.Ea("Less",i,void 0)},1429377:i=>{o.Ea("LessOrEqual",i,void 0)},1429436:(i,c,h,x,E)=>{o.Ea("ReduceMean",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:x?Array.from(n().subarray(E>>>0,E+x>>>0)):[]})},1429600:(i,c,h,x,E)=>{o.Ea("ReduceMax",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:x?Array.from(n().subarray(E>>>0,E+x>>>0)):[]})},1429763:(i,c,h,x,E)=>{o.Ea("ReduceMin",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:x?Array.from(n().subarray(E>>>0,E+x>>>0)):[]})},1429926:(i,c,h,x,E)=>{o.Ea("ReduceProd",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:x?Array.from(n().subarray(E>>>0,E+x>>>0)):[]})},1430090:(i,c,h,x,E)=>{o.Ea("ReduceSum",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:x?Array.from(n().subarray(E>>>0,E+x>>>0)):[]})},1430253:(i,c,h,x,E)=>{o.Ea("ReduceL1",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:x?Array.from(n().subarray(E>>>0,E+x>>>0)):[]})},1430415:(i,c,h,x,E)=>{o.Ea("ReduceL2",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:x?Array.from(n().subarray(E>>>0,E+x>>>0)):[]})},1430577:(i,c,h,x,E)=>{o.Ea("ReduceLogSum",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:x?Array.from(n().subarray(E>>>0,E+x>>>0)):[]})},1430743:(i,c,h,x,E)=>{o.Ea("ReduceSumSquare",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:x?Array.from(n().subarray(E>>>0,E+x>>>0)):[]})},1430912:(i,c,h,x,E)=>{o.Ea("ReduceLogSumExp",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:x?Array.from(n().subarray(E>>>0,E+x>>>0)):[]})},1431081:i=>{o.Ea("Where",i,void 0)},1431134:(i,c,h)=>{o.Ea("Transpose",i,{perm:c?Array.from(n().subarray(h>>>0,h+c>>>0)):[]})},1431247:(i,c,h,x,E,R,U,oe,ee,Z,re,he,be)=>{o.Ea("Conv",i,{format:ee?"NHWC":"NCHW",auto_pad:c,dilations:[h],group:x,kernel_shape:[E],pads:R?Array.from(n().subarray(U>>>0,U+R>>>0)):[],strides:[oe],w_is_const:()=>!!r()[Z>>>0],activation:Ue(re),activation_params:he?Array.from(u().subarray(be>>>0,be+he>>>0)):[]})},1431628:(i,c,h,x,E,R,U,oe,ee,Z,re,he,be,O,ue,ye)=>{o.Ea("Conv",i,{format:he?"NHWC":"NCHW",auto_pad:c,dilations:[h,x],group:E,kernel_shape:[R,U],pads:oe?Array.from(n().subarray(ee>>>0,ee+oe>>>0)):[],strides:[Z,re],w_is_const:()=>!!r()[be>>>0],activation:Ue(O),activation_params:ue?Array.from(u().subarray(ye>>>0,ye+ue>>>0)):[]})},1432030:(i,c,h,x,E,R,U,oe,ee,Z,re,he,be,O,ue)=>{o.Ea("ConvTranspose",i,{format:ee?"NHWC":"NCHW",autoPad:c,dilations:[h],group:x,kernel_shape:[E],pads:[R,U],strides:[oe],wIsConst:()=>!!r()[Z>>>0],outputPadding:re?Array.from(n().subarray(he>>>0,he+re>>>0)):[],outputShape:be?Array.from(n().subarray(O>>>0,O+be>>>0)):[],activation:Ue(ue)})},1432444:(i,c,h,x,E,R,U,oe,ee,Z,re,he,be,O)=>{o.Ea("ConvTranspose",i,{format:oe?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(h>>>0,h+2>>>0)),group:x,kernelShape:Array.from(n().subarray(E>>>0,E+2>>>0)),pads:Array.from(n().subarray(R>>>0,R+4>>>0)),strides:Array.from(n().subarray(U>>>0,U+2>>>0)),wIsConst:()=>!!r()[ee>>>0],outputPadding:0<Z?Array.from(n().subarray(re>>>0,re+Z>>>0)):[],outputShape:0<he?Array.from(n().subarray(be>>>0,be+he>>>0)):[],activation:Ue(O)})},1433001:(i,c,h,x,E,R,U,oe,ee,Z,re,he,be,O,ue)=>{o.Ea("ConvTranspose",i,{format:ee?"NHWC":"NCHW",autoPad:c,dilations:[h],group:x,kernel_shape:[E],pads:[R,U],strides:[oe],wIsConst:()=>!!r()[Z>>>0],outputPadding:re?Array.from(n().subarray(he>>>0,he+re>>>0)):[],outputShape:be?Array.from(n().subarray(O>>>0,O+be>>>0)):[],activation:Ue(ue)})},1433415:(i,c,h,x,E,R,U,oe,ee,Z,re,he,be,O)=>{o.Ea("ConvTranspose",i,{format:oe?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(h>>>0,h+2>>>0)),group:x,kernelShape:Array.from(n().subarray(E>>>0,E+2>>>0)),pads:Array.from(n().subarray(R>>>0,R+4>>>0)),strides:Array.from(n().subarray(U>>>0,U+2>>>0)),wIsConst:()=>!!r()[ee>>>0],outputPadding:0<Z?Array.from(n().subarray(re>>>0,re+Z>>>0)):[],outputShape:0<he?Array.from(n().subarray(be>>>0,be+he>>>0)):[],activation:Ue(O)})},1433972:(i,c)=>{o.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},1434063:(i,c,h,x,E,R,U,oe,ee,Z,re,he,be,O,ue,ye)=>{o.Ea("AveragePool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:h,count_include_pad:x,storage_order:E,dilations:[R,U],kernel_shape:[oe,ee],pads:[Z,re,he,be],strides:[O,ue]})},1434347:(i,c)=>{o.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},1434438:(i,c,h,x,E,R,U,oe,ee,Z,re,he,be,O,ue,ye)=>{o.Ea("AveragePool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:h,count_include_pad:x,storage_order:E,dilations:[R,U],kernel_shape:[oe,ee],pads:[Z,re,he,be],strides:[O,ue]})},1434722:(i,c)=>{o.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},1434809:(i,c,h,x,E,R,U,oe,ee,Z,re,he,be,O,ue,ye)=>{o.Ea("MaxPool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:h,count_include_pad:x,storage_order:E,dilations:[R,U],kernel_shape:[oe,ee],pads:[Z,re,he,be],strides:[O,ue]})},1435089:(i,c)=>{o.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},1435176:(i,c,h,x,E,R,U,oe,ee,Z,re,he,be,O,ue,ye)=>{o.Ea("MaxPool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:h,count_include_pad:x,storage_order:E,dilations:[R,U],kernel_shape:[oe,ee],pads:[Z,re,he,be],strides:[O,ue]})},1435456:(i,c,h,x,E)=>{o.Ea("Gemm",i,{alpha:c,beta:h,transA:x,transB:E})},1435560:i=>{o.Ea("MatMul",i,void 0)},1435614:(i,c,h,x)=>{o.Ea("ArgMax",i,{keepDims:!!c,selectLastIndex:!!h,axis:x})},1435722:(i,c,h,x)=>{o.Ea("ArgMin",i,{keepDims:!!c,selectLastIndex:!!h,axis:x})},1435830:(i,c)=>{o.Ea("Softmax",i,{axis:c})},1435893:(i,c)=>{o.Ea("Concat",i,{axis:c})},1435953:(i,c,h,x,E)=>{o.Ea("Split",i,{axis:c,numOutputs:h,splitSizes:x?Array.from(n().subarray(E>>>0,E+x>>>0)):[]})},1436098:i=>{o.Ea("Expand",i,void 0)},1436152:(i,c)=>{o.Ea("Gather",i,{axis:Number(c)})},1436223:(i,c)=>{o.Ea("GatherElements",i,{axis:Number(c)})},1436302:(i,c,h,x,E,R,U,oe,ee,Z,re)=>{o.Ea("Resize",i,{antialias:c,axes:h?Array.from(n().subarray(x>>>0,x+h>>>0)):[],coordinateTransformMode:Ue(E),cubicCoeffA:R,excludeOutside:U,extrapolationValue:oe,keepAspectRatioPolicy:Ue(ee),mode:Ue(Z),nearestMode:Ue(re)})},1436653:(i,c,h,x,E,R,U)=>{o.Ea("Slice",i,{starts:c?Array.from(n().subarray(h>>>0,h+c>>>0)):[],ends:x?Array.from(n().subarray(E>>>0,E+x>>>0)):[],axes:R?Array.from(n().subarray(U>>>0,U+R>>>0)):[]})},1436884:i=>{o.Ea("Tile",i,void 0)},1436936:(i,c,h)=>{o.Ea("LayerNormalization",i,{axis:Number(c),epsilon:Number(h)})},1437043:(i,c,h)=>{o.Ea("InstanceNormalization",i,{epsilon:c,format:h?"NHWC":"NCHW"})},1437157:(i,c,h)=>{o.Ea("InstanceNormalization",i,{epsilon:c,format:h?"NHWC":"NCHW"})},1437271:i=>{o.Ea("Range",i,void 0)},1437324:(i,c)=>{o.Ea("Einsum",i,{equation:Ue(c)})},1437405:(i,c,h,x,E)=>{o.Ea("Pad",i,{mode:c,value:h,pads:x?Array.from(n().subarray(E>>>0,E+x>>>0)):[]})},1437537:i=>{o.Ea("Gelu",i,void 0)},1437589:i=>{o.Ea("BiasAdd",i,void 0)},1437644:i=>{o.Ea("BiasSplitGelu",i,void 0)},1437705:(i,c)=>{o.Ea("SkipLayerNormalization",i,{epsilon:c})},1437786:i=>o.wb(i),1437819:i=>o.yb(i),1437851:(i,c,h)=>{o.jb(i,c,h,!0)},1437890:(i,c,h)=>{o.jb(i,c,h)}};function vt(i){this.name="ExitStatus",this.message=`Program terminated with exit(${i})`,this.status=i}function Gt(i){i.terminate(),i.onmessage=()=>{}}function Lt(i){(i=ne.Qa[i])||Qe(),ne.Eb(i)}function Qt(i){var c=ne.tb();if(!c)return 6;ne.Ya.push(c),ne.Qa[i.Xa]=c,c.Xa=i.Xa;var h={cmd:"run",start_routine:i.Gb,arg:i.rb,pthread_ptr:i.Xa};return S&&c.unref(),c.postMessage(h,i.Mb),0}var Ft=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,_r=(i,c,h)=>{c>>>=0;var x=c+h;for(h=c;i[h]&&!(h>=x);)++h;if(16<h-c&&i.buffer&&Ft)return Ft.decode(i.buffer instanceof SharedArrayBuffer?i.slice(c,h):i.subarray(c,h));for(x="";c<h;){var E=i[c++];if(E&128){var R=i[c++]&63;if((E&224)==192)x+=String.fromCharCode((E&31)<<6|R);else{var U=i[c++]&63;E=(E&240)==224?(E&15)<<12|R<<6|U:(E&7)<<18|R<<12|U<<6|i[c++]&63,65536>E?x+=String.fromCharCode(E):(E-=65536,x+=String.fromCharCode(55296|E>>10,56320|E&1023))}}else x+=String.fromCharCode(E)}return x},Ue=(i,c)=>(i>>>=0)?_r(a(),i,c):"";function er(i){if(C)return N(1,1,i);Ee=i,rt()||(ne.Hb(),o.onExit&&o.onExit(i),Te=!0),y(i,new vt(i))}var tr=i=>{if(Ee=i,C)throw Or(i),"unwind";er(i)},ne={ab:[],Ya:[],mb:[],Qa:{},gb:function(){C?ne.vb():ne.ub()},ub:function(){He.unshift(()=>{Xt(),ne.Bb(()=>Ar())})},vb:function(){ne.receiveObjectTransfer=ne.Db,ne.threadInitTLS=ne.lb,ne.setExitStatus=ne.kb,ie=!1},kb:function(i){Ee=i},Sb:["$terminateWorker"],Hb:function(){for(var i of ne.Ya)Gt(i);for(i of ne.ab)Gt(i);ne.ab=[],ne.Ya=[],ne.Qa=[]},Eb:function(i){var c=i.Xa;delete ne.Qa[c],ne.ab.push(i),ne.Ya.splice(ne.Ya.indexOf(i),1),i.Xa=0,Rn(c)},Db:function(){},lb:function(){ne.mb.forEach(i=>i())},Cb:i=>new Promise(c=>{i.onmessage=R=>{R=R.data;var U=R.cmd;if(R.targetThread&&R.targetThread!=Ur()){var oe=ne.Qa[R.Rb];oe?oe.postMessage(R,R.transferList):q('Internal error! Worker sent a message "'+U+'" to target pthread '+R.targetThread+", but that thread no longer exists!")}else U==="checkMailbox"?kt():U==="spawnThread"?Qt(R):U==="cleanupThread"?Lt(R.thread):U==="killThread"?(R=R.thread,U=ne.Qa[R],delete ne.Qa[R],Gt(U),Rn(R),ne.Ya.splice(ne.Ya.indexOf(U),1),U.Xa=0):U==="cancelThread"?ne.Qa[R.thread].postMessage({cmd:"cancel"}):U==="loaded"?(i.loaded=!0,c(i)):U==="alert"?alert("Thread "+R.threadId+": "+R.text):R.target==="setimmediate"?i.postMessage(R):U==="callHandler"?o[R.handler](...R.args):U&&q("worker sent an unknown command "+U)},i.onerror=R=>{throw q("worker sent an error! "+R.filename+":"+R.lineno+": "+R.message),R},S&&(i.on("message",function(R){i.onmessage({data:R})}),i.on("error",function(R){i.onerror(R)}));var h=[],x=["onExit","onAbort","print","printErr"],E;for(E of x)o.hasOwnProperty(E)&&h.push(E);i.postMessage({cmd:"load",handlers:h,urlOrBlob:o.mainScriptUrlOrBlob||e,wasmMemory:we,wasmModule:Se})}),Bb:function(i){i()},qb:function(){var i=P("ort-wasm-simd-threaded.worker.js");i=new Worker(i),ne.ab.push(i)},tb:function(){return ne.ab.length==0&&(ne.qb(),ne.Cb(ne.ab[0])),ne.ab.pop()}};o.PThread=ne;var mt=i=>{for(;0<i.length;)i.shift()(o)};o.establishStackSpace=function(){var i=Ur(),c=n()[i+52>>2>>>0];i=n()[i+56>>2>>>0],La(c,c-i),Vr(c)};function Or(i){if(C)return N(2,0,i);tr(i)}o.invokeEntryPoint=function(i,c){i=Fa.apply(null,[i,c]),rt()?ne.kb(i):kn(i)};function nt(i){this.fb=i-24,this.pb=function(c){s()[this.fb+4>>2>>>0]=c},this.ob=function(c){s()[this.fb+8>>2>>>0]=c},this.gb=function(c,h){this.nb(),this.pb(c),this.ob(h)},this.nb=function(){s()[this.fb+16>>2>>>0]=0}}var Je=0,Tr=0;function Tt(i,c,h,x){return C?N(3,1,i,c,h,x):rr(i,c,h,x)}function rr(i,c,h,x){if(i>>>=0,c>>>=0,h>>>=0,x>>>=0,typeof SharedArrayBuffer>"u")return q("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var E=[];return C&&E.length===0?Tt(i,c,h,x):(i={Gb:h,Xa:i,rb:x,Mb:E},C?(i.Ob="spawnThread",postMessage(i,E),0):Qt(i))}function nr(i,c,h){return C?N(4,1,i,c,h):0}function Rr(i,c){if(C)return N(5,1,i,c)}var Rt=i=>{for(var c=0,h=0;h<i.length;++h){var x=i.charCodeAt(h);127>=x?c++:2047>=x?c+=2:55296<=x&&57343>=x?(c+=4,++h):c+=3}return c},kr=(i,c,h,x)=>{if(h>>>=0,!(0<x))return 0;var E=h;x=h+x-1;for(var R=0;R<i.length;++R){var U=i.charCodeAt(R);if(55296<=U&&57343>=U){var oe=i.charCodeAt(++R);U=65536+((U&1023)<<10)|oe&1023}if(127>=U){if(h>=x)break;c[h++>>>0]=U}else{if(2047>=U){if(h+1>=x)break;c[h++>>>0]=192|U>>6}else{if(65535>=U){if(h+2>=x)break;c[h++>>>0]=224|U>>12}else{if(h+3>=x)break;c[h++>>>0]=240|U>>18,c[h++>>>0]=128|U>>12&63}c[h++>>>0]=128|U>>6&63}c[h++>>>0]=128|U&63}}return c[h>>>0]=0,h-E},Pr=(i,c,h)=>kr(i,a(),c,h);function Br(i,c){if(C)return N(6,1,i,c)}function Dr(i,c,h){if(C)return N(7,1,i,c,h)}function Mr(i,c,h){return C?N(8,1,i,c,h):0}function zr(i,c){if(C)return N(9,1,i,c)}function Ht(i,c,h){if(C)return N(10,1,i,c,h)}function ar(i,c,h,x){if(C)return N(11,1,i,c,h,x)}function or(i,c,h,x){if(C)return N(12,1,i,c,h,x)}function ir(i,c,h,x){if(C)return N(13,1,i,c,h,x)}function sr(i){if(C)return N(14,1,i)}function ur(i,c){if(C)return N(15,1,i,c)}function lr(i,c,h){if(C)return N(16,1,i,c,h)}var dr=i=>{if(!Te)try{if(i(),!rt())try{C?kn(Ee):tr(Ee)}catch(c){c instanceof vt||c=="unwind"||y(1,c)}}catch(c){c instanceof vt||c=="unwind"||y(1,c)}};function jt(i){i>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(n(),i>>2,i).value.then(kt),i+=128,Atomics.store(n(),i>>2,1))}o.__emscripten_thread_mailbox_await=jt;function kt(){var i=Ur();i&&(jt(i),dr(()=>Va()))}o.checkMailbox=kt;var $t=i=>i%4===0&&(i%100!==0||i%400===0),Pt=[0,31,60,91,121,152,182,213,244,274,305,335],cr=[0,31,59,90,120,151,181,212,243,273,304,334];function d(i,c,h,x,E,R,U,oe){return C?N(17,1,i,c,h,x,E,R,U,oe):-52}function f(i,c,h,x,E,R,U){if(C)return N(18,1,i,c,h,x,E,R,U)}var b=i=>{var c=Rt(i)+1,h=Tn(c);return h&&Pr(i,h,c),h},I=[],A=(i,c)=>{I.length=0;var h;for(c>>=2;h=a()[i++>>>0];)c+=h!=105&c,I.push(h==105?n()[c>>>0]:l()[c++>>>1]),++c;return I},V=i=>{var c=Pn();return i=i(),Vr(c),i};function N(i,c){var h=arguments.length-2,x=arguments;return V(()=>{for(var E=Bn(8*h),R=E>>3,U=0;U<h;U++){var oe=x[2+U];l()[R+U>>>0]=oe}return Ua(i,h,E,c)})}var ae=[],K={},Q=()=>{if(!J){var i={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"},c;for(c in K)K[c]===void 0?delete i[c]:i[c]=K[c];var h=[];for(c in i)h.push(`${c}=${i[c]}`);J=h}return J},J;function ce(i,c){if(C)return N(19,1,i,c);i>>>=0,c>>>=0;var h=0;return Q().forEach(function(x,E){var R=c+h;for(E=s()[i+4*E>>2>>>0]=R,R=0;R<x.length;++R)r()[E++>>0>>>0]=x.charCodeAt(R);r()[E>>0>>>0]=0,h+=x.length+1}),0}function me(i,c){if(C)return N(20,1,i,c);i>>>=0,c>>>=0;var h=Q();s()[i>>2>>>0]=h.length;var x=0;return h.forEach(function(E){x+=E.length+1}),s()[c>>2>>>0]=x,0}function _(i){return C?N(21,1,i):52}function te(i,c,h,x){return C?N(22,1,i,c,h,x):52}function fe(i,c,h,x,E){return C?N(23,1,i,c,h,x,E):70}var ht=[null,[],[]];function pr(i,c,h,x){if(C)return N(24,1,i,c,h,x);c>>>=0,h>>>=0,x>>>=0;for(var E=0,R=0;R<h;R++){var U=s()[c>>2>>>0],oe=s()[c+4>>2>>>0];c+=8;for(var ee=0;ee<oe;ee++){var Z=a()[U+ee>>>0],re=ht[i];Z===0||Z===10?((i===1?D:q)(_r(re,0)),re.length=0):re.push(Z)}E+=oe}return s()[x>>2>>>0]=E,0}var ka=[31,29,31,30,31,30,31,31,30,31,30,31],Pa=[31,28,31,30,31,30,31,31,30,31,30,31];function El(i){var c=Array(Rt(i)+1);return kr(i,c,0,c.length),c}var _l=(i,c)=>{r().set(i,c>>>0)};function Ba(i,c,h,x){function E(O,ue,ye){for(O=typeof O=="number"?O.toString():O||"";O.length<ue;)O=ye[0]+O;return O}function R(O,ue){return E(O,ue,"0")}function U(O,ue){function ye(Xa){return 0>Xa?-1:0<Xa?1:0}var Bt;return(Bt=ye(O.getFullYear()-ue.getFullYear()))===0&&(Bt=ye(O.getMonth()-ue.getMonth()))===0&&(Bt=ye(O.getDate()-ue.getDate())),Bt}function oe(O){switch(O.getDay()){case 0:return new Date(O.getFullYear()-1,11,29);case 1:return O;case 2:return new Date(O.getFullYear(),0,3);case 3:return new Date(O.getFullYear(),0,2);case 4:return new Date(O.getFullYear(),0,1);case 5:return new Date(O.getFullYear()-1,11,31);case 6:return new Date(O.getFullYear()-1,11,30)}}function ee(O){var ue=O.Za;for(O=new Date(new Date(O.$a+1900,0,1).getTime());0<ue;){var ye=O.getMonth(),Bt=($t(O.getFullYear())?ka:Pa)[ye];if(ue>Bt-O.getDate())ue-=Bt-O.getDate()+1,O.setDate(1),11>ye?O.setMonth(ye+1):(O.setMonth(0),O.setFullYear(O.getFullYear()+1));else{O.setDate(O.getDate()+ue);break}}return ye=new Date(O.getFullYear()+1,0,4),ue=oe(new Date(O.getFullYear(),0,4)),ye=oe(ye),0>=U(ue,O)?0>=U(ye,O)?O.getFullYear()+1:O.getFullYear():O.getFullYear()-1}i>>>=0,c>>>=0,h>>>=0,x>>>=0;var Z=n()[x+40>>2>>>0];x={Kb:n()[x>>2>>>0],Jb:n()[x+4>>2>>>0],cb:n()[x+8>>2>>>0],ib:n()[x+12>>2>>>0],eb:n()[x+16>>2>>>0],$a:n()[x+20>>2>>>0],Wa:n()[x+24>>2>>>0],Za:n()[x+28>>2>>>0],Tb:n()[x+32>>2>>>0],Ib:n()[x+36>>2>>>0],Lb:Z?Ue(Z):""},h=Ue(h),Z={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var re in Z)h=h.replace(new RegExp(re,"g"),Z[re]);var he="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),be="January February March April May June July August September October November December".split(" ");Z={"%a":O=>he[O.Wa].substring(0,3),"%A":O=>he[O.Wa],"%b":O=>be[O.eb].substring(0,3),"%B":O=>be[O.eb],"%C":O=>R((O.$a+1900)/100|0,2),"%d":O=>R(O.ib,2),"%e":O=>E(O.ib,2," "),"%g":O=>ee(O).toString().substring(2),"%G":O=>ee(O),"%H":O=>R(O.cb,2),"%I":O=>(O=O.cb,O==0?O=12:12<O&&(O-=12),R(O,2)),"%j":O=>{for(var ue=0,ye=0;ye<=O.eb-1;ue+=($t(O.$a+1900)?ka:Pa)[ye++]);return R(O.ib+ue,3)},"%m":O=>R(O.eb+1,2),"%M":O=>R(O.Jb,2),"%n":()=>`
`,"%p":O=>0<=O.cb&&12>O.cb?"AM":"PM","%S":O=>R(O.Kb,2),"%t":()=>"	","%u":O=>O.Wa||7,"%U":O=>R(Math.floor((O.Za+7-O.Wa)/7),2),"%V":O=>{var ue=Math.floor((O.Za+7-(O.Wa+6)%7)/7);if(2>=(O.Wa+371-O.Za-2)%7&&ue++,ue)ue==53&&(ye=(O.Wa+371-O.Za)%7,ye==4||ye==3&&$t(O.$a)||(ue=1));else{ue=52;var ye=(O.Wa+7-O.Za-1)%7;(ye==4||ye==5&&$t(O.$a%400-1))&&ue++}return R(ue,2)},"%w":O=>O.Wa,"%W":O=>R(Math.floor((O.Za+7-(O.Wa+6)%7)/7),2),"%y":O=>(O.$a+1900).toString().substring(2),"%Y":O=>O.$a+1900,"%z":O=>{O=O.Ib;var ue=0<=O;return O=Math.abs(O)/60,(ue?"+":"-")+("0000"+(O/60*100+O%60)).slice(-4)},"%Z":O=>O.Lb,"%%":()=>"%"},h=h.replace(/%%/g,"\0\0");for(re in Z)h.includes(re)&&(h=h.replace(new RegExp(re,"g"),Z[re](x)));return h=h.replace(/\0\0/g,"%"),re=El(h),re.length>c?0:(_l(re,i),re.length-1)}function Wr(i){try{i()}catch(c){Qe(c)}}function Ol(i){var c={},h;for(h in i)(function(x){var E=i[x];c[x]=typeof E=="function"?function(){Nr.push(x);try{return E.apply(null,arguments)}finally{Te||(Nr.pop()===x||Qe(),at&&xt===1&&Nr.length===0&&(xt=0,Ge+=1,Wr(ja),typeof Fibers<"u"&&Fibers.Ub()))}}:E})(h);return c}var xt=0,at=null,Da=0,Nr=[],Ma={},za={},Tl=0,On=null,Rl=[];function kl(){return new Promise((i,c)=>{On={resolve:i,reject:c}})}function Pl(){var i=Tn(65548),c=i+12;s()[i>>2>>>0]=c,s()[i+4>>2>>>0]=c+65536,c=Nr[0];var h=Ma[c];return h===void 0&&(h=Tl++,Ma[c]=h,za[h]=c),c=h,n()[i+8>>2>>>0]=c,i}function Bl(){var i=n()[at+8>>2>>>0];return i=j[za[i]],--Ge,i()}function Dl(i){if(!Te){if(xt===0){var c=!1,h=!1;i((x=0)=>{if(!Te&&(Da=x,c=!0,h)){xt=2,Wr(()=>qa(at)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),x=!1;try{var E=Bl()}catch(oe){E=oe,x=!0}var R=!1;if(!at){var U=On;U&&(On=null,(x?U.reject:U.resolve)(E),R=!0)}if(x&&!R)throw E}}),h=!0,c||(xt=1,at=Pl(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),Wr(()=>Ha(at)))}else xt===2?(xt=0,Wr(Ka),Wa(at),at=null,Rl.forEach(x=>dr(x))):Qe(`invalid state: ${xt}`);return Da}}function Ml(i){return Dl(c=>{i().then(c)})}ne.gb();var zl=[null,er,Or,Tt,nr,Rr,Br,Dr,Mr,zr,Ht,ar,or,ir,sr,ur,lr,d,f,ce,me,_,te,fe,pr],Wl={r:function(i,c,h){return Ml(async()=>{await o.xb(i,c,h)})},b:function(i,c,h){throw i>>>=0,new nt(i).gb(c>>>0,h>>>0),Je=i,Tr++,Je},P:function(i){Na(i>>>0,!v,1,!$,131072,!1),ne.lb()},n:function(i){i>>>=0,C?postMessage({cmd:"cleanupThread",thread:i}):Lt(i)},K:rr,g:nr,V:Rr,F:Br,H:Dr,y:Mr,T:zr,L:Ht,S:ar,p:or,G:ir,D:sr,U:ur,E:lr,q:()=>!0,B:function(i,c){i>>>=0,i==c>>>0?setTimeout(()=>kt()):C?postMessage({targetThread:i,cmd:"checkMailbox"}):(i=ne.Qa[i])&&i.postMessage({cmd:"checkMailbox"})},N:function(){return-1},O:jt,X:function(i){S&&ne.Qa[i>>>0].ref()},u:function(i,c,h){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,h>>>=0,i=new Date(1e3*i),n()[h>>2>>>0]=i.getUTCSeconds(),n()[h+4>>2>>>0]=i.getUTCMinutes(),n()[h+8>>2>>>0]=i.getUTCHours(),n()[h+12>>2>>>0]=i.getUTCDate(),n()[h+16>>2>>>0]=i.getUTCMonth(),n()[h+20>>2>>>0]=i.getUTCFullYear()-1900,n()[h+24>>2>>>0]=i.getUTCDay(),i=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,n()[h+28>>2>>>0]=i},v:function(i,c,h){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,h>>>=0,i=new Date(1e3*i),n()[h>>2>>>0]=i.getSeconds(),n()[h+4>>2>>>0]=i.getMinutes(),n()[h+8>>2>>>0]=i.getHours(),n()[h+12>>2>>>0]=i.getDate(),n()[h+16>>2>>>0]=i.getMonth(),n()[h+20>>2>>>0]=i.getFullYear()-1900,n()[h+24>>2>>>0]=i.getDay(),c=($t(i.getFullYear())?Pt:cr)[i.getMonth()]+i.getDate()-1|0,n()[h+28>>2>>>0]=c,n()[h+36>>2>>>0]=-(60*i.getTimezoneOffset()),c=new Date(i.getFullYear(),6,1).getTimezoneOffset();var x=new Date(i.getFullYear(),0,1).getTimezoneOffset();i=(c!=x&&i.getTimezoneOffset()==Math.min(x,c))|0,n()[h+32>>2>>>0]=i},w:function(i){i>>>=0;var c=new Date(n()[i+20>>2>>>0]+1900,n()[i+16>>2>>>0],n()[i+12>>2>>>0],n()[i+8>>2>>>0],n()[i+4>>2>>>0],n()[i>>2>>>0],0),h=n()[i+32>>2>>>0],x=c.getTimezoneOffset(),E=new Date(c.getFullYear(),6,1).getTimezoneOffset(),R=new Date(c.getFullYear(),0,1).getTimezoneOffset(),U=Math.min(R,E);return 0>h?n()[i+32>>2>>>0]=+(E!=R&&U==x):0<h!=(U==x)&&(E=Math.max(R,E),c.setTime(c.getTime()+6e4*((0<h?U:E)-x))),n()[i+24>>2>>>0]=c.getDay(),h=($t(c.getFullYear())?Pt:cr)[c.getMonth()]+c.getDate()-1|0,n()[i+28>>2>>>0]=h,n()[i>>2>>>0]=c.getSeconds(),n()[i+4>>2>>>0]=c.getMinutes(),n()[i+8>>2>>>0]=c.getHours(),n()[i+12>>2>>>0]=c.getDate(),n()[i+16>>2>>>0]=c.getMonth(),n()[i+20>>2>>>0]=c.getYear(),i=c.getTime()/1e3,Ga((ft=i,1<=+Math.abs(ft)?0<ft?+Math.floor(ft/4294967296)>>>0:~~+Math.ceil((ft-+(~~ft>>>0))/4294967296)>>>0:0)),i>>>0},s:d,t:f,A:function(i,c,h){function x(Z){return(Z=Z.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Z[1]:"GMT"}i>>>=0,c>>>=0,h>>>=0;var E=new Date().getFullYear(),R=new Date(E,0,1),U=new Date(E,6,1);E=R.getTimezoneOffset();var oe=U.getTimezoneOffset(),ee=Math.max(E,oe);s()[i>>2>>>0]=60*ee,n()[c>>2>>>0]=+(E!=oe),i=x(R),c=x(U),i=b(i),c=b(c),oe<E?(s()[h>>2>>>0]=i,s()[h+4>>2>>>0]=c):(s()[h>>2>>>0]=c,s()[h+4>>2>>>0]=i)},e:()=>{Qe("")},c:function(i,c,h){return i>>>=0,c=A(c>>>0,h>>>0),Vt[i].apply(null,c)},l:function(i,c,h){return i>>>=0,c=A(c>>>0,h>>>0),Vt[i].apply(null,c)},o:function(){},k:function(){return Date.now()},W:()=>{throw Ge+=1,"unwind"},C:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),j:function(){return S?(Bo(),St(Po)).cpus().length:navigator.hardwareConcurrency},M:function(i,c,h,x){for(ne.Pb=c>>>0,ae.length=h,c=x>>>0>>3,x=0;x<h;x++)ae[x]=l()[c+x>>>0];return(0>i?Vt[-i-1]:zl[i]).apply(null,ae)},z:function(i){i>>>=0;var c=a().length;if(i<=c||4294901760<i)return!1;for(var h=1;4>=h;h*=2){var x=c*(1+.2/h);x=Math.min(x,i+100663296);var E=Math;x=Math.max(i,x);e:{E=E.min.call(E,4294901760,x+(65536-x%65536)%65536)-we.buffer.byteLength+65535>>>16;try{we.grow(E),pe();var R=1;break e}catch{}R=void 0}if(R)return!0}return!1},Q:ce,R:me,J:tr,h:_,m:te,x:fe,i:pr,a:we||o.wasmMemory,I:Ba,d:function(i,c,h,x){return Ba(i>>>0,c>>>0,h>>>0,x>>>0)}};(function(){function i(h,x){return h=h.exports,h=Ol(h),j=h=Nl(h),ne.mb.push(j.Da),Oe.unshift(j.Y),Se=x,Ar(),h}var c={a:Wl};if(Xt(),o.instantiateWasm)try{return o.instantiateWasm(c,i)}catch(h){q("Module.instantiateWasm callback failed with error: "+h),m(h)}return Er(c,function(h){i(h.instance,h.module)}).catch(m),{}})(),o._OrtInit=(i,c)=>(o._OrtInit=j.Z)(i,c),o._OrtGetLastError=(i,c)=>(o._OrtGetLastError=j._)(i,c),o._OrtCreateSessionOptions=(i,c,h,x,E,R,U,oe,ee,Z)=>(o._OrtCreateSessionOptions=j.$)(i,c,h,x,E,R,U,oe,ee,Z),o._OrtAppendExecutionProvider=(i,c)=>(o._OrtAppendExecutionProvider=j.aa)(i,c),o._OrtAddFreeDimensionOverride=(i,c,h)=>(o._OrtAddFreeDimensionOverride=j.ba)(i,c,h),o._OrtAddSessionConfigEntry=(i,c,h)=>(o._OrtAddSessionConfigEntry=j.ca)(i,c,h),o._OrtReleaseSessionOptions=i=>(o._OrtReleaseSessionOptions=j.da)(i),o._OrtCreateSession=(i,c,h)=>(o._OrtCreateSession=j.ea)(i,c,h),o._OrtReleaseSession=i=>(o._OrtReleaseSession=j.fa)(i),o._OrtGetInputOutputCount=(i,c,h)=>(o._OrtGetInputOutputCount=j.ga)(i,c,h),o._OrtGetInputName=(i,c)=>(o._OrtGetInputName=j.ha)(i,c),o._OrtGetOutputName=(i,c)=>(o._OrtGetOutputName=j.ia)(i,c),o._OrtFree=i=>(o._OrtFree=j.ja)(i),o._OrtCreateTensor=(i,c,h,x,E,R)=>(o._OrtCreateTensor=j.ka)(i,c,h,x,E,R),o._OrtGetTensorData=(i,c,h,x,E)=>(o._OrtGetTensorData=j.la)(i,c,h,x,E),o._OrtReleaseTensor=i=>(o._OrtReleaseTensor=j.ma)(i),o._OrtCreateRunOptions=(i,c,h,x)=>(o._OrtCreateRunOptions=j.na)(i,c,h,x),o._OrtAddRunConfigEntry=(i,c,h)=>(o._OrtAddRunConfigEntry=j.oa)(i,c,h),o._OrtReleaseRunOptions=i=>(o._OrtReleaseRunOptions=j.pa)(i),o._OrtCreateBinding=i=>(o._OrtCreateBinding=j.qa)(i),o._OrtBindInput=(i,c,h)=>(o._OrtBindInput=j.ra)(i,c,h),o._OrtBindOutput=(i,c,h,x)=>(o._OrtBindOutput=j.sa)(i,c,h,x),o._OrtClearBoundOutputs=i=>(o._OrtClearBoundOutputs=j.ta)(i),o._OrtReleaseBinding=i=>(o._OrtReleaseBinding=j.ua)(i),o._OrtRunWithBinding=(i,c,h,x,E)=>(o._OrtRunWithBinding=j.va)(i,c,h,x,E),o._OrtRun=(i,c,h,x,E,R,U,oe)=>(o._OrtRun=j.wa)(i,c,h,x,E,R,U,oe),o._OrtEndProfiling=i=>(o._OrtEndProfiling=j.xa)(i),o._JsepOutput=(i,c,h)=>(o._JsepOutput=j.ya)(i,c,h),o._JsepGetNodeName=i=>(o._JsepGetNodeName=j.za)(i);var Ur=o._pthread_self=()=>(Ur=o._pthread_self=j.Aa)(),Tn=o._malloc=i=>(Tn=o._malloc=j.Ba)(i),Wa=o._free=i=>(Wa=o._free=j.Ca)(i);o.__emscripten_tls_init=()=>(o.__emscripten_tls_init=j.Da)();var Na=o.__emscripten_thread_init=(i,c,h,x,E,R)=>(Na=o.__emscripten_thread_init=j.Fa)(i,c,h,x,E,R);o.__emscripten_thread_crashed=()=>(o.__emscripten_thread_crashed=j.Ga)();var Ua=(i,c,h,x)=>(Ua=j.Ha)(i,c,h,x),Rn=i=>(Rn=j.Ia)(i),kn=o.__emscripten_thread_exit=i=>(kn=o.__emscripten_thread_exit=j.Ja)(i),Va=o.__emscripten_check_mailbox=()=>(Va=o.__emscripten_check_mailbox=j.Ka)(),Ga=i=>(Ga=j.La)(i),La=(i,c)=>(La=j.Ma)(i,c),Pn=()=>(Pn=j.Na)(),Vr=i=>(Vr=j.Oa)(i),Bn=i=>(Bn=j.Pa)(i),Fa=o.dynCall_ii=(i,c)=>(Fa=o.dynCall_ii=j.Ra)(i,c),Ha=i=>(Ha=j.Sa)(i),ja=()=>(ja=j.Ta)(),qa=i=>(qa=j.Ua)(i),Ka=()=>(Ka=j.Va)();o.___start_em_js=1437923,o.___stop_em_js=1438084;function Nl(i){i=Object.assign({},i);var c=x=>()=>x()>>>0,h=x=>E=>x(E)>>>0;return i.__errno_location=c(i.__errno_location),i.pthread_self=c(i.pthread_self),i.malloc=h(i.malloc),i.stackSave=c(i.stackSave),i.stackAlloc=h(i.stackAlloc),i}o.keepRuntimeAlive=rt,o.wasmMemory=we,o.stackAlloc=Bn,o.stackSave=Pn,o.stackRestore=Vr,o.UTF8ToString=Ue,o.stringToUTF8=Pr,o.lengthBytesUTF8=Rt,o.ExitStatus=vt,o.PThread=ne;var Gr;Ot=function i(){Gr||Ya(),Gr||(Ot=i)};function Ya(){function i(){if(!Gr&&(Gr=!0,o.calledRun=!0,!Te)&&(C||mt(Oe),p(o),o.onRuntimeInitialized&&o.onRuntimeInitialized(),!C)){if(o.postRun)for(typeof o.postRun=="function"&&(o.postRun=[o.postRun]);o.postRun.length;){var c=o.postRun.shift();ze.unshift(c)}mt(ze)}}if(!(0<Xe))if(C)p(o),C||mt(Oe),startWorker(o);else{if(o.preRun)for(typeof o.preRun=="function"&&(o.preRun=[o.preRun]);o.preRun.length;)He.unshift(o.preRun.shift());mt(He),0<Xe||(o.setStatus?(o.setStatus("Running..."),setTimeout(function(){setTimeout(function(){o.setStatus("")},1),i()},1)):i())}}if(o.preInit)for(typeof o.preInit=="function"&&(o.preInit=[o.preInit]);0<o.preInit.length;)o.preInit.pop()();return Ya(),t.ready}})();typeof Mo=="object"&&typeof Hn=="object"?Hn.exports=Do:typeof define=="function"&&define.amd&&define([],()=>Do)});var Wo=qt((Ef,Kl)=>{Kl.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\n'});var Uo,Yl,jn,qn,Zr,No,Xl,Jl,Zl,Vo,ke,Kt=F(()=>{"use strict";Uo=To();Yl=zo(),qn=!1,Zr=!1,No=!1,Xl=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},Jl=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Zl=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Vo=async e=>{if(qn)return Promise.resolve();if(Zr)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(No)throw new Error("previous call to 'initializeWebAssembly()' failed.");Zr=!0;let t=e.initTimeout,r=e.numThreads,a=e.simd,n=r>1&&Xl(),s=a&&Jl(),u=e.wasmPaths,l=typeof u=="string"?u:void 0,o=Zl(s,n),p=typeof u=="object"?u[o]:void 0,m=!1,w=[];if(t>0&&w.push(new Promise(g=>{setTimeout(()=>{m=!0,g()},t)})),w.push(new Promise((g,y)=>{let $=n?Yl:Uo,v={locateFile:(S,C)=>{if(n&&S.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Wo()],{type:"text/javascript"}));if(S.endsWith(".wasm")){if(p)return p;let T=l??C;return o==="ort-wasm-simd.wasm"?T+"ort-wasm-simd.jsep.wasm":o==="ort-wasm-simd-threaded.wasm"?T+"ort-wasm-simd-threaded.jsep.wasm":T+o}return C+S}};if(n)if(typeof Blob>"u")v.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let S=`var ortWasmThreaded=${$.toString()};`;v.mainScriptUrlOrBlob=new Blob([S],{type:"text/javascript"})}$(v).then(S=>{Zr=!1,qn=!0,jn=S,g()},S=>{Zr=!1,No=!0,y(S)})})),await Promise.race(w),m)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},ke=()=>{if(qn&&jn)return jn;throw new Error("WebAssembly is not initialized yet.")}});var De,hr,Ae,Qr=F(()=>{"use strict";Kt();De=(e,t)=>{let r=ke(),a=r.lengthBytesUTF8(e)+1,n=r._malloc(a);return r.stringToUTF8(e,n,a),t.push(n),n},hr=(e,t,r,a)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([n,s])=>{let u=t?t+n:n;if(typeof s=="object")hr(s,u+".",r,a);else if(typeof s=="string"||typeof s=="number")a(u,s.toString());else if(typeof s=="boolean")a(u,s?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof s}`)})},Ae=e=>{let t=ke(),r=t.stackSave();try{let a=t.stackAlloc(8);t._OrtGetLastError(a,a+4);let n=t.HEAP32[a/4],s=t.HEAPU32[a/4+1],u=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${u}`)}finally{t.stackRestore(r)}}});var Go,Lo=F(()=>{"use strict";Kt();Qr();Go=e=>{let t=ke(),r=0,a=[],n=e||{};try{if(e?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(n.terminate=!1);let s=0;return e?.tag!==void 0&&(s=De(e.tag,a)),r=t._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,s),r===0&&Ae("Can't create run options."),e?.extra!==void 0&&hr(e.extra,"",new WeakSet,(u,l)=>{let o=De(u,a),p=De(l,a);t._OrtAddRunConfigEntry(r,o,p)!==0&&Ae(`Can't set a run config entry: ${u} - ${l}.`)}),[r,a]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),a.forEach(u=>t._free(u)),s}}});var Ql,ed,td,rd,Fo,Ho=F(()=>{"use strict";Kt();Qr();Ql=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},ed=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},td=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},rd=(e,t,r)=>{for(let a of t){let n=typeof a=="string"?a:a.name;switch(n){case"xnnpack":n="XNNPACK";break;case"webnn":if(n="WEBNN",typeof a!="string"){let u=a;if(u?.deviceType){let l=De("deviceType",r),o=De(u.deviceType,r);ke()._OrtAddSessionConfigEntry(e,l,o)!==0&&Ae(`Can't set a session config entry: 'deviceType' - ${u.deviceType}.`)}if(u?.powerPreference){let l=De("powerPreference",r),o=De(u.powerPreference,r);ke()._OrtAddSessionConfigEntry(e,l,o)!==0&&Ae(`Can't set a session config entry: 'powerPreference' - ${u.powerPreference}.`)}}break;case"webgpu":if(n="JS",typeof a!="string"){let u=a;if(u?.preferredLayout){if(u.preferredLayout!=="NCHW"&&u.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${u.preferredLayout}`);let l=De("preferredLayout",r),o=De(u.preferredLayout,r);ke()._OrtAddSessionConfigEntry(e,l,o)!==0&&Ae(`Can't set a session config entry: 'preferredLayout' - ${u.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let s=De(n,r);ke()._OrtAppendExecutionProvider(e,s)!==0&&Ae(`Can't append execution provider: ${n}.`)}},Fo=e=>{let t=ke(),r=0,a=[],n=e||{};td(n);try{let s=Ql(n.graphOptimizationLevel??"all"),u=ed(n.executionMode??"sequential"),l=typeof n.logId=="string"?De(n.logId,a):0,o=n.logSeverityLevel??2;if(!Number.isInteger(o)||o<0||o>4)throw new Error(`log serverity level is not valid: ${o}`);let p=n.logVerbosityLevel??0;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log verbosity level is not valid: ${p}`);let m=typeof n.optimizedModelFilePath=="string"?De(n.optimizedModelFilePath,a):0;if(r=t._OrtCreateSessionOptions(s,!!n.enableCpuMemArena,!!n.enableMemPattern,u,!!n.enableProfiling,0,l,o,p,m),r===0&&Ae("Can't create session options."),n.executionProviders&&rd(r,n.executionProviders,a),n.freeDimensionOverrides)for(let[w,g]of Object.entries(n.freeDimensionOverrides)){if(typeof w!="string")throw new Error(`free dimension override name must be a string: ${w}`);if(typeof g!="number"||!Number.isInteger(g)||g<0)throw new Error(`free dimension override value must be a non-negative integer: ${g}`);let y=De(w,a);t._OrtAddFreeDimensionOverride(r,y,g)!==0&&Ae(`Can't set a free dimension override: ${w} - ${g}.`)}return n.extra!==void 0&&hr(n.extra,"",new WeakSet,(w,g)=>{let y=De(w,a),$=De(g,a);t._OrtAddSessionConfigEntry(r,y,$)!==0&&Ae(`Can't set a session config entry: ${w} - ${g}.`)}),[r,a]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),a.forEach(u=>t._free(u)),s}}});var Kn,gr,yr,en,br,tn,Yn,Me=F(()=>{"use strict";Kn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},gr=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},yr=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],en=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},br=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},tn=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",Yn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var nd,ad,jo,qo,Ko,od,_e,Ct=F(()=>{"use strict";Me();nd=["V","I","W","E","F"],ad=(e,t)=>{console.log(`[${nd[e]},${new Date().toISOString()}]${t}`)},Ko=(e,t)=>{jo=e,qo=t},od=(e,t)=>{let r=br(e),a=br(jo);r>=a&&ad(r,typeof t=="function"?t():t)},_e=(...e)=>{qo&&od(...e)}});var Yo,Xo=F(()=>{"use strict";Me();Yo=(e,t)=>new(en(t))(e)});var rn=F(()=>{"use strict"});var nn,id,Jo,Jn,Xn,Zo,Qo=F(()=>{"use strict";Ct();rn();nn=e=>Math.ceil(e/16)*16,id=1,Jo=()=>id++,Jn=async(e,t,r,a)=>{let n=nn(r),s=e.device.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=e.getCommandEncoder();e.endComputePass(),u.copyBufferToBuffer(t,0,s,0,n),e.flush(),await s.mapAsync(GPUMapMode.READ);let l=s.getMappedRange();if(a){let o=a();return o.set(new Uint8Array(l,0,r)),o}else return new Uint8Array(l.slice(0,r))}finally{s.destroy()}},Xn=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let a=r.buffer,n=r.byteOffset,s=r.byteLength,u=nn(s),l=this.storageCache.get(t);if(!l)throw new Error("gpu data for uploading does not exist");if(l.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${l.originalSize}, data size=${s}`);let o=this.backend.device.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),p=o.getMappedRange();new Uint8Array(p).set(new Uint8Array(a,n,s)),o.unmap();let m=this.backend.getCommandEncoder();this.backend.endComputePass(),m.copyBufferToBuffer(o,0,l.gpuData.buffer,0,u),_e("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(o)}memcpy(t,r){let a=this.storageCache.get(t);if(!a)throw new Error("source gpu data for memcpy does not exist");let n=this.storageCache.get(r);if(!n)throw new Error("destination gpu data for memcpy does not exist");if(a.originalSize!==n.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=nn(a.originalSize),u=this.backend.getCommandEncoder();this.backend.endComputePass(),u.copyBufferToBuffer(a.gpuData.buffer,0,n.gpuData.buffer,0,s)}registerExternalBuffer(t,r,a){let n;if(a){if(n=this.externalBuffers.get(a),n===void 0)throw new Error("previous buffer is not registered");if(t===a)return _e("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, buffer is the same, skip.`),n;this.externalBuffers.delete(a)}else n=Jo();return this.storageCache.set(n,{gpuData:{id:n,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,n),_e("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, registered.`),n}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),_e("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let a=nn(t),n,s=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,u=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||u){let o=s?this.freeBuffers:this.freeUniformBuffers,p=o.get(a);p||(p=[],o.set(a,p)),p.length>0?n=p.pop():n=this.backend.device.createBuffer({size:a,usage:r})}else n=this.backend.device.createBuffer({size:a,usage:r});let l={id:Jo(),type:0,buffer:n};return this.storageCache.set(l.id,{gpuData:l,originalSize:t}),_e("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${l.id}`),l}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return _e("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let a=this.storageCache.get(t);if(!a)throw new Error("data does not exist");await Jn(this.backend,a.gpuData.buffer,a.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},Zo=(...e)=>new Xn(...e)});var Zn,se,Pe=F(()=>{"use strict";Zn=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this._cacheKey}},se=e=>new Zn(e)});var Qn,it,M,zt,an,on,sn,ge=F(()=>{"use strict";Qn=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},it=class{static calcShape(t,r,a=!1){let n=t.length,s=r.length;if(n===0)return r;if(s===0)return t;let u=Math.max(t.length,r.length),l=new Array(u);if(a){if(n<2||s<2)return;let o=Qn.calcMatMulShape([t[n-2],t[n-1]],[r[s-2],r[s-1]]);if(o===void 0)return;[l[u-2],l[u-1]]=o}for(let o=a?3:1;o<=u;o++){let p=n-o<0?1:t[n-o],m=s-o<0?1:r[s-o];if(p!==m&&p>1&&m>1)return;l[u-o]=Math.max(p,m)}return l}static isValidBroadcast(t,r){let a=t.length,n=r.length;if(a>n)return!1;for(let s=1;s<=a;s++)if(t[a-s]!==1&&t[a-s]!==r[n-s])return!1;return!0}},M=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,a){let n=1;for(let s=r;s<a;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");n*=t[s]}return n}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let a=new Array(r);a[r-1]=1,a[r-2]=t[r-1];for(let n=r-3;n>=0;--n)a[n]=a[n+1]*t[n+1];return a}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(a=>this.normalizeAxis(a,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(a=>t[a]):t.slice().reverse()}static padShape(t,r){let a=t.length;return t.map((n,s)=>n+r[s]+r[s+a])}static areEqual(t,r){return t.length!==r.length?!1:t.every((a,n)=>a===r[n])}},zt=class e{static adjustPoolAttributes(t,r,a,n,s,u){if(!t&&a.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let l=0;l<r.length-2;l++)l>=a.length?a.push(r[l+2]):a[l]=r[l+2];for(let l=0;l<a.length;l++)if(l<n.length){if(n[l]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let l=0;l<a.length;l++)if(l<s.length){if(s[l]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let l=0;l<a.length*2;l++)if(l<u.length){if(u[l]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let l=0;l<a.length;l++){if(a[l]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[l]>=a[l]||u[l+a.length]>=a[l])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,a,n,s,u,l){if(l){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let o=0;o<t.length-2;o++)e.adjustPadAndReturnShape(t[o+(u?1:2)],r[o],a[o],n[o],s,o,o+t.length-2,l)}}static computePoolOutputShape(t,r,a,n,s,u,l){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let o=[r[0],r[1]];return e.computeShapeHelper(t,r,o,a,n,s,u,l),o}static computeConvOutputShape(t,r,a,n,s,u,l){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let o=[t[0],r[0]];return e.computeShapeHelper(!1,t,o,a,n,s,u,l),o}static computeShapeHelper(t,r,a,n,s,u,l,o){if(t)for(let p=0;p<r.length-2;p++)a.push(1);else for(let p=0;p<r.length-2;p++)a.push(e.adjustPadAndReturnShape(r[p+2],n[p],s[p],u[p],l,p,p+r.length-2,o))}static adjustPadAndReturnShape(t,r,a,n,s,u,l,o){let p=a*(n-1)+1;if(o&&o!=="NOTSET")switch(o){case"VALID":return s[u]=0,s[l]=0,Math.floor((t-p)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(a!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let w=((t+r-1)/r-1)*r+n-t;return s[u]=Math.floor(o==="SAME_LOWER"?(w+1)/2:w/2),s[l]=w-s[u],Math.floor((t+w-n)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[u]+s[l]-p)/r+1)}},an=class{static getShapeOfGemmResult(t,r,a,n,s){if(t.length!==2||a.length!==2)throw new Error("shape need to be of size 2");let u,l,o;r?(u=t[1],l=t[0]):(u=t[0],l=t[1]);let p=-1;if(n?(o=a[0],p=1):(o=a[1],p=0),a[p]!==l)throw new Error("dimension mismatch");if(u<=0||o<=0||l<=0)throw new Error("invalid shape specified");if(s&&!it.isValidBroadcast(s,[u,o]))throw new Error("gemm: invalid bias shape for broadcast");return[u,o,l]}},on=-34028234663852886e22,sn=34028234663852886e22});var sd,ei,Be,Wt,yt,et,Nt,It,ti,L,Y,ea,ri,ta,Yt,ve=F(()=>{"use strict";Me();ge();sd=64,ei=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Be=(e,t=1)=>{let r=ei(e,t);return typeof r=="string"?r:r[0]},Wt=e=>[{type:"uint32",data:e},{type:"uint32",data:M.computeStrides(e)}],yt=e=>e%4===0?4:e%2===0?2:1,et=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,Nt=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,It=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,ti=(e,t,r,a,n)=>{let s=typeof r=="number",u=s?r:r.length,l=[...new Array(u).keys()],o=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,p=ei(t,n),m=typeof p=="string"?p:p[1],w=typeof p=="string"?p:p[0],g={indices:o,value:m,storage:w,tensor:t},y=G=>typeof G=="string"?G:`${G}u`,$={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},v=s?"uniforms.":"",S=`${v}${e}_shape`,C=`${v}${e}_strides`,T="";for(let G=0;G<u-1;G++)T+=`
    let dim${G} = current / ${C}[${G}];
    let rest${G} = current % ${C}[${G}];
    indices[${G}] = dim${G};
    current = rest${G};
    `;T+=`indices[${u-1}] = current;`;let P=u<2?"":`
  fn o2i_${e}(offset: u32) -> ${g.indices} {
    var indices: ${g.indices};
    var current = offset;
    ${T}
    return indices;
  }`,B=G=>($.offsetToIndices=!0,u<2?G:`o2i_${e}(${G})`),z=[];if(u>=2)for(let G=u-1;G>=0;G--)z.push(`${C}[${G}] * (indices[${G}])`);let k=u<2?"":`
  fn i2o_${e}(indices: ${g.indices}) -> u32 {
    return ${z.join("+")};
  }`,W=G=>($.indicesToOffset=!0,u<2?G:`i2o_${e}(${G})`),H=(...G)=>u===0?"0u":`${g.indices}(${G.map(y).join(",")})`,X=(G,de)=>u<2?`${G}`:`${G}[${de}]`,le=(G,de,pe)=>u<2?`${G}=${pe};`:`${G}[${de}]=${pe};`,D={},q=(G,de)=>{$.broadcastedIndicesToOffset=!0;let pe=`${de.name}broadcastedIndicesTo${e}Offset`;if(pe in D)return`${pe}(${G})`;let Ne=[];for(let He=u-1;He>=0;He--){let Oe=de.indicesGet("outputIndices",He+de.rank-u);Ne.push(`${X(C,He)} * (${Oe} % ${X(S,He)})`)}return D[pe]=`fn ${pe}(outputIndices: ${de.type.indices}) -> u32 {
             return ${Ne.length>0?Ne.join("+"):"0u"};
           }`,`${pe}(${G})`},xe=(G,de)=>(()=>{if(g.storage===g.value)return`${e}[${G}]=${de};`;if(g.storage==="vec2<u32>"&&g.value==="i32")return`${e}[${G}]=vec2<u32>(u32(${de}), select(0u, 0xFFFFFFFFu, ${de} < 0));`;if(g.storage==="vec2<u32>"&&g.value==="u32")return`${e}[${G}]=vec2<u32>(u32(${de}), 0u);`;if(g.storage==="u32"&&g.value==="vec4<bool>")return`${e}[${G}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${de}));`;throw new Error(`not supported combination of storage type ${g.storage} and value type ${g.value} yet`)})(),ie=G=>(()=>{if(g.storage===g.value)return`${e}[${G}]`;if(g.storage==="vec2<u32>"&&g.value==="i32")return`i32(${e}[${G}].x)`;if(g.storage==="vec2<u32>"&&g.value==="u32")return`u32(${e}[${G}].x)`;if(g.storage==="u32"&&g.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${G}] & 0xFFu), bool(${e}[${G}] & 0xFF00u), bool(${e}[${G}] & 0xFF0000u), bool(${e}[${G}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${g.storage} and value type ${g.value} yet`)})(),we=u<2?"":`
  fn get_${e}ByIndices(indices: ${g.indices}) -> ${m} {
    return ${ie(`i2o_${e}(indices)`)};
  }`,j=u<2?"":(()=>{let G=l.map(pe=>`d${pe}: u32`).join(", "),de=l.map(pe=>`d${pe}`).join(", ");return`
  fn get_${e}(${G}) -> ${m} {
    return get_${e}ByIndices(${H(de)});
  }`})(),Se=(...G)=>{if(G.length!==u)throw new Error(`indices length must be ${u}`);let de=G.map(y).join(",");return u===0?ie("0u"):u===1?ie(de[0]):($.get=!0,$.getByIndices=!0,$.indicesToOffset=!0,`get_${e}(${de})`)},Te=G=>u<2?ie(G):($.getByIndices=!0,$.indicesToOffset=!0,`get_${e}ByIndices(${G})`),Ee=u<2?"":`
  fn set_${e}ByIndices(indices: ${g.indices}, value: ${m}) {
    ${xe(`i2o_${e}(indices)`,"value")}
  }`,Ce=u<2?"":(()=>{let G=l.map(pe=>`d${pe}: u32`).join(", "),de=l.map(pe=>`d${pe}`).join(", ");return`
  fn set_${e}(${G}, value: ${m}) {
    set_${e}ByIndices(${H(de)}, value);
  }`})();return{impl:()=>{let G=[];return s||(G.push(`const ${S} = ${g.indices}(${r.join(",")});`),G.push(`const ${C} = ${g.indices}(${M.computeStrides(r).join(",")});`)),$.offsetToIndices&&G.push(P),$.indicesToOffset&&G.push(k),$.broadcastedIndicesToOffset&&Object.values(D).forEach(de=>G.push(de)),$.set&&G.push(Ce),$.setByIndices&&G.push(Ee),$.get&&G.push(j),$.getByIndices&&G.push(we),G.join(`
`)},type:g,offsetToIndices:B,indicesToOffset:W,broadcastedIndicesToOffset:q,indices:H,indicesGet:X,indicesSet:le,set:(...G)=>{if(G.length!==u+1)throw new Error(`indices length must be ${u}`);let de=G[u];if(typeof de!="string")throw new Error("value must be string");let pe=G.slice(0,u).map(y).join(",");return u===0?xe("0u",de):u===1?xe(pe[0],de):($.set=!0,$.setByIndices=!0,$.indicesToOffset=!0,`set_${e}(${pe}, ${de})`)},setByOffset:xe,setByIndices:(G,de)=>u<2?xe(G,de):($.setByIndices=!0,$.indicesToOffset=!0,`set_${e}ByIndices(${G}, ${de});`),get:Se,getByOffset:ie,getByIndices:Te,usage:a?"input":"output",name:e,strides:C,shape:S,rank:u}},L=(e,t,r,a=1)=>ti(e,t,r,!0,a),Y=(e,t,r,a=1)=>ti(e,t,r,!1,a),ea=class{constructor(t){this.normalizedDispatchGroup=t;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=sd){let r=typeof t=="number"?t:t[0],a=typeof t=="number"?1:t[1],n=typeof t=="number"?1:t[2],s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,u=s?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>`,l=s?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +
          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${r*a*n}u + local_index;`;return`@compute @workgroup_size(${r}, ${a}, ${n})
  fn main(${u}) {
    ${l}
  `}declareVariable(t,r){this.indicesHelpers.push(t),t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:t.type.indices}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:t.type.indices});let a=t.usage==="input"?"read":"read_write",n=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${a}> ${t.name}: array<${n}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`
`)}registerUniform(t,r){return this.uniforms.push({name:t,type:r}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:a}of this.uniforms)t.push(`${r}:${a}`);return`
      struct Uniforms { ${t.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(t=>t.impl()).join(`
`)}},ri=e=>new ea(e),ta=(e,t)=>{let r=e.length,a=[];for(let n=0;n<r;n++){let s=r-1-n,u=e[s]||1;(t[t.length-1-n]||1)>1&&u===1&&a.unshift(s)}return a},Yt=e=>e<=4&&e>0});var ud,ni,ld,dd,At,ai,oi,wr=F(()=>{"use strict";ge();Pe();ve();ud=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},ni=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,ld=(e,t)=>M.sortBasedOnPerm(e,ni(e.length,t)),dd=(e,t,r,a)=>{let n=[];n.push(`fn perm(i: ${a.type.indices}) -> ${r.type.indices} {
    var a: ${r.type.indices};`);for(let s=0;s<t;++s)n.push(r.indicesSet("a",e[s],`i[${s}]`));return n.push("return a;}"),n.join(`
`)},At=(e,t)=>{let r=e.dataType,a=e.dims.length,n=ni(a,t),s=Yt(a),u=ld(e.dims,n),l=s?u.length:u,o=s?a:e.dims,p=Y("output",r,l),m=L("a",r,o),w=g=>`
  ${g.registerUniform("output_size","u32").declareVariables(m,p)}

  ${dd(n,a,m,p)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${p.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${p.setByOffset("global_idx",m.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:s?["rank"]:["dims"]},getRunData:g=>{let y=M.size(u);return{outputs:[{dims:u,dataType:g[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:s?[{type:"uint32",data:y},...Wt(g[0].dims),...Wt(u)]:[{type:"uint32",data:y}]}},getShaderSource:w}},ai=(e,t)=>{ud(e.inputs),e.compute(At(e.inputs[0],t.perm))},oi=e=>se({perm:e.perm})});var cd,pd,fd,md,hd,gd,yd,bd,wd,vd,st,ii,si,ui,li,di,ci,pi,fi,mi,hi,gi=F(()=>{"use strict";ge();ve();un();wr();cd={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},pd={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},fd={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},md={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},hd=(e,t)=>{let r=[];for(let a=t-e;a<t;++a)r.push(a);return r},gd=(e,t)=>{let r=[],a=e.length;for(let s=0;s<a;s++)t.indexOf(s)===-1&&r.push(e[s]);let n=t.map(s=>e[s]);return[r,n]},yd=(e,t)=>{let r=e.length+t.length,a=[],n=0;for(let s=0;s<r;s++)t.indexOf(s)===-1?a.push(e[n++]):a.push(1);return a},bd=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},wd=(e,t)=>{let r=[];if(!bd(e,t)){for(let a=0;a<t;++a)e.indexOf(a)===-1&&r.push(a);e.forEach(a=>r.push(a))}return r},vd=(e,t,r,a,n,s,u)=>{let l=r[0].dims,o=M.size(s),p=M.size(u),m=L("_A",r[0].dataType,l),w=Y("output",n,s),g=32,y=`
          var<workgroup> aBestValues : array<${w.type.storage}, ${g}>;
       `;return{name:e,shaderCache:t,getShaderSource:v=>`
        ${v.registerUniform("reduceSize","u32").declareVariables(m,w)}
        ${y}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${v.mainStart(g)}
          let local_idx = local_id.x;

          let outputIndex = global_idx / ${g};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = ${w.type.storage}(${fd[a]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${g}) {
           let candidate = ${w.type.storage}(${m.getByOffset("offset + k")});
           bestValue = ${cd[a]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${g}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${pd[a]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${w.setByOffset("outputIndex",`${a==="mean"?`bestValue / ${w.type.storage}(uniforms.reduceSize)`:`${md[a]}`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:s,dataType:n}],dispatchGroup:{x:o},programUniforms:[{type:"uint32",data:p}]})}},st=(e,t,r,a)=>{let n=e.inputs.length===1?r:ra(e.inputs,r),s=n.axes;s.length===0&&!n.noopWithEmptyAxes&&(s=e.inputs[0].dims.map((y,$)=>$));let u=M.normalizeAxes(s,e.inputs[0].dims.length),l=u,o=e.inputs[0],p=wd(l,e.inputs[0].dims.length);p.length>0&&(o=e.compute(At(e.inputs[0],p),{inputs:[0],outputs:[-1]})[0],l=hd(l.length,o.dims.length));let[m,w]=gd(o.dims,l),g=m;n.keepDims&&(g=yd(m,u)),e.compute(vd(t,{hint:n.cacheKey,inputDependencies:["type"]},[o],a,e.inputs[0].dataType,g,w),{inputs:[o]})},ii=(e,t)=>{st(e,"ReduceMeanShared",t,"mean")},si=(e,t)=>{st(e,"ReduceL1Shared",t,"l1")},ui=(e,t)=>{st(e,"ReduceL2Shared",t,"l2")},li=(e,t)=>{st(e,"ReduceLogSumExpShared",t,"logSumExp")},di=(e,t)=>{st(e,"ReduceMaxShared",t,"max")},ci=(e,t)=>{st(e,"ReduceMinShared",t,"min")},pi=(e,t)=>{st(e,"ReduceProdShared",t,"prod")},fi=(e,t)=>{st(e,"ReduceSumShared",t,"sum")},mi=(e,t)=>{st(e,"ReduceSumSquareShared",t,"sumSquare")},hi=(e,t)=>{st(e,"ReduceLogSumShared",t,"logSum")}});var ut,$d,ln,ra,lt,xd,Sd,Cd,Id,Ad,Ed,_d,Od,Td,Rd,dt,yi,bi,wi,vi,$i,xi,Si,Ci,Ii,Ai,tt,un=F(()=>{"use strict";ge();Pe();ve();gi();ut=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},$d=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],ln=(e,t,r,a,n,s,u=!1,l=!1)=>{let o=[],p=r[0].dims,m=M.normalizeAxes(n,r[0].dims.length),w=!l&&m.length===0;p.forEach((W,H)=>{w||m.indexOf(H)>=0?u&&o.push(1):o.push(W)});let g=[],y=L("_A",r[0].dataType,p),$=Y("output",s,o),v=a(y,$,m),S=`inputOffset = ${y.indicesToOffset("inputIndices")};`,C=`let ${S};`,T=`var ${S};`,P=v[1]===""?"":T,B=(v[1]===""?C:S)+`
`+v[2];for(let W=0,H=0;W<r[0].dims.length;W++)w||m.indexOf(W)>=0?(u&&H++,B=`for(var j${W}: u32 = 0; j${W} < ${r[0].dims[W]}; j${W}++) {
                ${v[2].includes("lastIndex")?`let lastIndex = j${W};`:""}
                ${y.indicesSet("inputIndices",W,`j${W}`)}
                ${B}
              }`):(g.push(`${y.indicesSet("inputIndices",W,$.indicesGet("outputIndices",H))};`),H++);let z=M.size(o);return{name:e,shaderCache:t,getShaderSource:W=>`
        ${W.declareVariables(y,$)}

        ${W.mainStart()}
          ${W.guardAgainstOutOfBoundsWorkgroupSizes(z)}
          var inputIndices: ${y.type.indices};
          let outputIndices = ${$.offsetToIndices("global_idx")};

          ${g.join(`
`)}
          ${v[0]}       // init ops for reduce max/min
          ${P}
          ${v[1]}
          ${B}
          ${v[3]}
          ${v.length===4?$.setByOffset("global_idx","value"):v.slice(4).join(`
`)}
        }`,getRunData:()=>({outputs:[{dims:o,dataType:s}],dispatchGroup:{x:Math.ceil(z/64)}})}},ra=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(a=>r.push(Number(a))),se({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},lt=(e,t,r,a)=>{let n=e.inputs,s=n.length===1?r:ra(n,r);e.compute(ln(t,{hint:s.cacheKey},[n[0]],s.noopWithEmptyAxes&&s.axes.length===0?$d:a,s.axes,n[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},xd=(e,t)=>{ut(e.inputs),lt(e,"ReduceLogSum",t,(a,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${a.getByOffset("inputOffset")};`,"value = log(value);"])},Sd=(e,t)=>{ut(e.inputs),lt(e,"ReduceL1",t,(a,n)=>[`var value = ${n.type.storage}(0);`,"",`value += abs(${a.getByOffset("inputOffset")});`,""])},Cd=(e,t)=>{ut(e.inputs),lt(e,"ReduceL2",t,(a,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${a.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},Id=(e,t)=>{ut(e.inputs),lt(e,"ReduceLogSumExp",t,(a,n)=>[`var value = ${n.type.storage}(0);`,"",`value += exp(${a.getByOffset("inputOffset")});`,"value = log(value);"])},Ad=(e,t)=>{ut(e.inputs),lt(e,"ReduceMax",t,(a,n,s)=>{let u=[];for(let l=0;l<a.rank;l++)(s.indexOf(l)>=0||s.length===0)&&u.push(a.indicesSet("inputIndices",l,0));return[`${u.join(`
`)}`,`var value = ${a.getByOffset("inputOffset")};`,`value = max(value, ${a.getByOffset("inputOffset")});`,""]})},Ed=(e,t)=>{ut(e.inputs),lt(e,"ReduceMean",t,(a,n,s)=>{let u=1;for(let l=0;l<a.rank;l++)(s.indexOf(l)>=0||s.length===0)&&(u*=e.inputs[0].dims[l]);return["var sum = f32(0);","",`sum += f32(${a.getByOffset("inputOffset")});`,`let value = ${n.type.value}(sum / ${u});`]})},_d=(e,t)=>{ut(e.inputs),lt(e,"ReduceMin",t,(a,n,s)=>{let u=[];for(let l=0;l<a.rank;l++)(s.indexOf(l)>=0||s.length===0)&&u.push(`inputIndices[${l}] = 0;`);return[`${u.join(`
`)}`,`var value = ${a.getByOffset("inputOffset")};`,`value = min(value, ${a.getByOffset("inputOffset")});`,""]})},Od=(e,t)=>{ut(e.inputs),lt(e,"ReduceProd",t,(a,n)=>[`var value = ${n.type.storage}(1);`,"",`value *= ${a.getByOffset("inputOffset")};`,""])},Td=(e,t)=>{ut(e.inputs),lt(e,"ReduceSum",t,(a,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${a.getByOffset("inputOffset")};`,""])},Rd=(e,t)=>{ut(e.inputs),lt(e,"ReduceSumSquare",t,(a,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${a.getByOffset("inputOffset")}; value += t * t;`,""])},dt=(e,t,r)=>{if(t.length===0)return!!r;let a=1,n=1;for(let s=0;s<t.length;s++)t.indexOf(s)===-1?a*=e[s]:n*=e[s];return n<32&&a>1024},yi=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ed(e,t):ii(e,t)},bi=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Sd(e,t):si(e,t)},wi=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Cd(e,t):ui(e,t)},vi=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Id(e,t):li(e,t)},$i=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ad(e,t):di(e,t)},xi=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?_d(e,t):ci(e,t)},Si=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Od(e,t):pi(e,t)},Ci=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Td(e,t):fi(e,t)},Ii=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Rd(e,t):mi(e,t)},Ai=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?xd(e,t):hi(e,t)},tt=e=>se(e)});var Ei,_i,Oi,Ti,na,Ri=F(()=>{"use strict";Me();Pe();un();Ei=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},_i=(e,t)=>se({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}),Oi=(e,t)=>{Ei(e.inputs);let r=(n,s,u)=>{let l=[];for(let o=0;o<n.rank;o++)(u.indexOf(o)>=0||u.length===0)&&l.push(`inputIndices[${o}] = 0;`);return[`${l.join(`
`)}`,`var value = ${n.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${n.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {
         value = ${n.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",s.setByOffset("global_idx","bestIndex")]},a=e.inputs.length===1?t:_i(e.inputs,t);e.compute(ln("ArgMin",{hint:a.cacheKey},[e.inputs[0]],r,[a.axis],7,a.keepDims),{inputs:[0]})},Ti=(e,t)=>{Ei(e.inputs);let r=(n,s,u)=>{let l=[];for(let o=0;o<n.rank;o++)(u.indexOf(o)>=0||u.length===0)&&l.push(`inputIndices[${o}] = 0;`);return[`${l.join(`
`)}`,`var value = ${n.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${n.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {
         value = ${n.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",s.setByOffset("global_idx","bestIndex")]},a=e.inputs.length===1?t:_i(e.inputs,t);e.compute(ln("argMax",{hint:a.cacheKey},[e.inputs[0]],r,[a.axis],7,a.keepDims),{inputs:[0]})},na=e=>se(e)});var kd,Pd,ki,Pi=F(()=>{"use strict";ge();ve();kd=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Pd=e=>{let t=e[0].dims,r=e[0].dims[2],a=M.size(t)/4,n=e[0].dataType,s=L("input",n,t,4),u=L("bias",n,[r],4),l=L("residual",n,t,4),o=Y("output",n,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:m=>`
  const channels = ${r}u / 4;
  ${m.declareVariables(s,u,l,o)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes(a)}
    let value = ${s.getByOffset("global_idx")}
      + ${u.getByOffset("global_idx % channels")} + ${l.getByOffset("global_idx")};
    ${o.setByOffset("global_idx","value")}
  }`}},ki=e=>{kd(e.inputs),e.compute(Pd(e.inputs))}});var Bd,$e,Bi,Di,Mi,zi,Wi,Ni,Ui,Vi,Gi,aa,Dd,Li,Fi,Hi,ji,dn,qi,cn,Ki,Yi,Xi,Ji,Zi,Qi,es,ts,rs,ns,as,os,is,ss,us,ls,ds,oa=F(()=>{"use strict";Me();ge();Pe();ve();Bd=(e,t,r,a,n,s)=>{let u=Math.ceil(t/4),l="";typeof n=="string"?l=`${n}(a)`:l=n("a");let o=L("inputData",r,[u],4),p=Y("outputData",a,[u],4);return`
      ${e.registerUniform("vec_size","u32").declareVariables(o,p)}

  ${s??""}

  ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${o.getByOffset("global_idx")};
    ${p.setByOffset("global_idx",l)}
  }`},$e=(e,t,r,a,n,s=e.dataType)=>({name:t,shaderCache:{hint:n,inputDependencies:["type"]},getShaderSource:u=>Bd(u,M.size(e.dims),e.dataType,s,r,a),getRunData:u=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(M.size(u[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(M.size(e.dims)/4)}]})}),Bi=e=>{e.compute($e(e.inputs[0],"Abs","abs"))},Di=e=>{e.compute($e(e.inputs[0],"Acos","acos"))},Mi=e=>{e.compute($e(e.inputs[0],"Acosh","acosh"))},zi=e=>{e.compute($e(e.inputs[0],"Asin","asin"))},Wi=e=>{e.compute($e(e.inputs[0],"Asinh","asinh"))},Ni=e=>{e.compute($e(e.inputs[0],"Atan","atan"))},Ui=e=>{e.compute($e(e.inputs[0],"Atanh","atanh"))},Vi=e=>se(e),Gi=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute($e(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},aa=(e,t)=>{let r=Be(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Clip",a=>`clamp(${a}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${r}> = vec4(${r}(${t.min}));
    const clip_max_: vec4<${r}> = vec4(${r}(${t.max}));
`,t.cacheKey),{inputs:[0]})},Dd=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:on,r=e.length>=3?e[2].getFloat32Array()[0]:sn;return se({min:t,max:r})},Li=e=>{let t=Dd(e.inputs);aa(e,t)},Fi=e=>{e.compute($e(e.inputs[0],"Ceil","ceil"))},Hi=e=>{e.compute($e(e.inputs[0],"Cos","cos"))},ji=e=>{e.compute($e(e.inputs[0],"Cosh","cosh"))},dn=e=>se(e),qi=(e,t)=>{e.compute($e(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`
  const elu_alpha_: f32 = f32(${t.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,t.cacheKey))},cn=(e,t="f32")=>`
const r0: ${t} = 0.3275911;
const r1: ${t} = 0.254829592;
const r2: ${t} = -0.284496736;
const r3: ${t} = 1.421413741;
const r4: ${t} = -1.453152027;
const r5: ${t} = 1.061405429;

fn erf_vf32(v: ${e}) -> ${e} {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,Ki=e=>{let t=Be(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,cn(`vec4<${t}>`,t)))},Yi=e=>{e.compute($e(e.inputs[0],"Exp","exp"))},Xi=e=>{e.compute($e(e.inputs[0],"Floor","floor"))},Ji=e=>{let t=Be(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,cn(`vec4<${t}>`,t)))},Zi=(e,t)=>{e.compute($e(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},Qi=e=>{e.compute($e(e.inputs[0],"Not",t=>`!${t}`))},es=e=>{e.compute($e(e.inputs[0],"Neg",t=>`-${t}`))},ts=e=>{e.compute($e(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},rs=e=>{e.compute($e(e.inputs[0],"Relu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > vec4<f32>(0.0))`))},ns=e=>{e.compute($e(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},as=e=>{e.compute($e(e.inputs[0],"Sin","sin"))},os=e=>{e.compute($e(e.inputs[0],"Sinh","sinh"))},is=e=>{e.compute($e(e.inputs[0],"Sqrt","sqrt"))},ss=e=>{e.compute($e(e.inputs[0],"Tan","tan"))},us=e=>{e.compute($e(e.inputs[0],"Tanh","tanh"))},ls=(e,t)=>(e.compute($e(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),ds=e=>{e.compute($e(e.inputs[0],"Log","log"))}});var zd,Wd,cs,ps=F(()=>{"use strict";ge();ve();oa();zd=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Wd=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=L("input",e[0].dataType,e[0].dims,4),a=L("bias",e[0].dataType,[e[0].dims[2]],4),n=Y("output",e[0].dataType,t,4),s=M.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:l=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${e[0].dims[2]/4/2}u;

  ${l.declareVariables(r,a,n)}

  ${cn("vec4f")}

  ${l.mainStart()}
    ${l.guardAgainstOutOfBoundsWorkgroupSizes(s)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${n.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},cs=e=>{zd(e.inputs),e.compute(Wd(e.inputs))}});var Nd,Ud,ct,fs,ms,hs,gs,ys,bs,ws,vs,$s,xs,Ss=F(()=>{"use strict";Me();ge();ve();Nd=(e,t,r,a,n,s,u,l,o,p,m,w)=>{let g,y;typeof u=="string"?g=y=(z,k)=>`${u}((${z}),(${k}))`:typeof u=="function"?g=y=u:(g=u.scalar,y=u.vector);let $=m?t.length:t,v=m?r.length:r,S=m?a.length:a,C=Y("outputData",p,S,4),T=L("aData",l,$,4),P=L("bData",o,v,4),B;if(n)if(s){let z=M.size(t)===1,k=M.size(r)===1;z||k?B=C.setByOffset("global_idx",y(z?`${T.type.value}(${T.getByOffset("0")}.x)`:T.getByOffset("global_idx"),k?`${P.type.value}(${P.getByOffset("0")}.x)`:P.getByOffset("global_idx"))):B=`
            let outputIndices = ${C.offsetToIndices("global_idx * 4u")};
            let offsetA = ${T.broadcastedIndicesToOffset("outputIndices",C)};
            let offsetB = ${P.broadcastedIndicesToOffset("outputIndices",C)};
            ${C.setByOffset("global_idx",y(T.getByOffset("offsetA / 4u"),P.getByOffset("offsetB / 4u")))}
          `}else B=C.setByOffset("global_idx",y(T.getByOffset("global_idx"),P.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let z=(k,W,H="")=>{let X=`aData[indexA${W}][componentA${W}]`,le=`bData[indexB${W}][componentB${W}]`;return`
            let outputIndices${W} = ${C.offsetToIndices(`global_idx * 4u + ${W}u`)};
            let offsetA${W} = ${T.broadcastedIndicesToOffset(`outputIndices${W}`,C)};
            let offsetB${W} = ${P.broadcastedIndicesToOffset(`outputIndices${W}`,C)};
            let indexA${W} = offsetA${W} / 4u;
            let indexB${W} = offsetB${W} / 4u;
            let componentA${W} = offsetA${W} % 4u;
            let componentB${W} = offsetB${W} % 4u;
            ${k}[${W}] = ${H}(${g(X,le)});
          `};p===9?B=`
            var data = vec4<u32>(0);
            ${z("data",0,"u32")}
            ${z("data",1,"u32")}
            ${z("data",2,"u32")}
            ${z("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:B=`
            ${z("outputData[global_idx]",0)}
            ${z("outputData[global_idx]",1)}
            ${z("outputData[global_idx]",2)}
            ${z("outputData[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(T,P,C)}

        ${w??""}

        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${B}
      }`},Ud=(e,t,r,a,n,s,u=r.dataType)=>{let l=!M.areEqual(r.dims,a.dims),o=r.dims,p=M.size(r.dims),m=!1,w=[l];if(l){let y=it.calcShape(r.dims,a.dims,!1);if(!y)throw new Error("Can't perform binary op on the given tensors");o=y,p=M.size(o);let $=M.size(r.dims)===1,v=M.size(a.dims)===1;w.push($),w.push(v);let S=1;for(let C=1;C<o.length;C++){let T=r.dims[r.dims.length-C]??1,P=a.dims[a.dims.length-C]??1;if(T===P)S*=T;else break}(S%4===0||$||v)&&(m=!0)}else m=!0;w.push(m);let g=Yt(r.dims.length)&&Yt(a.dims.length)&&Yt(o.length);return{name:e,shaderCache:{hint:t+w.map(y=>y.toString()).join("_"),inputDependencies:g?["rank","rank"]:[r.dims.length>0?"dims":"type",a.dims.length>0?"dims":"type"]},getShaderSource:y=>Nd(y,r.dims,a.dims,o,m,l,n,r.dataType,a.dataType,u,g,s),getRunData:()=>({outputs:[{dims:o,dataType:u}],dispatchGroup:{x:Math.ceil(p/64/4)},programUniforms:g?[{type:"uint32",data:Math.ceil(M.size(o)/4)},...Wt(r.dims),...Wt(a.dims),...Wt(o)]:[{type:"uint32",data:Math.ceil(M.size(o)/4)}]})}},ct=(e,t,r,a,n,s)=>{e.compute(Ud(t,n??"",e.inputs[0],e.inputs[1],r,a,s))},fs=e=>{ct(e,"Add",(t,r)=>`${t}+${r}`)},ms=e=>{ct(e,"Div",(t,r)=>`${t}/${r}`)},hs=e=>{ct(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},gs=e=>{ct(e,"Mul",(t,r)=>`${t}*${r}`)},ys=e=>{let t=L("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;ct(e,"Pow",{scalar:(a,n)=>`pow_custom(${a},${n})`,vector:(a,n)=>`pow_vector_custom(${a},${n})`},`
    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {
      if (b == ${t}(0.0)) {
        return ${t}(1.0);
      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {
        return ${t}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {
      // TODO: implement vectorized pow
      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},bs=e=>{ct(e,"Sub",(t,r)=>`${t}-${r}`)},ws=e=>{ct(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},vs=e=>{ct(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},$s=e=>{ct(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},xs=e=>{ct(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var Gd,Ld,Fd,Hd,Cs,Is,As=F(()=>{"use strict";ge();Pe();ve();Gd=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let a of e){if(a.dataType!==t)throw new Error("input tensors should be one type");if(a.dims.length!==r)throw new Error("input tensors should have the same shape")}},Ld=e=>`
  fn calculateInputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${e}u;
  }`,Fd=(e,t)=>{let r=e.length,a=[];for(let n=0;n<r;++n){let s=t.setByOffset("global_idx",e[n].getByIndices("indices"));r===1?a.push(s):n===0?a.push(`if (inputIndex == ${n}u) { ${s} }`):n===r-1?a.push(`else { ${s} }`):a.push(`else if (inputIndex == ${n}) { ${s} }`)}return a.join(`
`)},Hd=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn't match input dimensionality");let a=t<0?r.length+t:t,n=r.slice(0);for(let y=1;y<e.length;y++){let $=e[y].dims.slice();for(let v=0;v<r.length;v++)if(v===a)n[a]+=$[v];else if(r[v]!==$[v])throw new Error("non concat dimensions must match")}let s=M.size(n),u=new Array(e.length),l=new Array(e.length),o=e[0].dataType,p=0;for(let y=0;y<e.length;++y)p+=e[y].dims[a],u[y]=p,l[y]=L(`input${y}`,o,e[y].dims);let m=Y("output",o,n),w=m.indicesGet("indices",a),g=y=>`
  ${y.declareVariables(...l,m)}

  const sizeInConcatAxis = array<u32, ${u.length}>(${u.map($=>`${$}u`).join(",")});
  ${Ld(u.length)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes(s)}

    var indices = ${m.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${w});
    if (inputIndex != 0u) {
      ${w} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${Fd(l,m)}
  }`;return{name:"Concat",shaderCache:{hint:`${t}`},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:g}},Cs=(e,t)=>{Gd(e.inputs),e.compute(Hd(e.inputs,t.axis))},Is=e=>se({axis:e.axis})});var We,pn,fn,mn=F(()=>{"use strict";We=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},pn=(e,t=!1,r=!1,a=3)=>"",fn=(e,t)=>`
      ${e?"value = value + getBiasByOutputCoords(coords);":""}
      // TODO uncomment the following line when activation is supported above.
      // ${t?"value = activation(value, coords);":""}
      `});var hn,ia=F(()=>{"use strict";hn=`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));
}
`});var gn,yn,vr=F(()=>{"use strict";ge();gn=(e,t=!1)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:t?"value = max(value, vec4(0.0));":"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:t?"value = clamp(value, vec4(clip_min_), vec4(clip_max_));":"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},yn=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,a]=e?.activation_params||[on,sn];return{activation:t,clipMax:a,clipMin:r,activationCacheKey:`${t}:${r},${a}`}}return{activation:t,activationCacheKey:t}}});var jd,qd,$r,Es,Kd,xr,Yd,bn,Sr=F(()=>{"use strict";ge();ve();vr();mn();jd=(e,t)=>e?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${t?", batchIndices":""});
        `,qd=(e,t)=>e?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,$r=(e,t,r="f32",a,n=!1,s=32,u=!1,l=32)=>{let o=t[1]*e[1],p=t[0]*e[0],m=n?o:s,w=n?s:o,g=m/t[0],y=s/t[1];if(!((n&&g===4&&e[1]===4||!n&&(g===3||g===4))&&m%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${n} is true, innerElementSize ${g} and workPerThread[1] ${e[1]} must be 4.
      Otherwise, innerElementSize ${g} must be 3 or 4.
  tileAWidth ${m} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${g}<${r}>, ${m/g}>, ${w}>;
var<workgroup> mm_Bsub: array<array<vec4<${r}>, ${p/e[0]}>, ${s}>;

const rowPerThread = ${e[1]};
const colPerThread = ${e[0]};
const innerElementSize = ${g};
const tileInner = ${s};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${u?"0":"i32(globalId.z)"};
  ${a?`let batchIndices = ${a.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${o};

  let numTiles = ${u?`${Math.ceil(l/s)}`:"(dimInner - 1) / tileInner + 1"};
  var kStart = ${u?`i32(globalId.z) * ${l}`:"0"};

  var acc: array<vec4<${r}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${y};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${jd(n,a)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${y}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${a?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${g===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${qd(n,g)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Es=(e,t)=>e?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${t?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${t?", batchIndices":""});
            `,Kd=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",xr=(e,t,r="f32",a,n=!1,s=32,u=!1,l=32,o=!1)=>{let p=e[1]*t[1],m=e[0]*t[0],w=n?p:s,g=n?s:p;if(!(g%t[1]===0&&w%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${g} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${w} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let y=g/t[1],$=w/t[0],v=s/t[1],S=o?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${p};
    let globalColStart = i32(workgroupId.x) * ${m};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${g}; inputRow = inputRow + ${t[1]}) {
        for (var inputCol = localCol; inputCol < ${w}; inputCol = inputCol + ${t[0]}) {
          ${Es(n,a)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {
            for (var inputCol = localCol; inputCol < ${m}; inputCol = inputCol + ${t[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${a?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${r}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${t[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${t[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${p};

let tileRowA = i32(localId.y) * ${y};
let tileColA = i32(localId.x) * ${$};
let tileRowB = i32(localId.y) * ${v};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${y}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${$}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Es(n,a)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${v}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${a?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${r}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${Kd(n)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${r}, ${w}>, ${g}>;
  var<workgroup> mm_Bsub : array<array<${r}, ${m}>, ${s}>;
  const rowPerThread = ${e[1]};
  const colPerThread = ${e[0]};
  const tileInner = ${s};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${u?"0":"i32(globalId.z)"};
    ${a?`let batchIndices = ${a.offsetToIndices("u32(batch)")};`:""}
    let numTiles = ${u?`${Math.ceil(l/s)}`:"(dimInner - 1) / tileInner + 1"};
    var kStart = ${u?`i32(globalId.z) * ${l}`:"0"};

    var acc : array<array<${r}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${S}
  }
`},Yd=(e,t,r,a,n,s=!1)=>{let u=n[0],l=n[1],o=n[2],p=a[0],m=a[1],w=a[2],g=a[3],y=ta(u,o),$=ta(l,o),v=Be(a[0].type.tensor),S=()=>{let P=m.rank,B=p.rank,z=`var aIndices: ${m.type.indices};`;for(let k=P-2-1,W=B-1;k>=0;k--,W--)z+=`
aIndices[${k}] = ${B>1?`batchIndices[${W}]`:"batchIndices"};`;return y.forEach(k=>{z+=`
aIndices[${k}] = 0;`}),z+=`
aIndices[${P-2}] = u32(row);
                   aIndices[${P-1}] = u32(colIn);`,z},C=()=>{let P=w.rank,B=p.rank,z=`var bIndices: ${w.type.indices};`;for(let k=P-2-1,W=B-1;k>=0;k--,W--)z+=`
bIndices[${k}] = ${B>1?`batchIndices[${W}]`:"batchIndices"};`;return $.forEach(k=>{z+=`
bIndices[${k}] = 0;`}),z+=`
bIndices[${P-2}] = u32(row);
                   bIndices[${P-1}] = u32(colIn);`,z};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${We(e,v)} {
      var value = ${We(e,v)}(0.0);
      let col = colIn * ${e};
      if(row < dimAOuter && col < dimInner)
      {
        ${S()}
        value = ${m.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${We(e,v)} {
      var value = ${We(e,v)}(0.0);
      let col = colIn * ${e};
      if(row < dimInner && col < dimBOuter)
      {
        ${C()}
        value = ${w.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${We(e,v)}) {
      let col = colIn * ${e};
      if (row < dimAOuter && col < dimBOuter) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${t?`value = value + ${s?"bias[colIn]":`${We(e,v)}(bias[row])`};`:""}
        ${r}
        ${g.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},bn=(e,t,r,a,n=!1)=>{let s=e[0].dims,u=e[1].dims,l=s.slice(0,-2),o=u.slice(0,-2),p=a?a.slice(0,-2):r.slice(0,-2),m=L("batchDims",e[0].dataType,p),w=[m],g=[l,o,p],y=M.size(p),$=s[s.length-2],v=s[s.length-1],S=u[u.length-1],C=v%4===0&&S%4===0,{activationFunction:T,applyActivation:P}=gn(t,C),B=$<=8?[4,1,1]:[4,4,1],z=[8,8,1],k=[Math.ceil(S/z[0]/B[0]),Math.ceil($/z[1]/B[1]),Math.ceil(y/z[2]/B[2])],W=Be(e[0].dataType),H=C?4:1,X=L("a",e[0].dataType,[...l,$,v/H],H),le=L("b",e[1].dataType,[...o,v,S/H],H),D=Y("result",e[0].dataType,[y,$,S/H],H);w.push(X),w.push(le),w.push(D);let q=[X,le],xe=e.length>2,ie=Yd(H,xe,P,w,g,n);if(xe){let j=n?H:1;q.push(L("bias",e[2].dataType,e[2].dims,j))}let we=j=>`
  const dimAOuter: i32 = ${$};
  const dimBOuter: i32 = ${S};
  const dimInner: i32 = ${v};
  ${j.declareVariables(...q,D)}
  ${T}
  ${ie}
  ${C?$r(B,z,W,m):xr(B,z,W,m)}
                   ${m.impl()}`;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:k[0],y:k[1],z:k[2]}}),getShaderSource:we}}});var Xd,_s,Os=F(()=>{"use strict";Ct();ge();ve();mn();ia();Sr();Xd=(e,t,r,a,n=!1,s,u=!1,l=4,o=4,p=4,m="f32")=>{let w=le=>{switch(le){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${m}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},g=le=>{switch(le){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},y=e?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,$=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,v=e?"xShape[1]":"xShape[2]",S=e?"xShape[2]":"xShape[3]",C=e?"row":"col",T=e?"col":"row",P=`
    let inChannels = wShape[2];
    let outWidth = ${e?"outShape[2]":"outShape[3]"};
    let outRow = ${C} / outWidth;
    let outCol = ${C} % outWidth;

    let WRow = ${T} / (filterDims[1] * inChannels);
    let WCol = ${T} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${T} % inChannels;
    var resData = ${We(l,m)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${v} && xCol >= 0 && xCol < ${S}) {
      ${y}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${w(l)}
    }
    return resData;`,B=e?t&&a?`
    let col = colIn * ${l};
    ${P}`:`
    let col = colIn * ${l};
    if (row < dimAOuter && col < dimInner) {
      ${P}
    }
    return ${We(l,m)}(0.0);`:a&&r?`
    let col = colIn * ${l};
    ${P}`:`
    let col = colIn * ${l};
    if (row < dimInner && col < dimBOuter) {
      ${P}
    }
    return ${We(l,m)}(0.0);`,z=`${g(o)}`,k=We(p,m),W=e?We(l,m):We(o,m),H=e?We(o,m):We(l,m);return`
    ${pn(s,u,p===4,4)}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${W} {
      ${e?B:z}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${H} {
      ${e?z:B}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${k}) {
      let col = colIn * ${p};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${e?"outShape[2]":"outShape[3]"};
      ${$}
      ${fn(n,s)}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},_s=(e,t,r,a,n,s,u,l)=>{let o=t.format==="NHWC",p=o?e[0].dims[3]:e[0].dims[1],m=r[0],w=o?r[2]:r[3],g=o?r[1]:r[2],y=o?r[3]:r[1],$=o&&(p%4===0||p%3===0)&&y%4===0,v=o?y:w*g,S=o?w*g:y,C=[8,8,1],T=a<=8?[4,1,1]:[4,4,1],P=[Math.ceil(v/C[0]/T[0]),Math.ceil(S/C[1]/T[1]),Math.ceil(m/C[2]/T[2])];_e("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${P}`);let B=$?o&&p%4!==0?3:4:T[0],z=C[1]*T[1],k=C[0]*T[0],W=Math.max(C[0]*B,C[1]),H=a%z===0,X=n%k===0,le=s%W===0,D=$?[B,4,4]:[1,1,1],q=Be(e[0].dataType),xe=[`@group(0) @binding(0) var<storage, read> x: array<${$&&B===4?`vec4<${q}>`:q}>;`,`@group(0) @binding(1) var<storage, read> w: array<${$?`vec4<${q}>`:q}>;`],ie=`
      fn setOutputAtIndex(flatIndex : i32, value : ${$?`vec4<${q}>`:q}) {
        result[flatIndex] = ${$?`vec4<${q}>`:q}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${$?`vec4<${q}>`:q}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${$?"/ 4":""}, value);
      }`;return u&&(xe.push(`@group(0) @binding(2) var<storage, read> bias: array<${$?`vec4<${q}>`:q}>;`),ie+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${$?`vec4<${q}>`:q} {
          return bias[coords.${o?"w":"y"}${$?"/ 4":""}];
        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:P[0],y:P[1],z:P[2]}}),getShaderSource:()=>`
        ${hn}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${xe.join("")}
        @group(0) @binding(${xe.length}) var<storage, read_write> result: array<${$?`vec4<${q}>`:q}>;
        //@group(0) @binding(${xe.length+1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${M.computeStrides(r).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});
        const dimAOuter : i32 = ${a};
        const dimBOuter : i32 = ${n};
        const dimInner : i32 = ${s};
        ${ie}
        ${Xd(o,H,X,le,u,t.activation.toLowerCase(),!1,D[0],D[1],D[2],q)}
            ${$?$r(T,C,q,void 0,!o,W):xr(T,C,q,void 0,!o,W,!1,void 0,l)}`}}});var sa,Ts=F(()=>{"use strict";ge();ve();la();vr();sa=(e,t,r)=>{let a=e.length>2,n=a?"value += b[output_channel];":"",s=e[0].dims,u=e[1].dims,l=u[0]/t.group,{activationFunction:o,applyActivation:p}=gn(t),m=t.format==="NHWC",w=ua(s,u,t.dilations,t.pads,t.strides,m),g=M.size(w),y=Y("output",e[0].dataType,w),$=L("x",e[0].dataType,s),v=L("w",e[1].dataType,u),S=[$,v];a&&S.push(L("b",e[2].dataType,e[2].dims));let C=T=>`
  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);
  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);

  ${T.declareVariables(...S,y)}

  ${o}

  ${T.mainStart()}
    ${T.guardAgainstOutOfBoundsWorkgroupSizes(g)}

    let outputIndices = ${y.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${m?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${m?1:2}], outputIndices[${m?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${l}u;

    var value: ${y.type.value} = ${y.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${u[1]}u; wInChannel++) {
      let input_channel = group_id * ${u[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${u[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${s[m?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${u[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${s[m?2:3]}u) {
            continue;
          }

          let xVal = ${m?$.get("batch","xHeight","xWidth","input_channel"):$.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${v.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${n}
    ${p}
    ${y.setByOffset("global_idx","value")}
  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(w):w,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(g/64)}}),getShaderSource:C}}});var ua,Rs,Jd,ks,da,Zd,Qd,ca,la=F(()=>{"use strict";ge();Pe();Os();Sr();Ts();vr();wr();ua=(e,t,r,a,n,s)=>{let u=e[0],l=e.slice(s?1:2,s?3:4),o=l.length,p=t[0],w=t.slice(2).map(($,v)=>$+($-1)*(r[v]-1)),y=l.map(($,v)=>$+a[v]+a[v+o]).map(($,v)=>Math.floor(($-w[v]+n[v])/n[v]));return y.splice(0,0,u),y.splice(s?3:1,0,p),y},Rs=[2,3,1,0],Jd=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],a=e[1].dims[1]*t.group;if(r!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},ks=(e,t)=>{let r=e.kernelShape.slice();for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let a=e.pads.slice();zt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,a,e.format==="NHWC",e.autoPad);let n=Object.assign({},e);return Object.assign(n,{kernelShape:r,pads:a,cacheKey:e.cacheKey}),n},da=e=>{let t=yn(e),r=e.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],n=e.dilations,s=e.group,u=e.kernel_shape,l=e.pads,o=e.strides,p=e.w_is_const();return se({autoPad:a,format:r,dilations:n,group:s,kernelShape:u,pads:l,strides:o,wIsConst:p,...t})},Zd=(e,t,r)=>{let a=ks(r,t);if(r.group!==1){e.compute(sa(t,a));return}let n=r.format==="NHWC",s=t.length===3,u=t[0].dims[n?1:2],l=t[0].dims[n?2:3],o=t[0].dims[n?3:1],p=t[1].dims[2],m=t[1].dims[3],w=ua(t[0].dims,t[1].dims,r.dilations,a.pads,r.strides,n),g=w[n?1:2],y=w[n?2:3],$=w[n?3:1],v=n&&p===u&&m===l&&r.pads[0]===0&&r.pads[1]===0;if(v||p===1&&m===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let k=w[0],W,H,X,le=[];if(n){let D=e.kernelCustomData.wT??e.compute(At(t[1],Rs),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=D),v){let q=u*l*o;W=t[0].reshape([1,k,q]),H=D.reshape([1,q,$]),X=[1,k,$]}else W=t[0].reshape([k,u*l,o]),H=D.reshape([1,o,$]),X=[k,g*y,$];le.push(W),le.push(H)}else W=t[0].reshape([k,o,u*l]),H=t[1].reshape([1,$,o]),X=[k,$,g*y],le.push(H),le.push(W);s&&le.push(t[2]),e.compute(bn(le,a,w,X,n),{inputs:le});return}let S=!0,C=e.kernelCustomData.wT??e.compute(At(t[1],Rs),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=C);let T=[t[0],C];s&&T.push(t[2]);let P=n?g*y:$,B=n?$:g*y,z=p*m*o;e.compute(_s(T,a,w,P,B,z,s,S),{inputs:T})},Qd=(e,t)=>{let r=t.format==="NHWC",a=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&a.push(e.inputs[2]);let n=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),u=[1].concat(t.dilations),l=[1].concat(t.kernelShape),o=ks({...t,pads:n,strides:s,dilations:u,kernelShape:l},a);e.compute(sa(a,o,p=>r?[p[0],p[2],p[3]]:[]))},ca=(e,t)=>{Jd(e.inputs,t),e.inputs[0].dims.length===3?Qd(e,t):Zd(e,e.inputs,t)}});var ec,Ps,Bs=F(()=>{"use strict";Ct();ge();mn();ia();Sr();ec=(e,t=!1,r,a=!1,n=4)=>{let s=We(n,"f32"),u=C=>{switch(C){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${C} is not supported.`)}},l=e?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,o=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,p=e?"outBackprop[1]":"outBackprop[2]",m=e?"outBackprop[2]":"outBackprop[3]",w=e?"row":"col",g=e?"col":"row",y=`
      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};
      let outWidth = ${e?"outShape[2]":"outShape[3]"};
      let outRow = ${w} / outWidth;
      let outCol = ${w} % outWidth;

      let WRow = ${g} / (filterDims[1] * inChannels);
      let WCol = ${g} / inChannels % filterDims[1];
      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);
      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);
      if (xR < 0.0 || xR >= f32(${p}) || fract(xR) > 0.0) {
        return ${s}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${m}) || fract(xC) > 0.0) {
        return ${s}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${g} % inChannels;
      ${l}
      return x[getIndexFromCoords4D(coord, xShape)/${n}];`,$=e?`
      let col = colIn * ${n};
      if (row < dimAOuter && col < dimInner) {
        ${y}
      }
      return ${s}(0.0);`:`
      let col = colIn * ${n};
      if (row < dimInner && col < dimBOuter) {
        ${y}
      }
      return ${s}(0.0);`,v=`
      let col = colIn * ${n};
      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};
      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);
      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];
      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${u(n)}
      }
      return ${s}(0.0);
      `;return`
  ${pn(r,a,n===4,4)}
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${s} {
    ${e?$:v}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${s} {
    ${e?v:$}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${s}) {
    let col = colIn * ${n};
    if (row < dimAOuter && col < dimBOuter) {
      var value = valueInput;
      let outWidth = ${e?"outShape[2]":"outShape[3]"};
      ${o}
      ${fn(t,r)}
      result[getIndexFromCoords4D(coords, outShape)/${n}] = value;
    }
  }`},Ps=(e,t,r,a,n,s,u,l)=>{let o=t.format==="NHWC",p=o?e[0].dims[3]:e[0].dims[1],m=r[0],w=o?r[2]:r[3],g=o?r[1]:r[2],y=o?r[3]:r[1],$=o?p%4===0&&y%4===0:w%4===0&&y%4===0,v=o?y:w*g,S=o?w*g:y,C=$?[8,8,1]:[v<=4||S<=4?4:16,v>4&&S<=4?4:16,1],T=$?[4,4,1]:[v<=4?1:4,v>4&&S<=4?1:4,1],P=[Math.ceil(v/C[0]/T[0]),Math.ceil(S/C[1]/T[1]),Math.ceil(m/C[2]/T[2])];_e("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${P}`);let B=$?4:1,z=Math.max(C[0]*B,C[1]),k=[`@group(0) @binding(0) var<storage, read> x: array<${$?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],W="";return u&&(k.push(`@group(0) @binding(2) var<storage, read> bias: array<${$?"vec4<f32>":"f32"}>;`),W+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${$?"vec4<f32>":"f32"} {
          return bias[coords.${o?"w":"y"}${$?"/ 4":""}];
        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:P[0],y:P[1],z:P[2]}}),getShaderSource:()=>`
        ${hn}
        ${k.join(`
`)}
        @group(0) @binding(${k.length}) var<storage, read_write> result: array<${$?"vec4<f32>":"f32"}>;
        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${M.computeStrides(r).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[o?1:2]}, ${t.kernelShape[o?2:3]});
        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(
              ${t.dilations[0]<=1?0:(t.kernelShape[o?1:2]-1)*(t.dilations[0]-1)},
              ${t.dilations[1]<=1?0:(t.kernelShape[o?2:3]-1)*(t.dilations[1]-1)});
        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,
                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);
        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});
        const dimAOuter : i32 = ${a};
        const dimBOuter : i32 = ${n};
        const dimInner : i32 = ${s};
        ${W}
        ${ec(o,u,t.activation.toLowerCase(),!1,B)}
        ${$?$r(T,C,"f32",void 0,!o,z):xr(T,C,"f32",void 0,!o,z,!1,void 0,l)}`}}});var tc,pa,Ds=F(()=>{"use strict";Ct();ge();ve();tc=(e,t,r,a,n,s,u=!1,l)=>{let o=r.format==="NHWC",p=o?1:2,m=o?2:3,w=o?3:1,g=M.size(a),y=u?2:1,$=r.group,v=t[1].dims,S=v[0]/$,C=v[1],T=`
  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${l}>`:l}) {
    result[flatIndex] = ${u?`vec4<${l}>`:l}(value);
  }`;n&&(T+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${l}>`:l} {
      return bias[coords.${o?"w":"y"}${u?"/ 4":""}];
    }`);let P=u?4:1,B=L("W",t[1].dataType,t[1].dims,P),z=L("Dy",t[0].dataType,t[0].dims,P),k=[z,B];n&&k.push(L("bias",t[2].dataType,[a[w]],P));let W=Y("result",t[0].dataType,a,P),H=`{
        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];
        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];
        let c = ${s?"global_id.y":"workgroup_id.y"} * ${y};
        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${l}>, ${y}>;
        for (var i = 0; i < ${y}; i++) {
          dotProd[i] = vec4<${l}>(0.0);
        }
        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {
          var dyR = (${l}(dyCorner.x) + ${l}(wR)) / ${l}(strides.x);
          let wRPerm = filterDims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${l}(outBackprop[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {
            let dyC = (${l}(dyCorner.y) + ${l}(wC)) / ${l}(strides.y);
            let dyC2 = (${l}(dyCorner.y) + 1.0 + ${l}(wC)) / ${l}(strides.y);
            let wCPerm = filterDims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${l}(outBackprop[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${l}(outBackprop[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${z.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${z.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${l}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = outBackprop[${w}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${z.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${z.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${y}; i = i + 1) {
          let value = dotProd[i] + ${n?"bias[c+i]":"0.0"};
          ${W.set("batch","r","c + i","d1","value")};
        }
      }`,X=`
          let outputIndices = ${W.offsetToIndices("global_idx")};
          let batch = ${W.indicesGet("outputIndices",0)};
          let d1 = ${W.indicesGet("outputIndices",w)};
          let r = ${W.indicesGet("outputIndices",p)};
          let c = ${W.indicesGet("outputIndices",m)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / ${C};
          let wOutChannel = d1 - groupId * ${C};
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = 0.0;
          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {
            if (wR % dilations.x != 0) {
              continue;
            }
            let dyR = (${l}(dyRCorner) + ${l}(wR)) / ${l}(strides[0]);
            let wRPerm = filterDims.x - 1 - wR / dilations.x;
            if (dyR < 0.0 || dyR >= ${l}(outBackprop[${p}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {
              if (wC % dilations.y != 0) {
                continue;
              }
              let dyC = (${l}(dyCCorner) + ${l}(wC)) / ${l}(strides.y);
              let wCPerm = filterDims.y - 1 - wC / dilations.y;
              if (dyC < 0.0 || dyC >= ${l}(outBackprop[${m}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * ${S};
              for (var d2: u32 = 0; d2 < ${S}; d2 = d2 + 1) {
                let xValue = ${o?z.get("batch","idyR","idyC","inputChannel"):z.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${B.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${n?"bias[d1]":"0.0"};
          ${W.setByOffset("global_idx","value")};
        `;return`
  ${e.declareVariables(...k,W)}
  ${T}
  const outShape : vec4<u32> = vec4<u32>(${a.join(",")});
  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});
  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});
  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[o?1:2]}, ${r.kernelShape[o?2:3]});
  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});
  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(
          ${r.dilations[0]<=1?0:(r.kernelShape[o?1:2]-1)*(r.dilations[0]-1)},
          ${r.dilations[1]<=1?0:(r.kernelShape[o?2:3]-1)*(r.dilations[1]-1)});
  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,
                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);
    ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes(g)};
  ${u?H:X}}`},pa=(e,t,r)=>{let a=e.length>2,n=t.outputShape,s=M.size(n),u=[Math.ceil(s/64),1,1];_e("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${u}`);let l=Be(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:u[0],y:u[1],z:u[2]},outputs:[{dims:r?r(n):n,dataType:e[0].dataType}]}),getShaderSource:o=>tc(o,e,t,n,a,u[1]===1&&u[2]===1,!1,l)}}});var rc,nc,ac,Ms,zs,oc,ic,sc,uc,Ws,Ns=F(()=>{"use strict";Pe();Bs();Ds();vr();wr();rc=(e,t,r,a,n,s)=>(e-1)*t+r+(a-1)*n+1-s,nc=(e,t,r,a,n)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[a]=s,r[n]=e-s):t==="SAME_LOWER"&&(r[a]=e-s,r[n]=s)},ac=(e,t,r,a,n,s,u,l,o,p)=>{let m=e.length-2,w=p.length===0;if(o.length===0)for(let $=0;$<m;++$)o.push(0);let g=e[0],y=t[l?3:1]*n;for(let $=0,v=e.length-m-(l?1:0);$<m;++$,++v){let S=e[v],C=w?S*u[$]:p[$],T=rc(S,u[$],s[$],t[v],r[$],C);nc(T,a,s,$,$+m),w&&p.push(u[$]*(S-1)+o[$]+(t[v]-1)*r[$]+1-s[$]-s[$+m])}p.splice(0,0,g),p.splice(l?3:1,0,y)},Ms=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((g,y)=>g*y,1)===0){r.length=0;for(let g=2;g<t[1].dims.length;++g)r.push(t[1].dims[g])}let a=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(a?3:1,0,t[1].dims[1]);let n=e.pads.slice(),s=e.outputShape.slice(),u=e.outputPadding.slice(),l=t[0].dims,o=e.dilations.slice();if(o.reduce((g,y)=>g+y,0)===0){let g=t[0].dims.length-2;o=new Array(g).fill(1)}let p=e.strides.slice();if(p.reduce((g,y)=>g+y,0)===0){let g=t[0].dims.length-2;p=new Array(g).fill(1)}ac(l,r,o,e.autoPad,e.group,n,p,a,u,s);let m=Object.assign({},e),w=e.cacheKey+[r.join("n,"),n.join(","),p.join(","),u.join(","),s.join(","),o.join(",")].join("_");return Object.assign(m,{kernelShape:r,pads:n,outputPadding:u,outputShape:s,dilations:o,strides:p,cacheKey:w}),m},zs=e=>{let t=yn(e),r=e.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],n=e.dilations,s=e.group,u=e.kernelShape,l=e.pads,o=e.strides,p=e.wIsConst(),m=e.outputPadding,w=e.outputShape;return se({autoPad:a,format:r,dilations:n,group:s,kernelShape:u,outputPadding:m,outputShape:w,pads:l,strides:o,wIsConst:p,...t})},oc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],a=e[1].dims[0];if(r!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==n))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((m,w)=>m+w,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((m,w)=>m+w,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((m,w)=>m+w,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((m,w)=>m+w,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},ic=[2,3,1,0],sc=(e,t,r)=>{let a=Ms(r,t),n=r.format==="NHWC",s=t.length===3;if(a.group!==1){e.compute(pa(t,a));return}let u=a.outputShape,l=u[n?1:2],o=u[n?2:3],p=u[n?3:1],m=t[1].dims[2],w=t[1].dims[3],g=t[0].dims[n?3:1],y=n?l*o:p,$=n?p:l*o,v=m*w*g,S=!0,C=e.kernelCustomData.wT??e.compute(At(t[1],ic),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=C);let T=[t[0],C];s&&(!n&&t[2].dims.length===1?T.push(t[2].reshape([t[2].dims[0],1,1])):T.push(t[2])),e.compute(Ps(T,a,u,y,$,v,s,S),{inputs:T})},uc=(e,t)=>{let r=t.format==="NHWC",a=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];a.length===3&&a.push(e.inputs[2]);let n=t.kernelShape;(n.length===0||n[0]===0)&&(n=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let u=t.strides;(u.length===0||u[0]===0)&&(u=[1]);let l=t.pads;l.length===0&&(l=[0,0]),l=[0,l[0],0,l[1]],u=[1].concat(u),s=[1].concat(s),n=[1].concat(n);let o=Ms({...t,pads:l,strides:u,dilations:s,kernelShape:n},a);e.compute(pa(a,o,p=>r?[p[0],p[2],p[3]]:[p[0],p[1],p[3]]))},Ws=(e,t)=>{oc(e.inputs,t),e.inputs[0].dims.length===3?uc(e,t):sc(e,e.inputs,t)}});var fa,wn,Us,lc,dc,ma,ha,cc,Vs,Gs,Ls=F(()=>{"use strict";ge();Pe();ve();fa="[a-zA-Z]|\\.\\.\\.",wn="("+fa+")+",Us="^"+wn+"$",lc="("+wn+",)*"+wn,dc="^"+lc+"$",ma=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let a=this.symbolToIndices.get(t);a===void 0?a=[r]:a.push(r),this.symbolToIndices.set(t,a)}},ha=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[a,n]=r.includes("->")?r.split("->",2):[r,""];if(!a.match(RegExp(dc)))throw new Error("Invalid LHS term");if(a.split(",").forEach((l,o)=>{let p=t[o].dims.slice();if(!l.match(RegExp(Us)))throw new Error("Invalid LHS term");let m=this.processTerm(l,!0,p,o);this.lhs.push(m)}),n==="")n+=[...this.symbolToInfo.entries()].filter(([l,o])=>o.count===1||l==="...").map(([l])=>l).join("");else if(!n.match(RegExp(wn)))throw new Error("Invalid RHS");n.match(RegExp(fa,"g"))?.forEach(l=>{if(l==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let o=this.symbolToInfo.get(l);if(o===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(o.dimValue)}}),this.rhs=this.processTerm(n,!0,this.outputDims)}addSymbol(t,r,a){let n=this.symbolToInfo.get(t);if(n!==void 0){if(n.dimValue!==r&&n.count!==1)throw new Error("Dimension mismatch");n.count++,n.inputIndices.push(a)}else n={count:1,dimValue:r,inputIndices:[a]};this.symbolToInfo.set(t,n)}processTerm(t,r,a,n=-1){let s=a.length,u=!1,l=[],o=0;if(!t.match(RegExp(Us))&&!r&&t!=="")throw new Error("Invalid LHS term");let p=t.match(RegExp(fa,"g")),m=new ma(n);return p?.forEach((w,g)=>{if(w==="..."){if(u)throw new Error("Only one ellipsis is allowed per input term");u=!0;let y=s-p.length+1;if(y<0)throw new Error("Ellipsis out of bounds");if(l=a.slice(o,o+y),this.hasEllipsis){if(this.ellipsisDims.length!==l.length||this.ellipsisDims.toString()!==l.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=l;else throw new Error("Ellipsis must be specified in the LHS");for(let $=0;$<l.length;$++){let v=String.fromCharCode("0".charCodeAt(0)+g);m.addSymbol(v,g+$),this.addSymbol(v,a[o++],n)}}else m.addSymbol(w,g),this.addSymbol(w,a[o++],n)}),m}},cc=(e,t)=>{let r=e[0].dataType,a=new Array(e.length);for(let P=0;P<e.length;++P)a[P]=L(`input${P}`,r,e[P].dims);let n=t.outputDims,s=M.size(n),u=Y("output",r,n),l=[],o=Array.from(t.rhs.symbolToIndices.keys()),p="var prod = 1.0;",m="var sum = 0.0;",w="sum += prod;",g=[],y=[],$=[],v=[],S=t.symbolToInfo.size===o.length;t.symbolToInfo.forEach((P,B)=>{if(o.includes(B)){let z=o.indexOf(B);t.lhs.forEach((k,W)=>{if(P.inputIndices.includes(W)){let H=k.symbolToIndices.get(B);if(H===void 0)throw new Error("Invalid symbol error");H.forEach(X=>{l.push(`${a[W].indicesSet(`input${W}Indices`,X,u.indicesGet("outputIndices",z))}`)})}})}else t.lhs.forEach((z,k)=>{let W=t.symbolToInfo.get(B);if(W===void 0)throw new Error("Invalid symbol error");if(W.inputIndices.includes(k)){let H=z.symbolToIndices.get(B);if(H===void 0)throw new Error("Invalid symbol error");H.forEach(X=>{g.push(`${a[k].indicesSet(`input${k}Indices`,X,`${B}`)}`)}),v.push(`prod *= ${a[k].getByIndices(`input${k}Indices`)};`)}}),y.push(`for(var ${B}: u32 = 0; ${B} < ${t.symbolToInfo.get(B)?.dimValue}; ${B}++) {`),$.push("}")});let C=S?[...l,`let sum = ${a.map((P,B)=>P.getByIndices(`input${B}Indices`)).join(" * ")};`]:[...l,m,...y,...g,p,...v,w,...$],T=P=>`
      ${P.declareVariables(...a,u)}

      ${P.mainStart()}
        ${P.guardAgainstOutOfBoundsWorkgroupSizes(s)}
        var outputIndices = ${u.offsetToIndices("global_idx")};
        ${a.map((B,z)=>`var input${z}Indices: ${a[z].type.indices};`).join(`
`)}
        ${C.join(`
`)};
        ${u.setByOffset("global_idx","sum")};
      }`;return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:T}},Vs=(e,t)=>{let r=new ha(e.inputs,t.equation);e.compute(cc(e.inputs,r))},Gs=e=>{let t=e.equation.replace(/\s+/g,"");return se({equation:t})}});var pc,Fs,fc,mc,Hs,js=F(()=>{"use strict";ge();ve();pc=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),a=r.length<t.length?0:r.length-t.length,n=t.length<r.length?0:t.length-r.length;for(;a<r.length&&n<t.length;++a,++n)if(r[a]!==t[n]&&r[a]!==1&&t[n]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Fs=(e,t)=>{let r=e.length-t.length,a=[];for(let n=0;n<r;++n)a.push(e[n]);for(let n=0;n<t.length;++n)a.push(t[n]===1?e[n+r]:t[n]);return a},fc=(e,t)=>e.length>t.length?Fs(e,t):Fs(t,e),mc=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),a=fc(t,r),n=M.size(a),s=e[0].dataType,u=L("input",s,t),l=Y("output",s,a),o=p=>`
  const inputShape = ${u.indices(...t)};
  ${p.declareVariables(u,l)}
  ${p.mainStart()}
  ${p.guardAgainstOutOfBoundsWorkgroupSizes(n)}
    let outputIndices = ${l.offsetToIndices("global_idx")};
    var inputIndices: ${u.type.indices};
    for (var i = 0; i < ${t.length}; i++) {
      if (${u.indicesGet("inputShape","i")} == 1) {
        ${u.indicesSet("inputIndices","i",0)}
      } else {
        ${u.indicesSet("inputIndices","i",l.indicesGet("outputIndices",`i + ${a.length-t.length}`))}
      }
    }
    ${l.setByOffset("global_idx",u.getByIndices("inputIndices"))}
  }`;return{name:"Expand",shaderCache:{hint:`${a}`},getShaderSource:o,getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}})}},Hs=e=>{pc(e.inputs),e.compute(mc(e.inputs),{inputs:[0]})}});var hc,gc,qs,Ks,Ys=F(()=>{"use strict";ge();Pe();ve();hc=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},gc=(e,t)=>{let r=e[0].dims,a=e[1].dims,n=r.length,s=M.normalizeAxis(t.axis,n),u=r.slice(0);u.splice(s,1,...a);let l=r[s],o=M.size(u),p=L("data",e[0].dataType,e[0].dims),m=L("inputIndices",e[1].dataType,e[1].dims),w=Y("output",e[0].dataType,u),g=()=>{let $=a.length,v=`var indicesIndices  = ${m.type.indices}(0);`;for(let S=0;S<$;S++)v+=`${$>1?`indicesIndices[${S}]`:"indicesIndices"} = ${u.length>1?`outputIndices[${s+S}]`:"outputIndices"};`;v+=`
        var idx = ${m.getByIndices("indicesIndices")};
        if (idx < 0) {
          idx = idx + ${l};
        }
        var dataIndices = ${p.type.indices}(0);
      `;for(let S=0,C=0;S<n;S++)S===s?(v+=`${n>1?`dataIndices[${S}]`:"dataIndices"} = u32(idx);`,C+=$):(v+=`${n>1?`dataIndices[${S}]`:"dataIndices"} = ${u.length>1?`outputIndices[${C}]`:"outputIndices"};`,C++);return v},y=$=>`
      ${$.declareVariables(p,m,w)}
      ${$.mainStart()}
        ${$.guardAgainstOutOfBoundsWorkgroupSizes(o)}
        let outputIndices = ${w.offsetToIndices("global_idx")};
        ${g()};
        let value = ${p.getByIndices("dataIndices")};
        ${w.setByOffset("global_idx","value")};
      }`;return{name:"Gather",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:y}},qs=e=>se({axis:e.axis}),Ks=(e,t)=>{let r=e.inputs;hc(r),e.compute(gc(e.inputs,t))}});var yc,bc,Xs,Js,Zs=F(()=>{"use strict";ge();Pe();ve();yc=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},bc=(e,t)=>{let r=e[0].dims,a=e[0].dataType,n=r.length,s=M.computeStrides(r),u=M.size(r),l=e[1].dims,o=e[1].dataType,p=M.size(l),m=M.normalizeAxis(t.axis,n),w=r[m],g=l.slice(0),y=M.size(g),$=L("input",a,r),v=L("indices",o,[p]),S=Y("output",a,g),C=T=>`
      const inputStrides = array<u32, ${s.length}>(${s.map(P=>`${P}u`).join(",")});
      ${T.declareVariables($,v,S)}
      ${T.mainStart()}
      ${T.guardAgainstOutOfBoundsWorkgroupSizes(y)}

      let outputIndices = ${S.offsetToIndices("global_idx")};

      var idx = ${v.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + ${w};
      }

      var srcOffset = u32(0);

      for (var i = 0; i < ${r.length}; i++) {
        if (i == ${m}) {
          srcOffset +=  u32(idx) * inputStrides[i];
        } else {
          srcOffset += ${S.indicesGet("outputIndices","i")} * inputStrides[i];
        }
      }

      // Should never hit this with valid values in indices
      // This is a guard against malicious data in the indices input
      if (srcOffset < 0 || srcOffset >= ${u}) {
        return;
      }

      output[global_idx] = input[srcOffset];
  }`;return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:g,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)}}),getShaderSource:C}},Xs=e=>se({axis:e.axis}),Js=(e,t)=>{let r=e.inputs;yc(r),e.compute(bc(e.inputs,t))}});var wc,vc,$c,Qs,eu,tu=F(()=>{"use strict";ge();Pe();ve();wc=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},vc=(e,t,r)=>{if(r.length===0)return"0u";let a=r.length===1&&e!==1||r.length===2&&r[0]!==e,n=r[r.length-1]!==t,s="0u";return a||(s+=`+ m * ${r[r.length-1]}u`),n||(s+="+n"),s},$c=(e,t)=>{let r=e[0].dims.slice(),a=e[1].dims.slice(),[n,s,u]=an.getShapeOfGemmResult(r,t.transA,a,t.transB,e.length===3?e[2].dims:void 0),l=[n,s];if(!l)throw new Error("Can't use gemm on the given tensors");let o=M.size(l),p="";t.transA&&t.transB?p="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?p="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?p="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(p="value += a[m * K + k] * b[k * N + n];");let m=Be(e[0].dataType),w=t.alpha===1?"":"value *= alpha;",g=e.length===3?`value += beta * c[${vc(n,s,e[2].dims)}];`:"",y=[`@group(0) @binding(0) var<storage, read> a : array<${m}>;`,`@group(0) @binding(1) var<storage, read> b : array<${m}>;`];e.length===3&&y.push(`@group(0) @binding(2) var<storage, read> c : array<${m}>;`);let $=v=>`
  const M: u32 = ${n}u;
  const N: u32 = ${s}u;
  const K: u32 = ${u}u;
  const alpha = ${m}(${t.alpha});
  const beta = ${m}(${t.beta});

  ${y.join(`
`)}
  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${m}>;

  ${v.mainStart()}
    ${v.guardAgainstOutOfBoundsWorkgroupSizes(o)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${m}(0);
    for (var k: u32 = 0u; k<${u}u; k++) {
      ${p}
    }

    ${w}
    ${g}
    output[global_id.x] = value;

  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:l,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:$}},Qs=(e,t)=>{wc(e.inputs),e.compute($c(e.inputs,t))},eu=e=>se(e)});var xc,Sc,Cc,Ic,ru,nu,au=F(()=>{"use strict";Me();ge();Pe();ve();xc={name:"InstanceNormalization"},Sc=(e,t)=>{let r=e[0].dims,a=r,n=2,s=M.sizeToDimension(r,n),u=M.sizeFromDimension(r,n),l=r[1],o=L("x",e[0].dataType,[r[0],r[1],u]),p=L("scale",e[1].dataType,e[1].dims),m=L("bias",e[2].dataType,e[2].dims),w=Y("output",e[0].dataType,[r[0],r[1],u]),g=[o,p,m,w],y=o.type.value,$=64,v=S=>`

  const C: u32 = ${l};
  const normSize: u32 = ${u};
  const epsilon: f32 = ${t.epsilon};
  var<workgroup> meanShared : ${y};
  var<workgroup> squaredNormShared : ${y};
  var<workgroup> workgroupShared : array<${y}, ${$}>;
  const workgroupSize = ${$}u;
  ${S.declareVariables(...g)}
  ${S.mainStart($)}
    let norm = global_idx / workgroupSize;
    let batch = norm / C;
    let channel = norm % C;
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial: ${y} = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      initial = initial + ${o.get("batch","channel","h")};
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = workgroupShared[0] / ${y}(normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let deviation =  ${o.get("batch","channel","h")} - meanShared;
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = workgroupShared[0];
    }
    workgroupBarrier();

    let invStdDev = 1 / sqrt(squaredNormShared / ${y}(normSize) + epsilon);
    let channelScale = invStdDev * ${p.getByOffset("channel")};
    let channelShift = ${m.getByOffset("channel")} - meanShared * channelScale;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let value = ${o.get("batch","channel","h")} * channelScale + channelShift;
      ${w.set("batch","channel","h","value")};
    }
  }`;return{...xc,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:s}}),getShaderSource:v}},Cc=(e,t,r,a,n,s,u,l)=>{let o=yt(u),p=L("input",t.dataType,t.dims,o),m=L("scale",r.dataType,r.dims,o),w=L("bias",a.dataType,a.dims,o),g=64,y=o===1?"vec2f":`mat2x${o}f`,$=o===1?"f32":`vec${o}f`,v=(z,k)=>`${y}(${z}, ${k})`,S=n*u/o,C=Math.ceil(s/g),T=z=>`
  const H: u32 = ${s};
  const C: u32 = ${u/o};
  const imageSize: u32 = ${s*u/o};

  ${z.declareVariables(p)}
  @group(0) @binding(1) var<storage, read_write> output : array<${y}>;

  ${z.mainStart(g)}
    let currentImageNumber = global_idx / ${g} / C;
    let currentChannelNumber = (global_idx / ${g}) % C;
    let wgId = global_idx % ${g};
    let wgOffset = wgId * ${C};
    if (wgOffset >= H) {
        return;
    }
    let wgMax = min(wgOffset + ${C}, H);

    let offset = currentImageNumber * imageSize + currentChannelNumber;
    var sum = ${et("f32",o)};
    var squaredSum = ${et("f32",o)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${$}(input[offset + i * C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${v("sum","squaredSum")};
  }`,P=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:o,n,h:s,c:u})},getRunData:()=>({outputs:[{dims:[n,u,g,2],dataType:1}],dispatchGroup:{x:n*u/o}}),getShaderSource:T},{inputs:[t],outputs:[-1]})[0],B=z=>`
  const H: u32 = ${s};
  const C: u32 = ${u/o};
  const imageSize: u32 = ${g*u/o};
  const epsilon: f32 = ${l};

  @group(0) @binding(0) var<storage, read> input : array<${y}>;
  @group(0) @binding(1) var<storage, read> scale : array<${m.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${w.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${y}>;

  ${z.mainStart()}
    ${z.guardAgainstOutOfBoundsWorkgroupSizes(S)}
    let currentImageNumber = global_idx / C;
    let currentChannelNumber = global_idx % C;

    let offset = currentImageNumber * imageSize;
    var sum = ${et("f32",o)};
    var squaredSum = ${et("f32",o)};
    for (var i: u32 = 0; i < ${g}; i++) {
        let value = input[offset + i + currentChannelNumber * ${g}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(H);
    squaredSum = squaredSum / f32(H);
    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);
    let channelScale = invStdDev * ${$}(scale[currentChannelNumber]);
    let channelShift = ${$}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${v("channelScale","channelShift")};
  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:o,n,h:s,c:u,epsilon:l})},getRunData:()=>({outputs:[{dims:[n,u,2],dataType:1}],dispatchGroup:{x:Math.ceil(S/64)}}),getShaderSource:B},{inputs:[P,r,a],outputs:[-1]})[0]},Ic=(e,t,r)=>{let a=t[0].dims,n=a,s=a[0],u=a[a.length-1],l=M.sizeFromDimension(a,1)/u,o=yt(u),p=M.size(n)/o,m=L("input",t[0].dataType,t[0].dims,o),w=Y("output",t[0].dataType,n,o),g=Be(t[0].dataType),y=o===1?"vec2f":`mat2x${o}f`,$=o===1?g:`vec${o}<${g}>`,v=Cc(e,t[0],t[1],t[2],s,l,u,r.epsilon),S=C=>`
  const H: u32 = ${l};
  const C: u32 = ${u/o};

  @group(0) @binding(0) var<storage, read> input : array<${m.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${y}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${w.type.storage}>;

  ${C.mainStart()}
    let currentImageNumber = global_idx / (C * H);
    let currentChannelNumber = global_idx % C;

    let scaleOffset = currentImageNumber * C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${$}(scale[0]), ${$}(scale[1]));
  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${r.cacheKey}`},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:S},{inputs:[t[0],v]})},ru=e=>se({epsilon:e.epsilon,format:e.format}),nu=(e,t)=>{t.format==="NHWC"?Ic(e,e.inputs,t):e.compute(Sc(e.inputs,t))}});var Ac,Ec,ou,iu,su=F(()=>{"use strict";Me();ge();Pe();ve();Ac=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Ec=(e,t,r)=>{let a=e[0].dims,n=e[1],s=e[2],u=a,l=M.normalizeAxis(t.axis,a.length),o=M.sizeToDimension(a,l),p=M.sizeFromDimension(a,l),m=M.size(n.dims),w=s?M.size(s.dims):0;if(m!==p||s&&w!==p)throw new Error(`Size of X.shape()[axis:] == ${p}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${m} and bias size of ${w}`);let g=[];for(let B=0;B<a.length;++B)B<l?g.push(a[B]):g.push(1);let y=yt(p),$=Be(e[0].dataType),v=[L("x",e[0].dataType,e[0].dims,y),L("scale",n.dataType,n.dims,y)];s&&v.push(L("bias",s.dataType,s.dims,y)),v.push(Y("output",e[0].dataType,u,y));let S=r>1,C=r>2;S&&v.push(Y("meanDataOutput",1,g)),C&&v.push(Y("invStdOutput",1,g));let T=B=>`
  const normSize: f32 = ${p};
  const normSizeVectorized: u32 = ${p/y};
  const epsilon: f32 = ${t.epsilon};

  ${B.declareVariables(...v)}
  ${B.mainStart()}
    ${B.guardAgainstOutOfBoundsWorkgroupSizes(o)}
    let offset = global_idx * normSizeVectorized;
    var meanVector = ${et("f32",y)};
    var meanSquareVector = ${et("f32",y)};

    for (var h: u32 = 0u; h < normSizeVectorized; h++) {
      let value = ${Nt($,y,"x[h + offset]")};
      meanVector += value;
      meanSquareVector += value * value;
    }
    let mean = ${It("meanVector",y)} / normSize;
    let meanSquare = sqrt(${It("meanSquareVector",y)} 
      / normSize - mean * mean + epsilon);

    for (var j: u32 = 0; j < normSizeVectorized; j++) {
      let f32input = ${Nt($,y,"x[j + offset]")};
      let f32scale = ${Nt($,y,"scale[j]")};
      output[j + offset] = ${v[0].type.value}((f32input - mean) / meanSquare * f32scale
        ${s?`+ ${Nt($,y,"bias[j]")}`:""}
      );
    }

    ${S?"meanDataOutput[global_idx] = mean":""};
    ${C?"invStdOutput[global_idx] = 1 / meanSquare":""};
  }`,P=[{dims:u,dataType:e[0].dataType}];return S&&P.push({dims:g,dataType:1}),C&&P.push({dims:g,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:T}},ou=e=>se({axis:e.axis,epsilon:e.epsilon}),iu=(e,t)=>{Ac(e.inputs),e.compute(Ec(e.inputs,t,e.outputCount))}});var _c,uu,lu=F(()=>{"use strict";ge();Sr();_c=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},uu=e=>{_c(e.inputs);let t=it.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");e.compute(bn(e.inputs,{activation:"",activationCacheKey:""},t))}});var Oc,Tc,Rc,kc,Pc,Bc,Dc,Mc,zc,du,cu,pu=F(()=>{"use strict";Me();ge();Pe();ve();Oc=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Tc=(e,t,r,a,n,s,u)=>{let l=r.length,o="";for(let p=l-1;p>=0;--p)o+=`
            k = i32(${e.indicesGet("indices",p)}) - ${n[p]};
            if (k < 0) {
              break;
            }
            if (k >= ${r[p]}) {
              break;
            }
            offset += k * ${a[p]};
        `;return`
          value = ${s}(${u});
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${o}
            value = x[offset];
          }
      `},Rc=(e,t,r,a,n)=>{let s=r.length,u="";for(let l=s-1;l>=0;--l)u+=`
                k = i32(${e.indicesGet("indices",l)}) - ${n[l]};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = ${2*(r[l]-1)};
                  k = k % _2n_1;
                  if(k >= ${r[l]}) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * ${a[l]};
            `;return`
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `},kc=(e,t,r,a,n)=>{let s=r.length,u="";for(let l=s-1;l>=0;--l)u+=`
                k = i32(${e.indicesGet("indices",l)}) - ${n[l]};
                if (k < 0) {
                  k = 0;
                }
                if (k >= ${r[l]}) {
                  k = ${r[l]-1};
                }
                offset += k * ${a[l]};
            `;return`
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `},Pc=(e,t,r,a,n)=>{let s=r.length,u="";for(let l=s-1;l>=0;--l)u+=`
                k = i32(${e.indicesGet("indices",l)}) - ${n[l]};
                if (k < 0)  {
                  k += ${r[l]};
                }
                if (k >= ${r[l]}) {
                  k -= ${r[l]};
                }
                offset += k * ${a[l]};
            `;return`
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `},Bc=(e,t,r,a,n,s)=>{switch(n.mode){case 0:return Tc(e,t,r,a,n.pads,s,n.value);case 1:return Rc(e,t,r,a,n.pads);case 2:return kc(e,t,r,a,n.pads);case 3:return Pc(e,t,r,a,n.pads);default:throw new Error("Invalid mode")}},Dc=(e,t,r,a)=>{let n=t[0].dims,s=M.padShape(n.slice(),r.pads),u=M.size(s),l=M.computeStrides(n),o=Y("output",t[0].dataType,s),p=L("x",t[0].dataType,n),m=Bc(o,s,n,l,r,a);return`
              ${e.declareVariables(p,o)}
              ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}

              let indices = ${o.offsetToIndices("global_idx")};

              var value = ${a}(0);
              ${m}
              output[global_idx] = value;
          }`},Mc=(e,t)=>{let r=M.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(M.size(r)/64)}}),getShaderSource:a=>Dc(a,e,t,"f32")}},zc=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),a=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,n=e[0].dims.length,s=new Int32Array(2*n).fill(0);if(e.length>=4){let l=e[3].getBigInt64Array();for(let o=0;o<l.length;o++)s[Number(l[o])]=Number(r[o]),s[Number(l[o])+n]=Number(r[o+l.length])}else r.forEach((l,o)=>s[Number(o)]=Number(l));let u=[];return s.forEach(l=>u.push(l)),se({mode:t.mode,value:a,pads:u})}else return t},du=(e,t)=>{Oc(e.inputs);let r=zc(e.inputs,t);e.compute(Mc(e.inputs,r),{inputs:[0]})},cu=e=>{let t=e.mode,r=e.value,a=e.pads;return se({mode:t,value:r,pads:a})}});var vn,fu,mu,hu,gu,yu,bu,wu,vu,$u,xu,Su,Cu,Iu,Au,Eu=F(()=>{"use strict";ge();Pe();ve();vn=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},fu=(e,t,r)=>{let a=t.format==="NHWC",n=e.dims.slice();a&&n.splice(1,0,n.pop());let s=Object.hasOwnProperty.call(t,"dilations"),u=t.kernelShape.slice(),l=t.strides.slice(),o=s?t.dilations.slice():[],p=t.pads.slice();zt.adjustPoolAttributes(r,n,u,l,o,p);let m=zt.computePoolOutputShape(r,n,l,o,u,p,t.autoPad),w=Object.assign({},t);s?Object.assign(w,{kernelShape:u,strides:l,pads:p,dilations:o,cacheKey:t.cacheKey}):Object.assign(w,{kernelShape:u,strides:l,pads:p,cacheKey:t.cacheKey});let g=m.slice();return g.push(g.splice(1,1)[0]),[w,a?g:m]},mu=(e,t,r,a,n,s,u,l)=>{let o=n.format==="NHWC",p=r,m=t.type.value,w=p.length,g=M.size(a),y=Y("output",t.type.tensor,a);if(n.kernelShape.length<=2){let $=n.kernelShape[n.kernelShape.length-1],v=n.strides[n.strides.length-1],S=n.pads[n.pads.length/2-1],C=n.pads[n.pads.length-1],T=w-(o?2:1),P="",B="",z="";if(S+C!==0?P=`
                for (var i: u32 = 0u; i < ${$}u; i++) {
                  xIndices[${T}] = indices[${T}] * ${v} - ${S} + i;
                  if (xIndices[${T}] < 0 || xIndices[${T}] >= ${p[T]}) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${s}
                }`:P=`
                for (var i: u32 = 0u; i < ${$}u; i++) {
                  xIndices[${T}] = indices[${T}] * ${v} - ${S} + i;
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${s}
                }`,n.kernelShape.length===2){let W=n.kernelShape[n.kernelShape.length-2],H=n.strides[n.strides.length-2],X=n.pads[n.pads.length/2-2],le=n.pads[n.pads.length-2],D=w-(o?3:2),q=p[D];X+le!==0?B=`
                for (var j: u32 = 0u; j < ${W}u; j++) {
                  xIndices[${D}] = indices[${D}] * ${H} - ${X} + j;
                  if (xIndices[${D}] < 0 || xIndices[${D}] >= ${q}) {
                    pad+= ${$};
                    continue;
                  }
              `:B=`
                for (var j: u32 = 0u; j < ${W}u; j++) {
                  xIndices[${D}] = indices[${D}] * ${H} - ${X} + j;
                `,z=`
              }
            `}return`
            ${e.declareVariables(t,y)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(g)}

              let indices = ${y.offsetToIndices("global_idx")};
              var xIndices = ${y.offsetToIndices("global_idx")};

              var value: ${m} = ${m}(${l});
              var pad = 0;
              ${B}
              ${P}
              ${z}
              ${u}

              output[global_idx] = value;
            }`}else{if(o)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let $=M.size(n.kernelShape),v=M.computeStrides(n.kernelShape),S=v.length,C=n.pads.length,T=n.pads.reduce((z,k)=>z+k),P="";return T?P=`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${t.indicesToOffset("xIndices")}];
                ${s}
              }`:P=`
              }
              let x_val = x[${t.indicesToOffset("xIndices")}];
              ${s}
            `,`
            ${e.declareVariables(t,y)}

            const pads = array<u32, ${C}>(${n.pads.map(z=>`${z}u`).join(",")});
            const inputDims = array<u32, ${w}>(${p.map(z=>`${z}u`).join(",")});
            const kernelStrides = array<u32, ${S}>(${v.map(z=>`${z}u`).join(",")});
            const strides = array<u32, ${S}>(${n.strides.map(z=>`${z}u`).join(",")});

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(g)}

              let indices = ${y.offsetToIndices("global_idx")};
              let xIndices = ${y.offsetToIndices("global_idx")};

              var offsets: array<u32, ${S}>;

              var value = ${y.type.value}(${l});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${$}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${S-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${S-1}] = offset;

                isPad = false;
                for (var j = ${w-S}u; j < ${w}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${w-S}u]
                    + offsets[j - ${w-S}u] - pads[j - 2u];
                  ${P}
              }
              ${u}

              output[global_idx] = value;
            }`}},hu=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),gu=(e,t,r,a)=>{let[n,s]=fu(t,a,r),u=M.size(n.kernelShape),l=L("x",t.dataType,t.dims),o=l.type.value,p="value += x_val;",m="";return n.countIncludePad?m+=`value /= ${o}(${u});`:m+=`value /= ${o}(${u} - pad);`,{name:e,shaderCache:{hint:a.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(M.size(s)/64)}}),getShaderSource:w=>mu(w,l,t.dims,s,n,p,m,"0.0")}},yu=e=>{let t=e.count_include_pad!==0,r=hu(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return se({countIncludePad:t,...r})},bu=(e,t)=>{vn(e.inputs),e.compute(gu("AveragePool",e.inputs[0],!1,t))},wu={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},vu=e=>{let t=e.format;return{format:t,...wu,cacheKey:t}},$u=(e,t)=>{vn(e.inputs),e.compute(gu("GlobalAveragePool",e.inputs[0],!0,t))},xu=(e,t,r,a)=>{let[n,s]=fu(t,a,r),u=`
      value = max(x_val, value);
    `,l="",o=L("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:a.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(M.size(s)/64)}}),getShaderSource:p=>mu(p,o,t.dims,s,n,u,l,"-1e5")}},Su=(e,t)=>{vn(e.inputs),e.compute(xu("MaxPool",e.inputs[0],!1,t))},Cu=e=>{let t=e.storage_order,r=e.dilations,a=hu(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(a.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return se({storageOrder:t,dilations:r,...a})},Iu=e=>{let t=e.format;return{format:t,...wu,cacheKey:t}},Au=(e,t)=>{vn(e.inputs),e.compute(xu("GlobalMaxPool",e.inputs[0],!0,t))}});var Nc,Uc,_u,Ou=F(()=>{"use strict";ot();Me();ve();Nc=(e,t,r)=>{let a=e===t,n=e<t&&r<0,s=e>t&&r>0;if(a||n||s)throw new Error("Range these inputs' contents are invalid.")},Uc=(e,t,r,a)=>{let n=Math.abs(Math.ceil((t-e)/r)),s=[n],u=n,l=Y("output",a,s),o=l.type.storage,p=m=>`
        ${m.declareVariables(l)}
        ${m.mainStart()}
        ${m.guardAgainstOutOfBoundsWorkgroupSizes(u)}
        output[global_idx] = ${o}(${e}) + ${o}(global_idx) * ${o}(${r});
      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(m=>m.toString()).join("_")},getShaderSource:p,getRunData:()=>({outputs:[{dims:s,dataType:a}],dispatchGroup:{x:Math.ceil(u/64)}})}},_u=e=>{let t=0,r=0,a=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],a=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],a=e.inputs[2].getFloat32Array()[0]),Ie.webgpu.validateInputContent&&Nc(t,r,a),e.compute(Uc(t,r,a,e.inputs[0].dataType),{inputs:[]})}});var Vc,Gc,Lc,Fc,Hc,jc,qc,Kc,Yc,Xc,Jc,Zc,Qc,ep,tp,Tu,Ru,ku=F(()=>{"use strict";ge();Pe();ve();Vc=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Gc=(e,t,r)=>{t.every(n=>n>=0&&n<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let a=new Array(r).fill(1);return t.forEach((n,s)=>a[n]=e[s]),a},Lc=(e,t,r,a,n,s)=>{let[u,l,o]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],p=e[0].dims.length;if(u>0&&e.length>u&&e[u].dims.length>0)e[u].getFloat32Array().forEach(m=>s.push(m));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(l>0&&e.length>l&&e[l].dims.length>0){if(e[l].getFloat32Array().forEach(m=>a.push(m)),a.length!==0&&a.length!==p&&r>=18&&a.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Vc(a,t),t.axes.length>0&&Gc(a,t.axes,p).forEach((m,w)=>a[w]=m)}if(o>0&&e.length>o&&(e[o].getBigInt64Array().forEach(m=>n.push(Number(m))),n.length!==p||r>=18&&n.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(a.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(n.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof a<"u"&&typeof n<"u"&&a.length>0&&n.length>p)throw new Error("Resize requires only of scales or sizes to be specified")},Fc=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`
`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",Hc=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",jc=(e,t,r)=>{let a=new Array(r).fill(0).concat(new Array(r).fill(1)),n=e.length===0?a:e.slice();return t.length>0?(t.forEach((s,u)=>{a[s]=n[u],a[u+r]=n[t.length+u]}),a):n},qc=(e,t,r,a)=>{let n=[];if(r.length>0)if(a.length>0){if(e.forEach(s=>n.push(s)),Math.max(...a)>e.length)throw new Error("axes is out of bound");a.forEach((s,u)=>n[s]=r[u])}else r.forEach(s=>n.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");n=e.map((s,u)=>Math.round(s*t[u]))}return n},Kc=(e,t,r,a)=>{let n=(()=>{switch(a.keepAspectRatioPolicy){case"not_larger":return a.axes.length>0?Math.min(...a.axes.map(u=>r[u]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return a.axes.length>0?Math.max(...a.axes.map(u=>r[u]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${a.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let s=e.slice();return a.axes.length>0?(a.axes.forEach(u=>r[u]=n),a.axes.forEach(u=>s[u]=Math.round(e[u]*r[u]))):(r.fill(n,0,r.length),s.forEach((u,l)=>s[l]=Math.round(u*r[l]))),s},Yc=(e,t,r,a,n)=>`
    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${r.length}> {
      const inputShape = array<u32, ${t.length}>(${t.map(s=>`${s}u`).join(",")});
      const outputShape = array<u32, ${r.length}>(${r.map(s=>`${s}u`).join(",")});
      const scales = array<f32, ${a.length}>(${a.map(s=>`${s}f`).join(",")});
      const roi = array<f32, ${n.length}>(${n.map(s=>`${s}f`).join(",")});
      var originalIndices: array<f32, ${r.length}>;
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};
        if (scales[i] == 1.0) {
          originalIndices[i] = f32(outputIndex);
        } else {
          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);
        }
      }
      return originalIndices;
    }`,Xc=(e,t,r,a,n,s,u)=>`
    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {
        const inputShape = array<u32, ${r.length}>(${r.map(l=>`${l}u`).join(",")});
        const outputShape = array<u32, ${a.length}>(${a.map(l=>`${l}u`).join(",")});
        const scales = array<f32, ${n.length}>(${n.map(l=>`${l}f`).join(",")});
        const roi = array<f32, ${s.length}>(${s.map(l=>`${l}f`).join(",")});
        var inputIndices: ${e.type.indices};
        for (var i:u32 = 0; i < ${a.length}; i++) {
          var outputIndex = ${a.length===1?"outputIndices":"outputIndices[i]"};
          var inputIndex: u32;
          if (scales[i] == 1.0) {
            inputIndex = outputIndex;
          } else {
            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);
            if (!${u} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {
              if (original_idx < 0) {
                inputIndex = 0;
              } else if (original_idx > (f32(inputShape[i]) - 1)) {
                inputIndex = inputShape[i] - 1;
              } else {
                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));
              }
            } else {
              inputIndex = u32(original_idx);
            }
          }
          ${e.indicesSet("inputIndices","i","inputIndex")}
        }
        return inputIndices;
    }`,Jc=(e,t)=>`
    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {
      const inputShape = array<u32, ${t.length}>(${t.map(r=>`${r}u`).join(",")});
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var inputIndex = ${t.length===1?"inputIndices":"inputIndices[i]"};
        if (inputIndex < 0 || inputIndex >= inputShape[i]) {
          return false;
        }
      }
      return true;
    }`,Zc=(e,t,r,a,n,s,u)=>{let[l,o,p,m]=r.length===2?[-1,0,1,-1]:n[1]===1?[0,2,3,1]:[0,1,2,3];return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {
      var inputIndices: ${e.type.indices};
      inputIndices[${o}] = max(0, min(row, ${r[o]} - 1));
      inputIndices[${p}] = max(0, min(col, ${r[p]} - 1));
      if (${r.length} > 2) {
        inputIndices[${m}] = channel;
        inputIndices[${l}] = batch;
      };
      return input[${e.indicesToOffset("inputIndices")}];
    }

    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);
      var row:f32 = originalIndices[${o}];
      var col:f32 = originalIndices[${p}];
      if (${s} && (row < 0 || row > (${r[o]} - 1) || col < 0 || col > ${r[p]} - 1)) {
        return ${u};
      }
      row = max(0, min(row, ${r[o]} - 1));
      col = max(0, min(col, ${r[p]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = 0;
      var batch: u32 = 0;
      if (${r.length>2}) {
        channel = u32(originalIndices[${m}]);
        batch = u32(originalIndices[${l}]);
      }
      var x11: f32 = getInputValue(batch, channel, row1, col1);
      var x12: f32 = getInputValue(batch, channel, row1, col2);
      var x21: f32 = getInputValue(batch, channel, row2, col1);
      var x22: f32 = getInputValue(batch, channel, row2, col2);
      var dx1: f32 = row - f32(row1);
      var dx2: f32 = f32(row2 ) - row;
      var dy1 = col - f32(col1);
      var dy2 = f32(col2) - col;
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},Qc=(e,t,r,a,n,s,u,l,o,p)=>{let[m,w]=r.length===2?[0,1]:n[1]===1?[2,3]:[1,2],g=y=>{let $=y===m?"row":"col";return`
      fn ${$}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {
        var outputIndex = ${a.length===1?"outputIndices":`outputIndices[${y}]`};
        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${n[y]},
        f32(${a[y]}), f32(${r[y]}), ${s[y]}, ${s[y]} + ${r.length});
        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${l} && (originalIdx < 0 || originalIdx > (${r[y]} - 1))) {
          return ${o};
        }
        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${$}: f32 = originalIdx + f32(i);
          if (${$} < 0 || ${$} >= ${r[y]}) {
            if (${p}) {
              coefs[i + 1] = 0.0;
              continue;
            } else if (${l}) {
              return ${o};
            } else {
              ${$} = max(0, min(${$}, ${r[y]} - 1));
            }
          }
          var inputIndicesCopy: ${e.type.indices} = inputIndices;
          inputIndicesCopy[${y}] = u32(${$});
          data[i + 1] = ${y===m?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`
                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${g(m)};
    ${g(w)};
  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {
    var absS = abs(s);
    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: f32 = 1.0 - absS;
    var twoMinusAbsS: f32 = 2.0 - absS;
    var onePlusAbsS: f32 = 1.0 + absS;
    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};
    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;
    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {
    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {
    var inputIndices: ${e.type.indices} = outputIndices;
    return colCubicInterpolation(inputIndices, outputIndices);
  }
    `},ep=(e,t,r,a,n,s)=>{let u=e.dims,l=jc(s,t.axes,u.length),o=qc(u,a,n,t.axes),p=a.slice();a.length===0&&(p=u.map((S,C)=>S===0?1:o[C]/S),t.keepAspectRatioPolicy!=="stretch"&&(o=Kc(u,o,p,t)));let m=Y("output",e.dataType,o),w=L("input",e.dataType,u),g=M.size(o),y=u.length===o.length&&u.every((S,C)=>S===o[C]),$=t.coordinateTransformMode==="tf_crop_and_resize",v=S=>`
      ${y?"":`
      ${Fc(t.coordinateTransformMode)};
      ${(()=>{switch(t.mode){case"nearest":return`
              ${Jc(w,u)};
              ${Hc(t.nearestMode,r)};
              ${Xc(w,m,u,o,p,l,$)};
              `;case"linear":return`
              ${Yc(m,u,o,p,l)};
              ${Zc(w,m,u,o,p,$,t.extrapolationValue)};
              `;case"cubic":return`
            ${Qc(w,m,u,o,p,l,t.cubicCoeffA,$,t.extrapolationValue,t.excludeOutside)};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${S.declareVariables(w,m)}
      ${S.mainStart()}
        ${S.guardAgainstOutOfBoundsWorkgroupSizes(g)}
        ${y?"output[global_idx] = input[global_idx];":`
        let outputIndices = ${m.offsetToIndices("global_idx")};
        var inputIndices: ${w.type.indices};
        ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);
                if (checkInputIndices(inputIndices)) {
                  output[global_idx] = input[${w.indicesToOffset("inputIndices")}];
                } else {
                  output[global_idx] = ${t.extrapolationValue};
                }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};
        `}
      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${p.length>0?p:""}|${n.length>0?n:""}|${y}`},getShaderSource:v,getRunData:()=>({outputs:[{dims:o,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(g/64)}})}},tp=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Tu=(e,t)=>{let r=[],a=[],n=[],s=tp(e);Lc(e.inputs,t,s,r,a,n),e.compute(ep(e.inputs[0],t,s,r,a,n),{inputs:[0]})},Ru=e=>{let t=e.antialias,r=e.axes,a=e.coordinateTransformMode,n=e.cubicCoeffA,s=e.excludeOutside!==0,u=e.extrapolationValue,l=e.keepAspectRatioPolicy,o=e.mode,p=e.nearestMode===""?"simple":e.nearestMode;return se({antialias:t,axes:r,coordinateTransformMode:a,cubicCoeffA:n,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:l,mode:o,nearestMode:p})}});var rp,np,Pu,Bu,Du=F(()=>{"use strict";Me();ge();Pe();ve();rp=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],a=e[2];if(t.dataType!==r.dataType||t.dataType!==a.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let n=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==n)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(a.dims.length!==1)throw new Error("Gamma must be 1D");if(a.dims[a.dims.length-1]!==n)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let u=e[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let u=e[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Bias must have the same hidden size as input")}},np=(e,t,r,a)=>{let n=e[0].dims,s=M.size(n),u=n,l=s,o=n.slice(-1)[0],p=a?n.slice(0,-1).concat(1):[],m=e.length>3,w=e.length>4,g=a&&r>1,y=a&&r>2,$=r>3,v=yt(o),S=[L("x",e[0].dataType,e[0].dims,v),L("skip",e[1].dataType,e[1].dims,v),L("gamma",e[2].dataType,e[2].dims,v)];m&&S.push(L("beta",e[3].dataType,e[3].dims,v)),w&&S.push(L("bias",e[4].dataType,e[4].dims,v)),S.push(Y("output",e[0].dataType,u,v)),g&&S.push(Y("meanOutput",1,p)),y&&S.push(Y("invStdOutput",1,p)),$&&S.push(Y("inputSkipBiasSum",e[0].dataType,u,v));let C=Be(e[0].dataType),T=B=>`
      const hiddenSize: f32 = ${o};
      const hiddenSizeVectorized: u32 = ${o/v};
      const epsilon: f32 = ${t.epsilon};

      ${B.declareVariables(...S)}

      ${B.mainStart()}
        ${B.guardAgainstOutOfBoundsWorkgroupSizes(l/o)}
        let offset = global_idx * hiddenSizeVectorized;
        var sum = ${et("f32",v)};
        var squareSum = ${et("f32",v)};
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          let skipValue = skip[offset + i];
          let biasValue = ${w?"bias[i]":"0.0"};
          let inputValue = x[offset + i];
          let value = inputValue + skipValue + biasValue;
          ${$?"inputSkipBiasSum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32Value = ${Nt(C,v,"value")};
          sum += f32Value;
          squareSum += f32Value * f32Value;
        }
        let mean = ${It("sum",v)} / hiddenSize;
        let variance = sqrt(${It("squareSum",v)} / hiddenSize - mean * mean + epsilon);
        ${g?"meanOutput[global_idx] = mean;":""}
        ${y?"invStdOutput[global_idx] = 1.0 / variance;":""}
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          output[offset + i] = (output[offset + i] - ${C}(mean)) / ${C}(variance) * gamma[i]
           + ${m?"beta[i]":"0.0"};
        }
      }`,P=[{dims:u,dataType:e[0].dataType}];return r>1&&P.push({dims:p,dataType:1}),r>2&&P.push({dims:p,dataType:1}),r>3&&P.push({dims:n,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:T,getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(l/o/64)}})}},Pu=(e,t)=>{rp(e.inputs);let a=[0];e.outputCount>1&&a.push(-3),e.outputCount>2&&a.push(-3),e.outputCount>3&&a.push(3),e.compute(np(e.inputs,t,e.outputCount,!1),{outputs:a})},Bu=e=>{let t=e.epsilon;return se({epsilon:t})}});var ap,$n,op,Mu,ip,sp,zu,Wu,Nu=F(()=>{"use strict";Me();ge();Pe();ve();ap=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,a)=>{if(e[a+1].dataType!==6&&e[a+1].dataType!==7)throw new Error(`Input ${a} must be an array of int32 or int64`)})},$n=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(a=>r.push(Number(a)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(a=>r.push(Number(a)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},op=(e,t)=>{if(e.length>1){let r=$n(e,1),a=$n(e,2),n=$n(e,3);return n.length===0&&(n=[...Array(e[0].dims.length).keys()]),se({starts:r,ends:a,axes:n})}else return t},Mu=(e,t,r,a,n)=>{let s=e;return e<0&&(s+=r[a[t]]),n[t]<0?Math.max(0,Math.min(s,r[a[t]]-1)):Math.max(0,Math.min(s,r[a[t]]))},ip=(e,t,r,a)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {
          var inputIndices: ${e.type.indices};
          var carry = 0u;
          for (var i = ${r.length}; i >= 0; i--) {
            var outputIndex = ${a.length===1?"outputIndices":"outputIndices[i]"};
            var inputIndex = outputIndex * steps[i] + starts[i] + carry;
            carry = inputIndex / inputShape[i];
            inputIndex = inputIndex % inputShape[i];
            if (signs[i] < 0) {
              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];
            }
            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;
          }
          return inputIndices;
      }`,sp=(e,t)=>{let r=e[0].dims,a=M.size(r),n=t.axes.length>0?M.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=$n(e,4);s.forEach(v=>v!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(n.length).fill(1));let u=t.starts.map((v,S)=>Mu(v,S,r,n,s)),l=t.ends.map((v,S)=>Mu(v,S,r,n,s));if(n.length!==r.length)for(let v=0;v<r.length;++v)n.includes(v)||(u.splice(v,0,0),l.splice(v,0,r[v]),s.splice(v,0,1));let o=s.map(v=>Math.sign(v));s.forEach((v,S,C)=>{if(v<0){let T=(l[S]-u[S])/v,P=u[S],B=P+T*s[S];u[S]=B,l[S]=P,C[S]=-v}});let p=r.slice(0);n.forEach((v,S)=>{p[v]=Math.ceil((l[v]-u[v])/s[v])});let m={dims:p,dataType:e[0].dataType},w=Y("output",e[0].dataType,p),g=L("input",e[0].dataType,r),y=M.size(p),$=v=>`
      ${v.declareVariables(g,w)}
        const signs = array<i32, ${o.length}>(${o.map(S=>`${S}i`).join(",")});
        const starts = array<u32, ${u.length}>(${u.map(S=>`${S}u`).join(",")});
        const ends = array<u32, ${l.length}>(${l.map(S=>`${S}u`).join(",")});
        const steps = array<u32, ${s.length}>(${s.map(S=>`${S}u`).join(",")});
        const inputShape = array<u32, ${r.length}>(${r.map(S=>`${S}u`).join(",")});

        ${ip(g,w,r,p)}
        ${v.mainStart()}
          ${v.guardAgainstOutOfBoundsWorkgroupSizes(y)}
          let outputIndices = ${w.offsetToIndices("global_idx")};
          let inputIndices = calculateInputIndices(outputIndices);
          ${w.setByOffset("global_idx",g.getByIndices("inputIndices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${t.cacheKey}|${e[4]?.dims??""}`},getShaderSource:$,getRunData:()=>({outputs:[m],dispatchGroup:{x:Math.ceil(a/64)}})}},zu=(e,t)=>{ap(e.inputs,t);let r=op(e.inputs,t);e.compute(sp(e.inputs,r),{inputs:[0]})},Wu=e=>{let t=e.starts,r=e.ends,a=e.axes;return se({starts:t,ends:r,axes:a})}});var up,lp,Uu,Vu,Gu=F(()=>{"use strict";ge();Pe();ve();up=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},lp=(e,t)=>{let r=e.dims,a=M.size(r),n=64,s=t.axis;if(s<0&&(s=r.length+s),s<r.length-1)throw new Error("softmax only supports last axis for now.");let u=r[s],l=a/u,o=yt(u),p=u/o,m=(S,C)=>C===4?`max(max(${S}.x, ${S}.y), max(${S}.z, ${S}.w))`:C===2?`max(${S}.x, ${S}.y)`:C===3?`max(max(${S}.x, ${S}.y), ${S}.z)`:S,w=L("x",e.dataType,e.dims,o),g=Y("result",e.dataType,e.dims,o),y=w.type.value,$=Be(e.dataType)==="f32"?`var threadMax = ${y}(-3.402823e+38f);`:`var threadMax = ${y}(-65504.0h);`,v=S=>`
      var<workgroup> rowMaxShared : ${y};
      var<workgroup> rowSumShared : ${y};
      var<workgroup> threadShared : array<${y}, ${n}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${y} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${y}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${S.registerUniform("packedCols","i32").declareVariables(w,g)}
      ${S.mainStart()}
        let gindex = i32(global_id.x);
        let lindex = i32(local_id.x);
        const wg = ${n};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${$}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${y}(${m("threadShared[0]",o)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${y}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${y}(${It("threadShared[0]",o)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;return{name:"Softmax",shaderCache:{hint:`${o}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:l},programUniforms:[{type:"uint32",data:p}]}),getShaderSource:v}},Uu=(e,t)=>{up(e.inputs),e.compute(lp(e.inputs[0],t))},Vu=e=>se({axis:e.axis})});var dp,cp,pp,fp,mp,Lu,Fu,Hu=F(()=>{"use strict";ge();Pe();ve();dp=e=>{if(!e||e.length<1)throw new Error("too few inputs")},cp=(e,t)=>{let r=[],a=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),a=r.length),se({numOutputs:a,axis:t.axis,splitSizes:r})},pp=e=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
    if (index < sizeInConcatAxis[i]) {
        return i;
    }
    }
    return ${e}u;
}`,fp=e=>{let t=e.length,r=[];for(let a=0;a<t;++a){let n=e[a].setByIndices("indices","input[global_idx]");t===1?r.push(n):a===0?r.push(`if (outputNumber == ${a}u) { ${n} }`):a===t-1?r.push(`else { ${n} }`):r.push(`else if (outputNumber == ${a}) { ${n} }`)}return`
      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {
        ${r.join(`
`)}
      }`},mp=(e,t)=>{let r=e[0].dims,a=M.size(r),n=e[0].dataType,s=r.length,u=t.axis,l=u<0?r.length+u:u,o=new Array(t.numOutputs),p=L("input",n,r),m=new Array(t.numOutputs),w=[],g=[],y=0;for(let S=0;S<t.numOutputs;S++){y+=t.splitSizes[S],m[S]=y;let C=r.slice();C[t.axis]=t.splitSizes[S],g.push(C),o[S]=Y(`output${S}`,n,g[S]),w.push({dims:g[S],dataType:e[0].dataType})}let $=s<2?"indices":`indices[${l}]`,v=S=>`
  ${S.declareVariables(p,...o)}
  const sizeInConcatAxis = array<u32, ${m.length}>(${m.map(C=>`${C}u`).join(",")});
  ${pp(m.length)}
  ${fp(o)}

  ${S.mainStart()}
    ${S.guardAgainstOutOfBoundsWorkgroupSizes(a)}

    var indices = ${p.offsetToIndices("global_idx")};
    let outputNumber = calculateOutputIndex(${$});
    if (outputNumber != 0) {
        ${$} -= sizeInConcatAxis[outputNumber - 1u];
    }
    writeBufferData(outputNumber, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:v,getRunData:()=>({outputs:w,dispatchGroup:{x:Math.ceil(a/64)}})}},Lu=(e,t)=>{dp(e.inputs);let r=e.inputs.length===1?t:cp(e.inputs,t);e.compute(mp(e.inputs,r),{inputs:[0]})},Fu=e=>{let t=e.axis,r=e.splitSizes,a=e.numOutputs<0?r.length:e.numOutputs;if(a!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return se({axis:t,numOutputs:a,splitSizes:r})}});var ju,hp,gp,yp,qu,Ku=F(()=>{"use strict";Me();ge();ve();ju=e=>Array.from(e.getBigInt64Array(),Number),hp=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(ju(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},gp=(e,t)=>{let r=[];for(let a=0;a<e.length;++a)r.push(e[a]*t[a]);return r},yp=e=>{let t=e[0].dims,r=ju(e[1]),a=gp(t,r),n=M.size(a),s=e[0].dataType,u=L("input",s,t),l=Y("output",s,a),o=p=>`
      const inputShape = ${u.indices(...t)};
      ${p.declareVariables(u,l)}
      ${p.mainStart()}
      ${p.guardAgainstOutOfBoundsWorkgroupSizes(n)}
      let outputIndices = ${l.offsetToIndices("global_idx")};
      var inputIndices: ${u.type.indices};
      for (var i = 0; i < ${t.length}; i++) {
        let inputDimValue = ${l.indicesGet("outputIndices","i")}  % ${u.indicesGet("inputShape","i")};

        ${u.indicesSet("inputIndices","i","inputDimValue")}
      }
      ${l.setByOffset("global_idx",u.getByIndices("inputIndices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}}),getShaderSource:o}},qu=e=>{hp(e.inputs),e.compute(yp(e.inputs),{inputs:[0]})}});var bp,wp,Yu,Xu=F(()=>{"use strict";Me();ge();ve();bp=(e,t,r,a,n)=>{let s=M.size(r),u=Math.ceil(s/4),l=Y("outputData",n,r,4),o=L("aData",t[1].dataType,t[1].dims,4),p=L("bData",t[2].dataType,t[2].dims,4),m=L("cData",t[0].dataType,t[0].dims,4),w,g=(y,$,v)=>`select(${$}, ${y}, ${v})`;if(!a)w=l.setByOffset("global_idx",g(o.getByOffset("global_idx"),p.getByOffset("global_idx"),m.getByOffset("global_idx")));else{let y=($,v,S="")=>{let C=`aData[indexA${v}][componentA${v}]`,T=`bData[indexB${v}][componentB${v}]`,P=`bool(cData[indexC${v}] & ${4278190080>>>(3-v)*8}u)`;return`
            let outputIndices${v} = ${l.offsetToIndices(`global_idx * 4u + ${v}u`)};
            let offsetA${v} = ${o.broadcastedIndicesToOffset(`outputIndices${v}`,l)};
            let offsetB${v} = ${p.broadcastedIndicesToOffset(`outputIndices${v}`,l)};
            let offsetC${v} = ${m.broadcastedIndicesToOffset(`outputIndices${v}`,l)};
            let indexA${v} = offsetA${v} / 4u;
            let indexB${v} = offsetB${v} / 4u;
            let indexC${v} = offsetC${v} / 4u;
            let componentA${v} = offsetA${v} % 4u;
            let componentB${v} = offsetB${v} % 4u;
            ${$}[${v}] = ${S}(${g(C,T,P)});
          `};n===9?w=`
            var data = vec4<u32>(0);
            ${y("data",0,"u32")}
            ${y("data",1,"u32")}
            ${y("data",2,"u32")}
            ${y("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:w=`
            ${y("outputData[global_idx]",0)}
            ${y("outputData[global_idx]",1)}
            ${y("outputData[global_idx]",2)}
            ${y("outputData[global_idx]",3)}
          `}return`
        ${e.declareVariables(m,o,p,l)}
        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}
        ${w}
      }`},wp=e=>{let t=e[1].dims,r=e[2].dims,a=e[0].dims,n=e[1].dataType,s=!(M.areEqual(t,r)&&M.areEqual(r,a)),u=t,l=M.size(t);if(s){let o=it.calcShape(it.calcShape(t,r,!1),a,!1);if(!o)throw new Error("Can't perform where op on the given tensors");u=o,l=M.size(u)}return{name:"Where",getShaderSource:o=>bp(o,e,u,s,n),getRunData:()=>({outputs:[{dims:u,dataType:n}],dispatchGroup:{x:Math.ceil(l/64/4)}})}},Yu=e=>{e.compute(wp(e.inputs))}});var Ju,Zu=F(()=>{"use strict";Ri();Pi();ps();Ss();As();la();Ns();Ls();js();Ys();Zs();tu();au();su();lu();pu();Eu();Ou();un();ku();Du();Nu();Gu();Hu();Ku();wr();oa();Xu();Ju=new Map([["Abs",[Bi]],["Acos",[Di]],["Acosh",[Mi]],["Add",[fs]],["ArgMax",[Ti,na]],["ArgMin",[Oi,na]],["Asin",[zi]],["Asinh",[Wi]],["Atan",[Ni]],["Atanh",[Ui]],["AveragePool",[bu,yu]],["BiasAdd",[ki]],["BiasSplitGelu",[cs]],["Cast",[Gi,Vi]],["Ceil",[Fi]],["ClipV10",[aa]],["Clip",[Li]],["Concat",[Cs,Is]],["Conv",[ca,da]],["ConvTranspose",[Ws,zs]],["Cos",[Hi]],["Cosh",[ji]],["Div",[ms]],["Einsum",[Vs,Gs]],["Elu",[qi,dn]],["Equal",[hs]],["Erf",[Ki]],["Exp",[Yi]],["Expand",[Hs]],["Floor",[Xi]],["FusedConv",[ca,da]],["Gather",[Ks,qs]],["GatherElements",[Js,Xs]],["Gelu",[Ji]],["Gemm",[Qs,eu]],["GlobalAveragePool",[$u,vu]],["GlobalMaxPool",[Au,Iu]],["Greater",[ws]],["GreaterOrEqual",[$s]],["InstanceNormalization",[nu,ru]],["LayerNormalization",[iu,ou]],["LeakyRelu",[Zi,dn]],["Less",[vs]],["LessOrEqual",[xs]],["Log",[ds]],["MatMul",[uu]],["MaxPool",[Su,Cu]],["Mul",[gs]],["Neg",[es]],["Not",[Qi]],["Pad",[du,cu]],["Pow",[ys]],["Range",[_u]],["Reciprocal",[ts]],["ReduceMin",[xi,tt]],["ReduceMean",[yi,tt]],["ReduceMax",[$i,tt]],["ReduceSum",[Ci,tt]],["ReduceProd",[Si,tt]],["ReduceL1",[bi,tt]],["ReduceL2",[wi,tt]],["ReduceLogSum",[Ai,tt]],["ReduceLogSumExp",[vi,tt]],["ReduceSumSquare",[Ii,tt]],["Relu",[rs]],["Resize",[Tu,Ru]],["Sigmoid",[ns]],["Sin",[as]],["Sinh",[os]],["Slice",[zu,Wu]],["SkipLayerNormalization",[Pu,Bu]],["Split",[Lu,Fu]],["Sqrt",[is]],["Softmax",[Uu,Vu]],["Sub",[bs]],["Tan",[ss]],["Tanh",[us]],["ThresholdedRelu",[ls,dn]],["Tile",[qu]],["Transpose",[ai,oi]],["Where",[Yu]]])});var xn,Qu=F(()=>{"use strict";ot();Me();Ct();ve();rn();xn=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,a,n,s,u,l){je(t.programInfo.name);let o=this.backend.device,p=this.backend.getComputePassEncoder();this.backend.queryType===1&&p.writeTimestamp(this.backend.querySet,this.backend.pendingDispathNumber*2),p.setPipeline(t.computePipeline);let m=[];for(let g of n)m.push({binding:m.length,resource:{buffer:g.buffer}});for(let g of s)m.push({binding:m.length,resource:{buffer:g.buffer}});l&&m.push({binding:m.length,resource:l});let w=o.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:m,label:t.programInfo.name});if(p.setBindGroup(0,w),p.dispatchWorkgroups(...u),this.backend.queryType!==0){let g=this.backend.currentKernelId,$=this.backend.kernels.get(g)[0];t.programInfo.name!==$&&($=`${$}/${t.programInfo.name}`);let v=[];r.forEach((C,T)=>{v.push(`${T}: [${C.dims}] | ${gr(C.dataType)}`)});let S=[];a.forEach((C,T)=>{S.push(`${T}: [${C.dims}] | ${gr(C.dataType)}`)}),this.backend.pendingKernelInfo.push([g,$,v,S]),this.backend.queryType===1&&p.writeTimestamp(this.backend.querySet,this.backend.pendingDispathNumber*2+1)}this.backend.pendingDispathNumber++,this.backend.pendingDispathNumber>=this.backend.maxDispatchNumber&&this.backend.endComputePass(),this.backend.pendingDispathNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),qe(t.programInfo.name)}dispose(){}build(t,r){je(t.name);let a=this.backend.device,n=[];a.features.has("shader-f16")&&n.push("enable f16;");let s=ri(r),u=t.getShaderSource(s),l=`${n.join(`
`)}
${s.additionalImplementations}
${u}`,o=a.createShaderModule({code:l,label:t.name});_e("verbose",()=>`[WebGPU] ${t.name} shader code: ${l}`);let p=a.createComputePipeline({compute:{module:o,entryPoint:"main"},layout:"auto",label:t.name});return qe(t.name),{programInfo:t,computePipeline:p}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,a=typeof t=="number"?1:t.y||1,n=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=s&&a<=s&&n<=s)return[r,a,n];let u=r*a*n,l=Math.ceil(Math.sqrt(u));if(l>s){if(l=Math.ceil(Math.cbrt(u)),l>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[l,l,l]}else return[l,l,1]}}});var $p,xp,Sn,el=F(()=>{"use strict";ot();Ct();Xo();Qo();Zu();Qu();rn();$p=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let a=0;a<e.length;++a){let n=e[a].dataType;switch(t[a]){case"none":{r.push("");break}case"type":{r.push(`${n}`);break}case"rank":{let s=e[a].dims.length;r.push(`${n};${s}`);break}case"dims":{let s=e[a].dims.join(",");r.push(`${n};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[a]}`)}}return r.join("|")},xp=(e,t)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=`:${$p(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},Sn=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispathNumber=0;this.maxDispatchNumber=16;this.pendingKernelInfo=[];this.pendingKernelInfoIndexId=0;this.pendingKernelInfoIndexName=1;this.pendingKernelInfoIndexInputs=2;this.pendingKernelInfoIndexOutputs=3;this.pendingQueries={};this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let a=[],n={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:a};r.features.has("chromium-experimental-timestamp-query-inside-passes")?a.push("chromium-experimental-timestamp-query-inside-passes"):r.features.has("timestamp-query")&&a.push("timestamp-query"),r.features.has("shader-f16")&&a.push("shader-f16"),this.device=await r.requestDevice(n),this.gpuDataManager=Zo(this),this.programManager=new xn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,this.queryType=0,this.env.webgpu.profilingMode,this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType=1:this.device.features.has("timestamp-query")&&(this.queryType=2),this.queryType!==0&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveData=this.gpuDataManager.create(this.maxDispatchNumber*2*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE)),Ko(t.logLevel,!!t.debug),Yr(!!t.trace),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.queryType===2&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispathNumber*2,endOfPassWriteIndex:this.pendingDispathNumber*2+1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;je();let t;this.queryType!==0&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispathNumber*2,this.queryResolveData.buffer,0),t=this.gpuDataManager.create(this.pendingDispathNumber*2*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.pendingQueries[t.id]=this.pendingKernelInfo,this.pendingKernelInfo=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveData.buffer,0,t.buffer,0,this.pendingDispathNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispathNumber=0,this.queryType!==0&&t.buffer.mapAsync(GPUMapMode.READ).then(()=>{let r=new BigUint64Array(t.buffer.getMappedRange()),a=this.pendingQueries[t.id];for(let n=0;n<r.length/2;n++){let s=a[n][this.pendingKernelInfoIndexName],u=r[n*2],l=r[n*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=u);let o=Number(u-this.queryTimeBase),p=Number(l-this.queryTimeBase);if(!Number.isSafeInteger(o)||!Number.isSafeInteger(p))throw new RangeError("incorrect timestamp range");let m={kernelId:a[n][this.pendingKernelInfoIndexId],kernelName:s,inputs:a[n][this.pendingKernelInfoIndexInputs],outputs:a[n][this.pendingKernelInfoIndexOutputs],duration:p-o};console.log(`[profiling] ${JSON.stringify(m)}`),mr("GPU",`${s}::${u}::${l}`)}t.buffer.unmap(),this.gpuDataManager.release(t.id)}),qe()}run(t,r,a,n,s){je(t.name);let u=[];for(let C=0;C<r.length;++C){let T=this.gpuDataManager.get(r[C].data);if(!T)throw new Error(`no GPU data for input: ${r[C].data}`);u[C]=T}let l=xp(t,r),o=this.programManager.getArtifact(l),{outputs:p,dispatchGroup:m,programUniforms:w}=t.getRunData(r),g=a.length===0?p.map((C,T)=>T):a;if(g.length!==p.length)throw new Error(`Output size ${g.length} must be equal to ${p.length}.`);let y=[],$=[];for(let C=0;C<p.length;++C){if(!Number.isInteger(g[C])||g[C]<-3||g[C]>=p.length)throw new Error(`Invalid output index: ${g[C]}`);if(g[C]===-3)continue;let T=g[C]===-1,P=g[C]===-2,B=T||P?s(p[C].dataType,p[C].dims):n(g[C],p[C].dataType,p[C].dims),z=this.gpuDataManager.get(B.data);if(!z)throw new Error(`no GPU data for output: ${B.data}`);if(T&&this.temporaryData.push(z),P){let k=this.kernelPersistentData.get(this.currentKernelId);k||(k=[],this.kernelPersistentData.set(this.currentKernelId,k)),k.push(z)}y.push(B),$.push(z)}let v;if(w){let C=0,T=0,P=[],B=1;w.forEach(W=>{let H=typeof W.data=="number"?[W.data]:W.data,X;switch(H.length){case 1:X=4;break;case 2:X=8;break;case 3:X=16;break;case 4:X=16;break;case 5:X=16;break;case 6:X=16;break;default:throw new Error(`unsupported data length: ${H.length}`)}(T===5||T===6)&&(X=16),X>B&&(B=X),C=Math.ceil(C/X)*X,T=H.length,P.push(C),C+=H.length*4}),C=Math.ceil(C/B)*B;let z=new ArrayBuffer(C);w.forEach((W,H)=>{let X=P[H],le=typeof W.data=="number"?[W.data]:W.data;W.type==="int32"?new Int32Array(z,X,le.length).set(le):W.type==="uint32"?new Uint32Array(z,X,le.length).set(le):new Float32Array(z,X,le.length).set(le)});let k=this.gpuDataManager.create(C,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(k.buffer,0,z,0,C),this.gpuDataManager.release(k.id),v={offset:0,size:C,buffer:k.buffer}}let S=this.programManager.normalizeDispatchGroupSize(m);return o||(o=this.programManager.build(t,S),this.programManager.setArtifact(l,o)),_e("info",()=>`[ProgramManager] run "${t.name}" (key=${l}) with ${S[0]}x${S[1]}x${S[2]}`),this.programManager.run(o,r,y,u,$,S,v),qe(t.name),y}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,a,n){let s=Ju.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,n,s[0],[s[1],a]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let a of r)this.gpuDataManager.release(a.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,a){let n=this.kernels.get(t);if(!n)throw new Error(`kernel not created: ${t}`);let[s,u,l,o]=n;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${u}" is not allowed to be called recursively`);this.currentKernelId=t,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),_e("info",()=>`[WebGPU] Start to run kernel "[${s}] ${u}"...`);let p=this.env.debug;this.temporaryData=[];try{return p&&this.device.pushErrorScope("validation"),l(r,o[1]),0}catch(m){return a.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${u}" failed. ${m}`)),1}finally{p&&a.push(this.device.popErrorScope().then(m=>m?`GPU validation error for kernel "[${s}] ${u}": ${m.message}`:null));for(let m of this.temporaryData)this.gpuDataManager.release(m.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,a,n){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let u=s.get(r),l=this.gpuDataManager.registerExternalBuffer(a,n,u?.[1]);return s.set(r,[l,a]),l}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(a=>this.gpuDataManager.unregisterExternalBuffer(a[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,a){return async()=>{let n=await Jn(this,t,r);return Yo(n.buffer,a)}}}});var tl={};Dt(tl,{init:()=>Sp});var Cr,ga,Sp,rl=F(()=>{"use strict";Me();el();Ct();ge();Cr=class e{constructor(t,r,a,n){this.module=t;this.dataType=r;this.data=a;this.dims=n}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=M.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=M.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=M.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(M.size(t)!==M.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},ga=class{constructor(t,r,a){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let n=t.HEAPU32,s=a>>2;this.opKernelContext=n[s++];let u=n[s++];this.outputCount=n[s++],this.customDataOffset=n[s++],this.customDataSize=n[s++];let l=[];for(let o=0;o<u;o++){let p=n[s++],m=n[s++],w=n[s++],g=[];for(let y=0;y<w;y++)g.push(n[s++]);l.push(new Cr(t,p,m,g))}this.inputs=l}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let a=r?.inputs?.map(l=>typeof l=="number"?this.inputs[l]:l)??this.inputs,n=r?.outputs??[],s=(l,o,p)=>new Cr(this.module,o,this.output(l,p),p),u=(l,o)=>{let p=yr(l);if(!p)throw new Error(`Unsupported data type: ${l}`);let m=p*M.size(o);return new Cr(this.module,l,this.backend.gpuDataManager.create(m).id,o)};return this.backend.run(t,a,n,s,u)}output(t,r){let a=this.module.stackSave();try{let n=this.module.stackAlloc((1+r.length)*4),s=n>>2;this.module.HEAPU32[s++]=r.length;for(let u=0;u<r.length;u++)this.module.HEAPU32[s++]=r[u];return this.module._JsepOutput(this.opKernelContext,t,n)}catch(n){throw new Error(`Failed to generate kernel's output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(a)}}},Sp=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let a=new Sn;await a.initialize(t),r(a,n=>a.alloc(n),n=>a.free(n),(n,s,u,l=!1)=>{if(l)_e("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${n}, dst=${s}, size=${u}`),a.memcpy(n,s);else{_e("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${n}, gpuDataId=${s}, size=${u}`);let o=e.HEAPU8.subarray(n,n+u);a.upload(s,o)}},async(n,s,u)=>{_e("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${s}, size=${u}`),await a.download(n,()=>e.HEAPU8.subarray(s,s+u))},(n,s,u)=>a.createKernel(n,s,u,t.debug||t.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(s)):`${s}`),n=>a.releaseKernel(n),(n,s,u,l)=>{_e("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${n}, contextDataOffset=${s}`);let o=new ga(e,a,s);return a.computeKernel(n,o,l)})}}});var al,Cp,Ip,ol,Ir,il,ya,ba,sl,ul,nl,ll,dl,cl,pl=F(()=>{"use strict";Lo();Ho();Me();Kt();Qr();al=!1,Cp=e=>{let t=ke(),r=t.stackSave();try{let a=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,a,a+4)!==0&&Ae("Can't get session input/output count."),[t.HEAP32[a/4],t.HEAP32[a/4+1]]}finally{t.stackRestore(r)}},Ip=(e,t)=>{ke()._OrtInit(e,t)!==0&&Ae("Can't initialize onnxruntime.")},ol=async e=>{Ip(e.wasm.numThreads,br(e.logLevel));{let t=(rl(),St(tl)).init;await t(ke(),e)}al=!0},Ir=new Map,il=()=>al,ya=e=>{let t=ke(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},ba=(e,t)=>{let r=ke(),a=0,n=0,s=0,u=[],l=[],o=[];try{[n,u]=Fo(t),a=r._OrtCreateSession(e[0],e[1],n),a===0&&Ae("Can't create a session.");let[p,m]=Cp(a),w=[],g=[],y=[];for(let v=0;v<p;v++){let S=r._OrtGetInputName(a,v);S===0&&Ae("Can't get an input name."),l.push(S),w.push(r.UTF8ToString(S))}for(let v=0;v<m;v++){let S=r._OrtGetOutputName(a,v);S===0&&Ae("Can't get an output name."),o.push(S);let C=r.UTF8ToString(S);g.push(C);{let T=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[C]??"cpu";if(T!=="cpu"&&T!=="cpu-pinned"&&T!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${T}.`);y.push(T)}}let $=null;return y.some(v=>v==="gpu-buffer")&&(s=r._OrtCreateBinding(a),s===0&&Ae("Can't create IO binding."),$={handle:s,outputPreferredLocations:y,outputPreferredLocationsEncoded:y.map(v=>Yn(v))}),Ir.set(a,[a,l,o,$]),[a,w,g]}catch(p){throw l.forEach(m=>r._OrtFree(m)),o.forEach(m=>r._OrtFree(m)),s!==0&&r._OrtReleaseBinding(s),a!==0&&r._OrtReleaseSession(a),p}finally{r._free(e[0]),n!==0&&r._OrtReleaseSessionOptions(n),u.forEach(p=>r._free(p))}},sl=(e,t)=>{let r=ya(e);return ba(r,t)},ul=e=>{let t=ke(),r=Ir.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[a,n,s,u]=r;u&&t._OrtReleaseBinding(u.handle),t.jsepUnregisterBuffers?.(e),n.forEach(l=>t._OrtFree(l)),s.forEach(l=>t._OrtFree(l)),t._OrtReleaseSession(a),Ir.delete(e)},nl=(e,t,r,a,n)=>{if(!e){t.push(0);return}let s=ke(),u=e[0],l=e[1],o=e[3],p,m;if(u==="string"&&o==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(o==="gpu-buffer"){let y=e[2].gpuBuffer,$=yr(Kn(u));m=l.reduce((v,S)=>v*S,1)*$,p=s.jsepRegisterBuffer(a,n,y,m)}else{let y=e[2];if(Array.isArray(y)){m=4*y.length,p=s._malloc(m),r.push(p);let $=p/4;for(let v=0;v<y.length;v++){if(typeof y[v]!="string")throw new TypeError(`tensor data at index ${v} is not a string`);s.HEAPU32[$++]=De(y[v],r)}}else m=y.byteLength,p=s._malloc(m),r.push(p),s.HEAPU8.set(new Uint8Array(y.buffer,y.byteOffset,m),p)}let w=s.stackSave(),g=s.stackAlloc(4*l.length);try{let y=g/4;l.forEach(v=>s.HEAP32[y++]=v);let $=s._OrtCreateTensor(Kn(u),p,m,g,l.length,Yn(o));$===0&&Ae(`Can't create tensor for input/output. session=${a}, index=${n}.`),t.push($)}finally{s.stackRestore(w)}},ll=async(e,t,r,a,n,s)=>{let u=ke(),l=Ir.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let[o,p,m,w]=l,g=t.length,y=a.length,$=0,v=[],S=[],C=[],T=[],P=u.stackSave(),B=u.stackAlloc(g*4),z=u.stackAlloc(g*4),k=u.stackAlloc(y*4),W=u.stackAlloc(y*4);try{[$,v]=Go(s);for(let ie=0;ie<g;ie++)nl(r[ie],S,T,e,t[ie]);for(let ie=0;ie<y;ie++)nl(n[ie],C,T,e,g+a[ie]);let H=B/4,X=z/4,le=k/4,D=W/4;for(let ie=0;ie<g;ie++)u.HEAPU32[H++]=S[ie],u.HEAPU32[X++]=p[t[ie]];for(let ie=0;ie<y;ie++)u.HEAPU32[le++]=C[ie],u.HEAPU32[D++]=m[a[ie]];if(w){let{handle:ie,outputPreferredLocations:we,outputPreferredLocationsEncoded:j}=w;if(p.length!==g)throw new Error(`input count from feeds (${g}) is expected to be always equal to model's input count (${p.length}).`);for(let Se=0;Se<g;Se++){let Te=t[Se];await u._OrtBindInput(ie,p[Te],S[Se])!==0&&Ae(`Can't bind input[${Se}] for session=${e}.`)}for(let Se=0;Se<y;Se++){let Te=a[Se];n[Se]?.[3]?u._OrtBindOutput(ie,m[Te],C[Se],0)!==0&&Ae(`Can't bind pre-allocated output[${Se}] for session=${e}.`):u._OrtBindOutput(ie,m[Te],0,j[Te])!==0&&Ae(`Can't bind output[${Se}] to ${we[Se]} for session=${e}.`)}}let q;w?q=await u._OrtRunWithBinding(o,w.handle,y,k,$):q=await u._OrtRun(o,z,B,g,W,y,k,$),q!==0&&Ae("failed to call OrtRun().");let xe=[];for(let ie=0;ie<y;ie++){let we=u.HEAPU32[k/4+ie];if(we===C[ie]){xe.push(n[ie]);continue}let j=u.stackSave(),Se=u.stackAlloc(4*4),Te=!1,Ee,Ce=0;try{u._OrtGetTensorData(we,Se,Se+4,Se+8,Se+12)!==0&&Ae(`Can't access output tensor data on index ${ie}.`);let Fe=Se/4,Ye=u.HEAPU32[Fe++];Ce=u.HEAPU32[Fe++];let G=u.HEAPU32[Fe++],de=u.HEAPU32[Fe++],pe=[];for(let Oe=0;Oe<de;Oe++)pe.push(u.HEAPU32[G/4+Oe]);u._OrtFree(G);let Ne=pe.reduce((Oe,ze)=>Oe*ze,1);Ee=gr(Ye);let He=w?.outputPreferredLocations[a[ie]];if(Ee==="string"){if(He==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Oe=[],ze=Ce/4;for(let Ge=0;Ge<Ne;Ge++){let rt=u.HEAPU32[ze++],Xe=Ge===Ne-1?void 0:u.HEAPU32[ze]-rt;Oe.push(u.UTF8ToString(rt,Xe))}xe.push([Ee,pe,Oe,"cpu"])}else if(He==="gpu-buffer"&&Ne>0){let Oe=u.jsepGetBuffer(Ce),ze=yr(Ye);if(ze===void 0||!tn(Ee))throw new Error(`Unsupported data type: ${Ee}`);Te=!0,xe.push([Ee,pe,{gpuBuffer:Oe,download:u.jsepCreateDownloader(Oe,Ne*ze,Ee),dispose:()=>{u._OrtReleaseTensor(we)}},"gpu-buffer"])}else{let Oe=en(Ee),ze=new Oe(Ne);new Uint8Array(ze.buffer,ze.byteOffset,ze.byteLength).set(u.HEAPU8.subarray(Ce,Ce+ze.byteLength)),xe.push([Ee,pe,ze,"cpu"])}}finally{u.stackRestore(j),Ee==="string"&&Ce&&u._free(Ce),Te||u._OrtReleaseTensor(we)}}return w&&u._OrtClearBoundOutputs(w.handle),xe}finally{u.stackRestore(P),S.forEach(H=>u._OrtReleaseTensor(H)),C.forEach(H=>u._OrtReleaseTensor(H)),T.forEach(H=>u._free(H)),$!==0&&u._OrtReleaseRunOptions($),v.forEach(H=>u._free(H))}},dl=e=>{let t=ke(),r=Ir.get(e);if(!r)throw new Error("invalid session id");let a=r[0],n=t._OrtEndProfiling(a);n===0&&Ae("Can't get an profile file name."),t._OrtFree(n)},cl=e=>{let t=[];for(let r of e){let a=r[2];!Array.isArray(a)&&"buffer"in a&&t.push(a.buffer)}return t}});var fl=qt((cb,Ep)=>{Ep.exports='/*!\n * ONNX Runtime Web v1.17.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var cn=Object.defineProperty;var _u=Object.getOwnPropertyDescriptor;var Ru=Object.getOwnPropertyNames;var Pu=Object.prototype.hasOwnProperty;var L=(e,t)=>()=>(e&&(t=e(e=0)),t);var tr=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),_r=(e,t)=>{for(var r in t)cn(e,r,{get:t[r],enumerable:!0})},Bu=(e,t,r,a)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Ru(t))!Pu.call(e,n)&&n!==r&&cn(e,n,{get:()=>t[n],enumerable:!(a=_u(t,n))||a.enumerable});return e};var Dt=e=>Bu(cn({},"__esModule",{value:!0}),e);var pn={};_r(pn,{readFile:()=>Mu});var Mu,fn=L(()=>{Mu=void 0});var mn={};_r(mn,{join:()=>ku});var ku,hn=L(()=>{ku=void 0});var go=tr((ho,gn)=>{"use strict";var mo=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,a,n;r.ready=new Promise((l,p)=>{a=l,n=p}),r.jsepInit=(l,p,h,C,I,U,N,oe)=>{r.Za=l,r.Oa=p,r.Qa=h,r.Ja=C,r.Pa=I,r.ra=U,r.Ra=N,r.Sa=oe,p=(q,Q,J)=>(...ce)=>{let me=He,E=Q?.();ce=q(...ce);let te=Q?.();return E!==te&&(q=te,J(E),Q=J=null),He!=me?vr():ce},h=q=>async(...Q)=>{try{if(r.Da)throw Error("Session already started");let J=r.Da={Ta:Q[0],errors:[]},ce=await q(...Q);if(r.Da!==J)throw Error("Session mismatch");l.flush();let me=J.errors;if(0<me.length){let E=await Promise.all(me);if(E=E.filter(te=>te),0<E.length)throw Error(E.join(`\n`))}return ce}finally{r.Da=null}},r._OrtRun=h(p(r._OrtRun,()=>r._OrtRun,q=>r._OrtRun=q)),r._OrtRunWithBinding=h(p(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,q=>r._OrtRunWithBinding=q)),r._OrtBindInput=p(r._OrtBindInput,()=>r._OrtBindInput,q=>r._OrtBindInput=q),r.jsepRegisterBuffer=(q,Q,J,ce)=>l.registerBuffer(q,Q,J,ce),r.jsepUnregisterBuffers=q=>{l.unregisterBuffers(q)},r.jsepGetBuffer=q=>l.getBuffer(q),r.jsepCreateDownloader=(q,Q,J)=>l.createDownloader(q,Q,J)};var s=Object.assign({},r),u="./this.program",d=(l,p)=>{throw p},o=typeof window=="object",m=typeof importScripts=="function",g=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x="",b,y,$;if(g){var w=(fn(),Dt(pn)),S=(hn(),Dt(mn));x=m?S.dirname(x)+"/":__dirname+"/",b=(l,p)=>(l=l.startsWith("file://")?new URL(l):S.normalize(l),w.readFileSync(l,p?void 0:"utf8")),$=l=>(l=b(l,!0),l.buffer||(l=new Uint8Array(l)),l),y=(l,p,h,C=!0)=>{l=l.startsWith("file://")?new URL(l):S.normalize(l),w.readFile(l,C?void 0:"utf8",(I,U)=>{I?h(I):p(C?U.buffer:U)})},!r.thisProgram&&1<process.argv.length&&(u=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),d=(l,p)=>{throw process.exitCode=l,p},r.inspect=()=>"[Emscripten Module object]"}else(o||m)&&(m?x=self.location.href:typeof document<"u"&&document.currentScript&&(x=document.currentScript.src),e&&(x=e),x.indexOf("blob:")!==0?x=x.substr(0,x.replace(/[?#].*/,"").lastIndexOf("/")+1):x="",b=l=>{var p=new XMLHttpRequest;return p.open("GET",l,!1),p.send(null),p.responseText},m&&($=l=>{var p=new XMLHttpRequest;return p.open("GET",l,!1),p.responseType="arraybuffer",p.send(null),new Uint8Array(p.response)}),y=(l,p,h)=>{var C=new XMLHttpRequest;C.open("GET",l,!0),C.responseType="arraybuffer",C.onload=()=>{C.status==200||C.status==0&&C.response?p(C.response):h()},C.onerror=h,C.send(null)});var A=r.print||console.log.bind(console),_=r.printErr||console.error.bind(console);Object.assign(r,s),s=null,r.thisProgram&&(u=r.thisProgram),r.quit&&(d=r.quit);var z;r.wasmBinary&&(z=r.wasmBinary);var D=r.noExitRuntime||!0;typeof WebAssembly!="object"&&Fe("no native wasm support detected");var W,P,k=!1,H,X,le,B,K,xe,ie;function we(){var l=W.buffer;r.HEAP8=X=new Int8Array(l),r.HEAP16=new Int16Array(l),r.HEAP32=B=new Int32Array(l),r.HEAPU8=le=new Uint8Array(l),r.HEAPU16=new Uint16Array(l),r.HEAPU32=K=new Uint32Array(l),r.HEAPF32=xe=new Float32Array(l),r.HEAPF64=ie=new Float64Array(l)}var j=[],Se=[],Oe=[];function Ie(){var l=r.preRun.shift();j.unshift(l)}var Ce=0,dt=null,Ue=null;function Fe(l){throw r.onAbort&&r.onAbort(l),l="Aborted("+l+")",_(l),k=!0,H=1,l=new WebAssembly.RuntimeError(l+". Build with -sASSERTIONS for more info."),n(l),l}function G(l){return l.startsWith("data:application/octet-stream;base64,")}var de;if(de="ort-wasm-simd.wasm",!G(de)){var pe=de;de=r.locateFile?r.locateFile(pe,x):x+pe}function ze(l){if(l==de&&z)return new Uint8Array(z);if($)return $(l);throw"both async and sync fetching of the wasm failed"}function Ge(l){if(!z&&(o||m)){if(typeof fetch=="function"&&!l.startsWith("file://"))return fetch(l,{credentials:"same-origin"}).then(p=>{if(!p.ok)throw"failed to load wasm binary file at \'"+l+"\'";return p.arrayBuffer()}).catch(()=>ze(l));if(y)return new Promise((p,h)=>{y(l,C=>p(new Uint8Array(C)),h)})}return Promise.resolve().then(()=>ze(l))}function Ee(l,p,h){return Ge(l).then(C=>WebAssembly.instantiate(C,p)).then(C=>C).then(h,C=>{_("failed to asynchronously prepare wasm: "+C),Fe(C)})}function ke(l,p){var h=de;return z||typeof WebAssembly.instantiateStreaming!="function"||G(h)||h.startsWith("file://")||g||typeof fetch!="function"?Ee(h,l,p):fetch(h,{credentials:"same-origin"}).then(C=>WebAssembly.instantiateStreaming(C,l).then(p,function(I){return _("wasm streaming compile failed: "+I),_("falling back to ArrayBuffer instantiation"),Ee(h,l,p)}))}var Ve,Xe={913120:l=>{r.ra("Abs",l,void 0)},913171:l=>{r.ra("Neg",l,void 0)},913222:l=>{r.ra("Floor",l,void 0)},913275:l=>{r.ra("Ceil",l,void 0)},913327:l=>{r.ra("Reciprocal",l,void 0)},913385:l=>{r.ra("Sqrt",l,void 0)},913437:l=>{r.ra("Exp",l,void 0)},913488:l=>{r.ra("Erf",l,void 0)},913539:l=>{r.ra("Sigmoid",l,void 0)},913594:l=>{r.ra("Log",l,void 0)},913645:l=>{r.ra("Sin",l,void 0)},913696:l=>{r.ra("Cos",l,void 0)},913747:l=>{r.ra("Tan",l,void 0)},913798:l=>{r.ra("Asin",l,void 0)},913850:l=>{r.ra("Acos",l,void 0)},913902:l=>{r.ra("Atan",l,void 0)},913954:l=>{r.ra("Sinh",l,void 0)},914006:l=>{r.ra("Cosh",l,void 0)},914058:l=>{r.ra("Asinh",l,void 0)},914111:l=>{r.ra("Acosh",l,void 0)},914164:l=>{r.ra("Atanh",l,void 0)},914217:l=>{r.ra("Tanh",l,void 0)},914269:l=>{r.ra("Not",l,void 0)},914320:(l,p,h)=>{r.ra("Clip",l,{min:p,max:h})},914389:l=>{r.ra("Clip",l,void 0)},914441:(l,p)=>{r.ra("Elu",l,{alpha:p})},914499:l=>{r.ra("Relu",l,void 0)},914551:(l,p)=>{r.ra("LeakyRelu",l,{alpha:p})},914615:(l,p)=>{r.ra("ThresholdedRelu",l,{alpha:p})},914685:(l,p)=>{r.ra("Cast",l,{to:p})},914743:l=>{r.ra("Add",l,void 0)},914794:l=>{r.ra("Sub",l,void 0)},914845:l=>{r.ra("Mul",l,void 0)},914896:l=>{r.ra("Div",l,void 0)},914947:l=>{r.ra("Pow",l,void 0)},914998:l=>{r.ra("Equal",l,void 0)},915051:l=>{r.ra("Greater",l,void 0)},915106:l=>{r.ra("GreaterOrEqual",l,void 0)},915168:l=>{r.ra("Less",l,void 0)},915220:l=>{r.ra("LessOrEqual",l,void 0)},915279:(l,p,h,C,I)=>{r.ra("ReduceMean",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(I>>>0,I+C>>>0)):[]})},915443:(l,p,h,C,I)=>{r.ra("ReduceMax",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(I>>>0,I+C>>>0)):[]})},915606:(l,p,h,C,I)=>{r.ra("ReduceMin",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(I>>>0,I+C>>>0)):[]})},915769:(l,p,h,C,I)=>{r.ra("ReduceProd",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(I>>>0,I+C>>>0)):[]})},915933:(l,p,h,C,I)=>{r.ra("ReduceSum",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(I>>>0,I+C>>>0)):[]})},916096:(l,p,h,C,I)=>{r.ra("ReduceL1",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(I>>>0,I+C>>>0)):[]})},916258:(l,p,h,C,I)=>{r.ra("ReduceL2",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(I>>>0,I+C>>>0)):[]})},916420:(l,p,h,C,I)=>{r.ra("ReduceLogSum",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(I>>>0,I+C>>>0)):[]})},916586:(l,p,h,C,I)=>{r.ra("ReduceSumSquare",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(I>>>0,I+C>>>0)):[]})},916755:(l,p,h,C,I)=>{r.ra("ReduceLogSumExp",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(I>>>0,I+C>>>0)):[]})},916924:l=>{r.ra("Where",l,void 0)},916977:(l,p,h)=>{r.ra("Transpose",l,{perm:p?Array.from(B.subarray(h>>>0,h+p>>>0)):[]})},917090:(l,p,h,C,I,U,N,oe,q,Q,J,ce,me,E,te)=>{r.ra("ConvTranspose",l,{format:q?"NHWC":"NCHW",autoPad:p,dilations:[h],group:C,kernel_shape:[I],pads:[U,N],strides:[oe],wIsConst:()=>!!X[Q>>>0],outputPadding:J?Array.from(B.subarray(ce>>>0,ce+J>>>0)):[],outputShape:me?Array.from(B.subarray(E>>>0,E+me>>>0)):[],activation:_e(te)})},917504:(l,p,h,C,I,U,N,oe,q,Q,J,ce,me,E)=>{r.ra("ConvTranspose",l,{format:oe?"NHWC":"NCHW",autoPad:p,dilations:Array.from(B.subarray(h>>>0,h+2>>>0)),group:C,kernelShape:Array.from(B.subarray(I>>>0,I+2>>>0)),pads:Array.from(B.subarray(U>>>0,U+4>>>0)),strides:Array.from(B.subarray(N>>>0,N+2>>>0)),wIsConst:()=>!!X[q>>>0],outputPadding:0<Q?Array.from(B.subarray(J>>>0,J+Q>>>0)):[],outputShape:0<ce?Array.from(B.subarray(me>>>0,me+ce>>>0)):[],activation:_e(E)})},918061:(l,p,h,C,I,U,N,oe,q,Q,J,ce,me,E,te)=>{r.ra("ConvTranspose",l,{format:q?"NHWC":"NCHW",autoPad:p,dilations:[h],group:C,kernel_shape:[I],pads:[U,N],strides:[oe],wIsConst:()=>!!X[Q>>>0],outputPadding:J?Array.from(B.subarray(ce>>>0,ce+J>>>0)):[],outputShape:me?Array.from(B.subarray(E>>>0,E+me>>>0)):[],activation:_e(te)})},918475:(l,p,h,C,I,U,N,oe,q,Q,J,ce,me,E)=>{r.ra("ConvTranspose",l,{format:oe?"NHWC":"NCHW",autoPad:p,dilations:Array.from(B.subarray(h>>>0,h+2>>>0)),group:C,kernelShape:Array.from(B.subarray(I>>>0,I+2>>>0)),pads:Array.from(B.subarray(U>>>0,U+4>>>0)),strides:Array.from(B.subarray(N>>>0,N+2>>>0)),wIsConst:()=>!!X[q>>>0],outputPadding:0<Q?Array.from(B.subarray(J>>>0,J+Q>>>0)):[],outputShape:0<ce?Array.from(B.subarray(me>>>0,me+ce>>>0)):[],activation:_e(E)})},919032:(l,p)=>{r.ra("GlobalAveragePool",l,{format:p?"NHWC":"NCHW"})},919123:(l,p,h,C,I,U,N,oe,q,Q,J,ce,me,E,te,fe)=>{r.ra("AveragePool",l,{format:fe?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:C,storage_order:I,dilations:[U,N],kernel_shape:[oe,q],pads:[Q,J,ce,me],strides:[E,te]})},919407:(l,p)=>{r.ra("GlobalAveragePool",l,{format:p?"NHWC":"NCHW"})},919498:(l,p,h,C,I,U,N,oe,q,Q,J,ce,me,E,te,fe)=>{r.ra("AveragePool",l,{format:fe?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:C,storage_order:I,dilations:[U,N],kernel_shape:[oe,q],pads:[Q,J,ce,me],strides:[E,te]})},919782:(l,p)=>{r.ra("GlobalMaxPool",l,{format:p?"NHWC":"NCHW"})},919869:(l,p,h,C,I,U,N,oe,q,Q,J,ce,me,E,te,fe)=>{r.ra("MaxPool",l,{format:fe?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:C,storage_order:I,dilations:[U,N],kernel_shape:[oe,q],pads:[Q,J,ce,me],strides:[E,te]})},920149:(l,p)=>{r.ra("GlobalMaxPool",l,{format:p?"NHWC":"NCHW"})},920236:(l,p,h,C,I,U,N,oe,q,Q,J,ce,me,E,te,fe)=>{r.ra("MaxPool",l,{format:fe?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:C,storage_order:I,dilations:[U,N],kernel_shape:[oe,q],pads:[Q,J,ce,me],strides:[E,te]})},920516:(l,p,h,C,I)=>{r.ra("Gemm",l,{alpha:p,beta:h,transA:C,transB:I})},920620:l=>{r.ra("MatMul",l,void 0)},920674:(l,p,h,C)=>{r.ra("ArgMax",l,{keepDims:!!p,selectLastIndex:!!h,axis:C})},920782:(l,p,h,C)=>{r.ra("ArgMin",l,{keepDims:!!p,selectLastIndex:!!h,axis:C})},920890:(l,p)=>{r.ra("Softmax",l,{axis:p})},920953:(l,p)=>{r.ra("Concat",l,{axis:p})},921013:(l,p,h,C,I)=>{r.ra("Split",l,{axis:p,numOutputs:h,splitSizes:C?Array.from(B.subarray(I>>>0,I+C>>>0)):[]})},921158:l=>{r.ra("Expand",l,void 0)},921212:(l,p)=>{r.ra("Gather",l,{axis:Number(p)})},921283:(l,p)=>{r.ra("GatherElements",l,{axis:Number(p)})},921362:(l,p,h,C,I,U,N,oe,q,Q,J)=>{r.ra("Resize",l,{antialias:p,axes:h?Array.from(B.subarray(C>>>0,C+h>>>0)):[],coordinateTransformMode:_e(I),cubicCoeffA:U,excludeOutside:N,extrapolationValue:oe,keepAspectRatioPolicy:_e(q),mode:_e(Q),nearestMode:_e(J)})},921713:(l,p,h,C,I,U,N)=>{r.ra("Slice",l,{starts:p?Array.from(B.subarray(h>>>0,h+p>>>0)):[],ends:C?Array.from(B.subarray(I>>>0,I+C>>>0)):[],axes:U?Array.from(B.subarray(N>>>0,N+U>>>0)):[]})},921944:l=>{r.ra("Tile",l,void 0)},921996:(l,p,h)=>{r.ra("LayerNormalization",l,{axis:Number(p),epsilon:Number(h)})},922103:(l,p,h)=>{r.ra("InstanceNormalization",l,{epsilon:p,format:h?"NHWC":"NCHW"})},922217:(l,p,h)=>{r.ra("InstanceNormalization",l,{epsilon:p,format:h?"NHWC":"NCHW"})},922331:l=>{r.ra("Range",l,void 0)},922384:(l,p)=>{r.ra("Einsum",l,{equation:_e(p)})},922465:(l,p,h,C,I)=>{r.ra("Pad",l,{mode:p,value:h,pads:C?Array.from(B.subarray(I>>>0,I+C>>>0)):[]})},922597:(l,p,h,C,I,U)=>{r.ra("BatchNormalization",l,{epsilon:p,momentum:h,spatial:!!I,trainingMode:!!C,format:U?"NHWC":"NCHW"})},922766:(l,p,h,C,I,U)=>{r.ra("BatchNormalization",l,{epsilon:p,momentum:h,spatial:!!I,trainingMode:!!C,format:U?"NHWC":"NCHW"})},922935:(l,p,h)=>{r.ra("CumSum",l,{exclusive:Number(p),reverse:Number(h)})},923032:(l,p,h,C,I,U,N,oe,q)=>{r.ra("Attention",l,{numHeads:p,isUnidirectional:h,maskFilterValue:C,scale:I,doRotary:U,qkvHiddenSizes:N?Array.from(B.subarray(Number(oe)>>>0,Number(oe)+N>>>0)):[],pastPresentShareBuffer:!!q})},923304:l=>{r.ra("Gelu",l,void 0)},923356:(l,p,h,C,I,U)=>{r.ra("MultiHeadAttention",l,{numHeads:p,isUnidirectional:h,maskFilterValue:C,scale:I,doRotary:U})},923515:l=>{r.ra("BiasAdd",l,void 0)},923570:l=>{r.ra("BiasSplitGelu",l,void 0)},923631:(l,p)=>{r.ra("SkipLayerNormalization",l,{epsilon:p})},923712:(l,p,h,C,I,U,N,oe,q,Q,J,ce,me)=>{r.ra("Conv",l,{format:q?"NHWC":"NCHW",auto_pad:p,dilations:[h],group:C,kernel_shape:[I],pads:U?Array.from(B.subarray(N>>>0,N+U>>>0)):[],strides:[oe],w_is_const:()=>!!X[Q>>>0],activation:_e(J),activation_params:ce?Array.from(xe.subarray(me>>>0,me+ce>>>0)):[]})},924093:(l,p,h,C,I,U,N,oe,q,Q,J,ce,me,E,te,fe)=>{r.ra("Conv",l,{format:ce?"NHWC":"NCHW",auto_pad:p,dilations:[h,C],group:I,kernel_shape:[U,N],pads:oe?Array.from(B.subarray(q>>>0,q+oe>>>0)):[],strides:[Q,J],w_is_const:()=>!!X[me>>>0],activation:_e(E),activation_params:te?Array.from(xe.subarray(fe>>>0,fe+te>>>0)):[]})},924495:l=>{r.Ra(l)},924529:(l,p)=>r.Sa(l,p,r.Da.Ta,r.Da.errors),924641:l=>r.Oa(l),924674:l=>r.Qa(l),924706:(l,p,h)=>{r.Ja(l,p,h,!0)},924745:(l,p,h)=>{r.Ja(l,p,h)}};function Le(l){this.name="ExitStatus",this.message=`Program terminated with exit(${l})`,this.status=l}var yt=l=>{for(;0<l.length;)l.shift()(r)};function bt(l){this.Ha=l-24,this.Ma=function(p){K[this.Ha+4>>2>>>0]=p},this.La=function(p){K[this.Ha+8>>2>>>0]=p},this.Ya=function(p,h){this.Ka(),this.Ma(p),this.La(h)},this.Ka=function(){K[this.Ha+16>>2>>>0]=0}}var zt=0,fr=0,Ke=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Nt=(l,p,h)=>{p>>>=0;var C=p+h;for(h=p;l[h]&&!(h>=C);)++h;if(16<h-p&&l.buffer&&Ke)return Ke.decode(l.subarray(p,h));for(C="";p<h;){var I=l[p++];if(I&128){var U=l[p++]&63;if((I&224)==192)C+=String.fromCharCode((I&31)<<6|U);else{var N=l[p++]&63;I=(I&240)==224?(I&15)<<12|U<<6|N:(I&7)<<18|U<<12|N<<6|l[p++]&63,65536>I?C+=String.fromCharCode(I):(I-=65536,C+=String.fromCharCode(55296|I>>10,56320|I&1023))}}else C+=String.fromCharCode(I)}return C},_e=(l,p)=>(l>>>=0)?Nt(le,l,p):"",Ot=l=>{for(var p=0,h=0;h<l.length;++h){var C=l.charCodeAt(h);127>=C?p++:2047>=C?p+=2:55296<=C&&57343>=C?(p+=4,++h):p+=3}return p},Vt=(l,p,h,C)=>{if(h>>>=0,!(0<C))return 0;var I=h;C=h+C-1;for(var U=0;U<l.length;++U){var N=l.charCodeAt(U);if(55296<=N&&57343>=N){var oe=l.charCodeAt(++U);N=65536+((N&1023)<<10)|oe&1023}if(127>=N){if(h>=C)break;p[h++>>>0]=N}else{if(2047>=N){if(h+1>=C)break;p[h++>>>0]=192|N>>6}else{if(65535>=N){if(h+2>=C)break;p[h++>>>0]=224|N>>12}else{if(h+3>=C)break;p[h++>>>0]=240|N>>18,p[h++>>>0]=128|N>>12&63}p[h++>>>0]=128|N>>6&63}p[h++>>>0]=128|N&63}}return p[h>>>0]=0,h-I},at=l=>l%4===0&&(l%100!==0||l%400===0),mr=[0,31,60,91,121,152,182,213,244,274,305,335],it=[0,31,59,90,120,151,181,212,243,273,304,334],_t=l=>{var p=Ot(l)+1,h=Mt(p);return h&&Vt(l,le,h,p),h},ct=[],Rt=(l,p)=>{ct.length=0;var h;for(p>>=2;h=le[l++>>>0];)p+=h!=105&p,ct.push(h==105?B[p>>>0]:ie[p++>>>1]),++p;return ct},Pt={},Ut=()=>{if(!Bt){var l={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:u||"./this.program"},p;for(p in Pt)Pt[p]===void 0?delete l[p]:l[p]=Pt[p];var h=[];for(p in l)h.push(`${p}=${l[p]}`);Bt=h}return Bt},Bt,hr=[null,[],[]],Ne=[31,29,31,30,31,30,31,31,30,31,30,31],Gt=[31,28,31,30,31,30,31,31,30,31,30,31];function Ft(l){var p=Array(Ot(l)+1);return Vt(l,p,0,p.length),p}function ne(l,p,h,C){function I(E,te,fe){for(E=typeof E=="number"?E.toString():E||"";E.length<te;)E=fe[0]+E;return E}function U(E,te){return I(E,te,"0")}function N(E,te){function fe(er){return 0>er?-1:0<er?1:0}var ut;return(ut=fe(E.getFullYear()-te.getFullYear()))===0&&(ut=fe(E.getMonth()-te.getMonth()))===0&&(ut=fe(E.getDate()-te.getDate())),ut}function oe(E){switch(E.getDay()){case 0:return new Date(E.getFullYear()-1,11,29);case 1:return E;case 2:return new Date(E.getFullYear(),0,3);case 3:return new Date(E.getFullYear(),0,2);case 4:return new Date(E.getFullYear(),0,1);case 5:return new Date(E.getFullYear()-1,11,31);case 6:return new Date(E.getFullYear()-1,11,30)}}function q(E){var te=E.Ba;for(E=new Date(new Date(E.Ca+1900,0,1).getTime());0<te;){var fe=E.getMonth(),ut=(at(E.getFullYear())?Ne:Gt)[fe];if(te>ut-E.getDate())te-=ut-E.getDate()+1,E.setDate(1),11>fe?E.setMonth(fe+1):(E.setMonth(0),E.setFullYear(E.getFullYear()+1));else{E.setDate(E.getDate()+te);break}}return fe=new Date(E.getFullYear()+1,0,4),te=oe(new Date(E.getFullYear(),0,4)),fe=oe(fe),0>=N(te,E)?0>=N(fe,E)?E.getFullYear()+1:E.getFullYear():E.getFullYear()-1}l>>>=0,p>>>=0,h>>>=0,C>>>=0;var Q=B[C+40>>2>>>0];C={Wa:B[C>>2>>>0],Va:B[C+4>>2>>>0],Ea:B[C+8>>2>>>0],Ia:B[C+12>>2>>>0],Fa:B[C+16>>2>>>0],Ca:B[C+20>>2>>>0],wa:B[C+24>>2>>>0],Ba:B[C+28>>2>>>0],$a:B[C+32>>2>>>0],Ua:B[C+36>>2>>>0],Xa:Q?_e(Q):""},h=_e(h),Q={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var J in Q)h=h.replace(new RegExp(J,"g"),Q[J]);var ce="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),me="January February March April May June July August September October November December".split(" ");Q={"%a":E=>ce[E.wa].substring(0,3),"%A":E=>ce[E.wa],"%b":E=>me[E.Fa].substring(0,3),"%B":E=>me[E.Fa],"%C":E=>U((E.Ca+1900)/100|0,2),"%d":E=>U(E.Ia,2),"%e":E=>I(E.Ia,2," "),"%g":E=>q(E).toString().substring(2),"%G":E=>q(E),"%H":E=>U(E.Ea,2),"%I":E=>(E=E.Ea,E==0?E=12:12<E&&(E-=12),U(E,2)),"%j":E=>{for(var te=0,fe=0;fe<=E.Fa-1;te+=(at(E.Ca+1900)?Ne:Gt)[fe++]);return U(E.Ia+te,3)},"%m":E=>U(E.Fa+1,2),"%M":E=>U(E.Va,2),"%n":()=>`\n`,"%p":E=>0<=E.Ea&&12>E.Ea?"AM":"PM","%S":E=>U(E.Wa,2),"%t":()=>"	","%u":E=>E.wa||7,"%U":E=>U(Math.floor((E.Ba+7-E.wa)/7),2),"%V":E=>{var te=Math.floor((E.Ba+7-(E.wa+6)%7)/7);if(2>=(E.wa+371-E.Ba-2)%7&&te++,te)te==53&&(fe=(E.wa+371-E.Ba)%7,fe==4||fe==3&&at(E.Ca)||(te=1));else{te=52;var fe=(E.wa+7-E.Ba-1)%7;(fe==4||fe==5&&at(E.Ca%400-1))&&te++}return U(te,2)},"%w":E=>E.wa,"%W":E=>U(Math.floor((E.Ba+7-(E.wa+6)%7)/7),2),"%y":E=>(E.Ca+1900).toString().substring(2),"%Y":E=>E.Ca+1900,"%z":E=>{E=E.Ua;var te=0<=E;return E=Math.abs(E)/60,(te?"+":"-")+("0000"+(E/60*100+E%60)).slice(-4)},"%Z":E=>E.Xa,"%%":()=>"%"},h=h.replace(/%%/g,"\\0\\0");for(J in Q)h.includes(J)&&(h=h.replace(new RegExp(J,"g"),Q[J](C)));return h=h.replace(/\\0\\0/g,"%"),J=Ft(h),J.length>p?0:(X.set(J,l>>>0),J.length-1)}function st(l){try{l()}catch(p){Fe(p)}}function gr(l){var p={},h;for(h in l)(function(C){var I=l[C];p[C]=typeof I=="function"?function(){wt.push(C);try{return I.apply(null,arguments)}finally{k||(wt.pop()===C||Fe(),He&&Je===1&&wt.length===0&&(Je=0,st(Zt),typeof Fibers<"u"&&Fibers.ab()))}}:I})(h);return p}var Je=0,He=null,yr=0,wt=[],Lt={},Ht={},br=0,vt=null,wr=[];function vr(){return new Promise((l,p)=>{vt={resolve:l,reject:p}})}function $r(){var l=Mt(65548),p=l+12;K[l>>2>>>0]=p,K[l+4>>2>>>0]=p+65536,p=wt[0];var h=Lt[p];return h===void 0&&(h=br++,Lt[p]=h,Ht[h]=p),B[l+8>>2>>>0]=h,l}function xr(l){if(!k){if(Je===0){var p=!1,h=!1;l((C=0)=>{if(!k&&(yr=C,p=!0,h)){Je=2,st(()=>kt(He)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),C=!1;try{var I=(0,P[Ht[B[He+8>>2>>>0]]])()}catch(oe){I=oe,C=!0}var U=!1;if(!He){var N=vt;N&&(vt=null,(C?N.reject:N.resolve)(I),U=!0)}if(C&&!U)throw I}}),h=!0,p||(Je=1,He=$r(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),st(()=>Jt(He)))}else Je===2?(Je=0,st($t),jt(He),He=null,wr.forEach(C=>{if(!k)try{if(C(),!D)try{H=H=C=H,D||(r.onExit&&r.onExit(C),k=!0),d(C,new Le(C))}catch(I){I instanceof Le||I=="unwind"||d(1,I)}}catch(I){I instanceof Le||I=="unwind"||d(1,I)}})):Fe(`invalid state: ${Je}`);return yr}}function Sr(l){return xr(p=>{l().then(p)})}var Cr={n:function(l,p,h){return Sr(async()=>{await r.Pa(l,p,h)})},a:function(l,p,h){throw l>>>=0,new bt(l).Ya(p>>>0,h>>>0),zt=l,fr++,zt},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(l,p,h){l=p+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*p:NaN,h>>>=0,l=new Date(1e3*l),B[h>>2>>>0]=l.getUTCSeconds(),B[h+4>>2>>>0]=l.getUTCMinutes(),B[h+8>>2>>>0]=l.getUTCHours(),B[h+12>>2>>>0]=l.getUTCDate(),B[h+16>>2>>>0]=l.getUTCMonth(),B[h+20>>2>>>0]=l.getUTCFullYear()-1900,B[h+24>>2>>>0]=l.getUTCDay(),B[h+28>>2>>>0]=(l.getTime()-Date.UTC(l.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(l,p,h){l=p+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*p:NaN,h>>>=0,l=new Date(1e3*l),B[h>>2>>>0]=l.getSeconds(),B[h+4>>2>>>0]=l.getMinutes(),B[h+8>>2>>>0]=l.getHours(),B[h+12>>2>>>0]=l.getDate(),B[h+16>>2>>>0]=l.getMonth(),B[h+20>>2>>>0]=l.getFullYear()-1900,B[h+24>>2>>>0]=l.getDay(),B[h+28>>2>>>0]=(at(l.getFullYear())?mr:it)[l.getMonth()]+l.getDate()-1|0,B[h+36>>2>>>0]=-(60*l.getTimezoneOffset()),p=new Date(l.getFullYear(),6,1).getTimezoneOffset();var C=new Date(l.getFullYear(),0,1).getTimezoneOffset();B[h+32>>2>>>0]=(p!=C&&l.getTimezoneOffset()==Math.min(C,p))|0},s:function(l){l>>>=0;var p=new Date(B[l+20>>2>>>0]+1900,B[l+16>>2>>>0],B[l+12>>2>>>0],B[l+8>>2>>>0],B[l+4>>2>>>0],B[l>>2>>>0],0),h=B[l+32>>2>>>0],C=p.getTimezoneOffset(),I=new Date(p.getFullYear(),6,1).getTimezoneOffset(),U=new Date(p.getFullYear(),0,1).getTimezoneOffset(),N=Math.min(U,I);return 0>h?B[l+32>>2>>>0]=+(I!=U&&N==C):0<h!=(N==C)&&(I=Math.max(U,I),p.setTime(p.getTime()+6e4*((0<h?N:I)-C))),B[l+24>>2>>>0]=p.getDay(),B[l+28>>2>>>0]=(at(p.getFullYear())?mr:it)[p.getMonth()]+p.getDate()-1|0,B[l>>2>>>0]=p.getSeconds(),B[l+4>>2>>>0]=p.getMinutes(),B[l+8>>2>>>0]=p.getHours(),B[l+12>>2>>>0]=p.getDate(),B[l+16>>2>>>0]=p.getMonth(),B[l+20>>2>>>0]=p.getYear(),l=p.getTime()/1e3,Kt((Ve=l,1<=+Math.abs(Ve)?0<Ve?+Math.floor(Ve/4294967296)>>>0:~~+Math.ceil((Ve-+(~~Ve>>>0))/4294967296)>>>0:0)),l>>>0},o:function(){return-52},p:function(){},v:function(l,p,h){function C(q){return(q=q.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?q[1]:"GMT"}h>>>=0;var I=new Date().getFullYear(),U=new Date(I,0,1),N=new Date(I,6,1);I=U.getTimezoneOffset();var oe=N.getTimezoneOffset();K[l>>>0>>2>>>0]=60*Math.max(I,oe),B[p>>>0>>2>>>0]=+(I!=oe),l=C(U),p=C(N),l=_t(l),p=_t(p),oe<I?(K[h>>2>>>0]=l,K[h+4>>2>>>0]=p):(K[h>>2>>>0]=p,K[h+4>>2>>>0]=l)},e:()=>{Fe("")},b:function(l,p,h){return l>>>=0,p=Rt(p>>>0,h>>>0),Xe[l].apply(null,p)},i:function(l,p,h){return l>>>=0,p=Rt(p>>>0,h>>>0),Xe[l].apply(null,p)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(l,p,h){return p>>>=0,le.copyWithin(l>>>0>>>0,p>>>0,p+(h>>>0)>>>0)},u:function(l){l>>>=0;var p=le.length;if(4294901760<l)return!1;for(var h=1;4>=h;h*=2){var C=p*(1+.2/h);C=Math.min(C,l+100663296);var I=Math;C=Math.max(l,C);e:{I=I.min.call(I,4294901760,C+(65536-C%65536)%65536)-W.buffer.byteLength+65535>>>16;try{W.grow(I),we();var U=1;break e}catch{}U=void 0}if(U)return!0}return!1},D:function(l,p){l>>>=0,p>>>=0;var h=0;return Ut().forEach(function(C,I){var U=p+h;for(I=K[l+4*I>>2>>>0]=U,U=0;U<C.length;++U)X[I++>>0>>>0]=C.charCodeAt(U);X[I>>0>>>0]=0,h+=C.length+1}),0},E:function(l,p){l>>>=0,p>>>=0;var h=Ut();K[l>>2>>>0]=h.length;var C=0;return h.forEach(function(I){C+=I.length+1}),K[p>>2>>>0]=C,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(l,p,h,C){p>>>=0,h>>>=0,C>>>=0;for(var I=0,U=0;U<h;U++){var N=K[p>>2>>>0],oe=K[p+4>>2>>>0];p+=8;for(var q=0;q<oe;q++){var Q=le[N+q>>>0],J=hr[l];Q===0||Q===10?((l===1?A:_)(Nt(J,0)),J.length=0):J.push(Q)}I+=oe}return K[C>>2>>>0]=I,0},F:ne,d:function(l,p,h,C){return ne(l>>>0,p>>>0,h>>>0,C>>>0)}};(function(){function l(h){if(h=h.exports,h=gr(h),P=h=pt(h),W=P.M,we(),Se.unshift(P.N),Ce--,r.monitorRunDependencies&&r.monitorRunDependencies(Ce),Ce==0&&(dt!==null&&(clearInterval(dt),dt=null),Ue)){var C=Ue;Ue=null,C()}return h}var p={a:Cr};if(Ce++,r.monitorRunDependencies&&r.monitorRunDependencies(Ce),r.instantiateWasm)try{return r.instantiateWasm(p,l)}catch(h){_("Module.instantiateWasm callback failed with error: "+h),n(h)}return ke(p,function(h){l(h.instance)}).catch(n),{}})(),r._OrtInit=(l,p)=>(r._OrtInit=P.O)(l,p),r._OrtGetLastError=(l,p)=>(r._OrtGetLastError=P.P)(l,p),r._OrtCreateSessionOptions=(l,p,h,C,I,U,N,oe,q,Q)=>(r._OrtCreateSessionOptions=P.Q)(l,p,h,C,I,U,N,oe,q,Q),r._OrtAppendExecutionProvider=(l,p)=>(r._OrtAppendExecutionProvider=P.R)(l,p),r._OrtAddFreeDimensionOverride=(l,p,h)=>(r._OrtAddFreeDimensionOverride=P.S)(l,p,h),r._OrtAddSessionConfigEntry=(l,p,h)=>(r._OrtAddSessionConfigEntry=P.T)(l,p,h),r._OrtReleaseSessionOptions=l=>(r._OrtReleaseSessionOptions=P.U)(l),r._OrtCreateSession=(l,p,h)=>(r._OrtCreateSession=P.V)(l,p,h),r._OrtReleaseSession=l=>(r._OrtReleaseSession=P.W)(l),r._OrtGetInputOutputCount=(l,p,h)=>(r._OrtGetInputOutputCount=P.X)(l,p,h),r._OrtGetInputName=(l,p)=>(r._OrtGetInputName=P.Y)(l,p),r._OrtGetOutputName=(l,p)=>(r._OrtGetOutputName=P.Z)(l,p),r._OrtFree=l=>(r._OrtFree=P._)(l),r._OrtCreateTensor=(l,p,h,C,I,U)=>(r._OrtCreateTensor=P.$)(l,p,h,C,I,U),r._OrtGetTensorData=(l,p,h,C,I)=>(r._OrtGetTensorData=P.aa)(l,p,h,C,I),r._OrtReleaseTensor=l=>(r._OrtReleaseTensor=P.ba)(l),r._OrtCreateRunOptions=(l,p,h,C)=>(r._OrtCreateRunOptions=P.ca)(l,p,h,C),r._OrtAddRunConfigEntry=(l,p,h)=>(r._OrtAddRunConfigEntry=P.da)(l,p,h),r._OrtReleaseRunOptions=l=>(r._OrtReleaseRunOptions=P.ea)(l),r._OrtCreateBinding=l=>(r._OrtCreateBinding=P.fa)(l),r._OrtBindInput=(l,p,h)=>(r._OrtBindInput=P.ga)(l,p,h),r._OrtBindOutput=(l,p,h,C)=>(r._OrtBindOutput=P.ha)(l,p,h,C),r._OrtClearBoundOutputs=l=>(r._OrtClearBoundOutputs=P.ia)(l),r._OrtReleaseBinding=l=>(r._OrtReleaseBinding=P.ja)(l),r._OrtRunWithBinding=(l,p,h,C,I)=>(r._OrtRunWithBinding=P.ka)(l,p,h,C,I),r._OrtRun=(l,p,h,C,I,U,N,oe)=>(r._OrtRun=P.la)(l,p,h,C,I,U,N,oe),r._OrtEndProfiling=l=>(r._OrtEndProfiling=P.ma)(l),r._JsepOutput=(l,p,h)=>(r._JsepOutput=P.na)(l,p,h),r._JsepGetNodeName=l=>(r._JsepGetNodeName=P.oa)(l);var Mt=r._malloc=l=>(Mt=r._malloc=P.pa)(l),jt=r._free=l=>(jt=r._free=P.qa)(l),Kt=l=>(Kt=P.sa)(l),qt=()=>(qt=P.ta)(),Yt=l=>(Yt=P.ua)(l),Xt=l=>(Xt=P.va)(l),Jt=l=>(Jt=P.xa)(l),Zt=()=>(Zt=P.ya)(),kt=l=>(kt=P.za)(l),$t=()=>($t=P.Aa)();r.___start_em_js=924778,r.___stop_em_js=924939;function pt(l){l=Object.assign({},l);var p=C=>()=>C()>>>0,h=C=>I=>C(I)>>>0;return l.__errno_location=p(l.__errno_location),l.malloc=h(l.malloc),l.stackSave=p(l.stackSave),l.stackAlloc=h(l.stackAlloc),l}r.stackAlloc=Xt,r.stackSave=qt,r.stackRestore=Yt,r.UTF8ToString=_e,r.stringToUTF8=(l,p,h)=>Vt(l,le,p,h),r.lengthBytesUTF8=Ot;var xt;Ue=function l(){xt||Qt(),xt||(Ue=l)};function Qt(){function l(){if(!xt&&(xt=!0,r.calledRun=!0,!k)){if(yt(Se),a(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var p=r.postRun.shift();Oe.unshift(p)}yt(Oe)}}if(!(0<Ce)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)Ie();yt(j),0<Ce||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),l()},1)):l())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return Qt(),t.ready}})();typeof ho=="object"&&typeof gn=="object"?gn.exports=mo:typeof define=="function"&&define.amd&&define([],()=>mo)});var yo=tr(()=>{});var bo=tr(()=>{});var wo={};_r(wo,{cpus:()=>Du});var Du,vo=L(()=>{Du=void 0});var So=tr((xo,yn)=>{"use strict";var $o=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return we.buffer!=Ce.buffer&&pe(),Ce}function a(){return we.buffer!=Ce.buffer&&pe(),dt}function n(){return we.buffer!=Ce.buffer&&pe(),Ue}function s(){return we.buffer!=Ce.buffer&&pe(),Fe}function u(){return we.buffer!=Ce.buffer&&pe(),G}function d(){return we.buffer!=Ce.buffer&&pe(),de}var o=t,m,g;o.ready=new Promise((i,c)=>{m=i,g=c}),o.jsepInit=(i,c,f,v,T,R,V,ae)=>{o.Qb=i,o.wb=c,o.yb=f,o.jb=v,o.xb=T,o.Ea=R,o.zb=V,o.Ab=ae,c=(ee,Z,re)=>(...he)=>{let be=Ze,O=Z?.();he=ee(...he);let ue=Z?.();return O!==ue&&(ee=ue,re(O),Z=re=null),Ze!=be?xu():he},f=ee=>async(...Z)=>{try{if(o.bb)throw Error("Session already started");let re=o.bb={Fb:Z[0],errors:[]},he=await ee(...Z);if(o.bb!==re)throw Error("Session mismatch");i.flush();let be=re.errors;if(0<be.length){let O=await Promise.all(be);if(O=O.filter(ue=>ue),0<O.length)throw Error(O.join(`\n`))}return he}finally{o.bb=null}},o._OrtRun=f(c(o._OrtRun,()=>o._OrtRun,ee=>o._OrtRun=ee)),o._OrtRunWithBinding=f(c(o._OrtRunWithBinding,()=>o._OrtRunWithBinding,ee=>o._OrtRunWithBinding=ee)),o._OrtBindInput=c(o._OrtBindInput,()=>o._OrtBindInput,ee=>o._OrtBindInput=ee),o.jsepRegisterBuffer=(ee,Z,re,he)=>i.registerBuffer(ee,Z,re,he),o.jsepUnregisterBuffers=ee=>{i.unregisterBuffers(ee)},o.jsepGetBuffer=ee=>i.getBuffer(ee),o.jsepCreateDownloader=(ee,Z,re)=>i.createDownloader(ee,Z,re)};var x=Object.assign({},o),b="./this.program",y=(i,c)=>{throw c},$=typeof window=="object",w=typeof importScripts=="function",S=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",A=o.ENVIRONMENT_IS_PTHREAD||!1,_="";function z(i){return o.locateFile?o.locateFile(i,_):_+i}var D,W,P;if(S){var k=(fn(),Dt(pn)),H=(hn(),Dt(mn));_=w?H.dirname(_)+"/":__dirname+"/",D=(c,f)=>(c=c.startsWith("file://")?new URL(c):H.normalize(c),k.readFileSync(c,f?void 0:"utf8")),P=c=>(c=D(c,!0),c.buffer||(c=new Uint8Array(c)),c),W=(c,f,v,T=!0)=>{c=c.startsWith("file://")?new URL(c):H.normalize(c),k.readFile(c,T?void 0:"utf8",(R,V)=>{R?v(R):f(T?V.buffer:V)})},!o.thisProgram&&1<process.argv.length&&(b=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),y=(c,f)=>{throw process.exitCode=c,f},o.inspect=()=>"[Emscripten Module object]";let i;try{i=yo()}catch(c){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),c}global.Worker=i.Worker}else($||w)&&(w?_=self.location.href:typeof document<"u"&&document.currentScript&&(_=document.currentScript.src),typeof e<"u"&&e&&(_=e),_.indexOf("blob:")!==0?_=_.substr(0,_.replace(/[?#].*/,"").lastIndexOf("/")+1):_="",S||(D=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.send(null),c.responseText},w&&(P=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.responseType="arraybuffer",c.send(null),new Uint8Array(c.response)}),W=(i,c,f)=>{var v=new XMLHttpRequest;v.open("GET",i,!0),v.responseType="arraybuffer",v.onload=()=>{v.status==200||v.status==0&&v.response?c(v.response):f()},v.onerror=f,v.send(null)}));S&&typeof performance>"u"&&(global.performance=bo().performance);var X=console.log.bind(console),le=console.error.bind(console);S&&(X=(...i)=>k.writeSync(1,i.join(" ")+`\n`),le=(...i)=>k.writeSync(2,i.join(" ")+`\n`));var B=o.print||X,K=o.printErr||le;Object.assign(o,x),x=null,o.thisProgram&&(b=o.thisProgram),o.quit&&(y=o.quit);var xe;o.wasmBinary&&(xe=o.wasmBinary);var ie=o.noExitRuntime||!0;typeof WebAssembly!="object"&&Ke("no native wasm support detected");var we,j,Se,Oe=!1,Ie,Ce,dt,Ue,Fe,G,de;function pe(){var i=we.buffer;o.HEAP8=Ce=new Int8Array(i),o.HEAP16=new Int16Array(i),o.HEAP32=Ue=new Int32Array(i),o.HEAPU8=dt=new Uint8Array(i),o.HEAPU16=new Uint16Array(i),o.HEAPU32=Fe=new Uint32Array(i),o.HEAPF32=G=new Float32Array(i),o.HEAPF64=de=new Float64Array(i)}var ze=o.INITIAL_MEMORY||16777216;if(5242880<=ze||Ke("INITIAL_MEMORY should be larger than STACK_SIZE, was "+ze+"! (STACK_SIZE=5242880)"),A)we=o.wasmMemory;else if(o.wasmMemory)we=o.wasmMemory;else if(we=new WebAssembly.Memory({initial:ze/65536,maximum:65536,shared:!0}),!(we.buffer instanceof SharedArrayBuffer))throw K("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),S&&K("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");pe(),ze=we.buffer.byteLength;var Ge=[],Ee=[],ke=[],Ve=0;function Xe(){return ie||0<Ve}var Le=0,yt=null,bt=null;function zt(){Le++,o.monitorRunDependencies&&o.monitorRunDependencies(Le)}function fr(){if(Le--,o.monitorRunDependencies&&o.monitorRunDependencies(Le),Le==0&&(yt!==null&&(clearInterval(yt),yt=null),bt)){var i=bt;bt=null,i()}}function Ke(i){throw o.onAbort&&o.onAbort(i),i="Aborted("+i+")",K(i),Oe=!0,Ie=1,i=new WebAssembly.RuntimeError(i+". Build with -sASSERTIONS for more info."),g(i),i}function Nt(i){return i.startsWith("data:application/octet-stream;base64,")}var _e;_e="ort-wasm-simd-threaded.wasm",Nt(_e)||(_e=z(_e));function Ot(i){if(i==_e&&xe)return new Uint8Array(xe);if(P)return P(i);throw"both async and sync fetching of the wasm failed"}function Vt(i){if(!xe&&($||w)){if(typeof fetch=="function"&&!i.startsWith("file://"))return fetch(i,{credentials:"same-origin"}).then(c=>{if(!c.ok)throw"failed to load wasm binary file at \'"+i+"\'";return c.arrayBuffer()}).catch(()=>Ot(i));if(W)return new Promise((c,f)=>{W(i,v=>c(new Uint8Array(v)),f)})}return Promise.resolve().then(()=>Ot(i))}function at(i,c,f){return Vt(i).then(v=>WebAssembly.instantiate(v,c)).then(v=>v).then(f,v=>{K("failed to asynchronously prepare wasm: "+v),Ke(v)})}function mr(i,c){var f=_e;return xe||typeof WebAssembly.instantiateStreaming!="function"||Nt(f)||f.startsWith("file://")||S||typeof fetch!="function"?at(f,i,c):fetch(f,{credentials:"same-origin"}).then(v=>WebAssembly.instantiateStreaming(v,i).then(c,function(T){return K("wasm streaming compile failed: "+T),K("falling back to ArrayBuffer instantiation"),at(f,i,c)}))}var it,_t={1427128:i=>{o.Ea("Abs",i,void 0)},1427179:i=>{o.Ea("Neg",i,void 0)},1427230:i=>{o.Ea("Floor",i,void 0)},1427283:i=>{o.Ea("Ceil",i,void 0)},1427335:i=>{o.Ea("Reciprocal",i,void 0)},1427393:i=>{o.Ea("Sqrt",i,void 0)},1427445:i=>{o.Ea("Exp",i,void 0)},1427496:i=>{o.Ea("Erf",i,void 0)},1427547:i=>{o.Ea("Sigmoid",i,void 0)},1427602:i=>{o.Ea("Log",i,void 0)},1427653:i=>{o.Ea("Sin",i,void 0)},1427704:i=>{o.Ea("Cos",i,void 0)},1427755:i=>{o.Ea("Tan",i,void 0)},1427806:i=>{o.Ea("Asin",i,void 0)},1427858:i=>{o.Ea("Acos",i,void 0)},1427910:i=>{o.Ea("Atan",i,void 0)},1427962:i=>{o.Ea("Sinh",i,void 0)},1428014:i=>{o.Ea("Cosh",i,void 0)},1428066:i=>{o.Ea("Asinh",i,void 0)},1428119:i=>{o.Ea("Acosh",i,void 0)},1428172:i=>{o.Ea("Atanh",i,void 0)},1428225:i=>{o.Ea("Tanh",i,void 0)},1428277:i=>{o.Ea("Not",i,void 0)},1428328:(i,c,f)=>{o.Ea("ClipV10",i,{min:c,max:f})},1428400:i=>{o.Ea("Clip",i,void 0)},1428452:(i,c)=>{o.Ea("Elu",i,{alpha:c})},1428510:i=>{o.Ea("Relu",i,void 0)},1428562:(i,c)=>{o.Ea("LeakyRelu",i,{alpha:c})},1428626:(i,c)=>{o.Ea("ThresholdedRelu",i,{alpha:c})},1428696:i=>{o.zb(i)},1428730:(i,c)=>o.Ab(i,c,o.bb.Fb,o.bb.errors),1428842:(i,c)=>{o.Ea("Cast",i,{to:c})},1428900:i=>{o.Ea("Add",i,void 0)},1428951:i=>{o.Ea("Sub",i,void 0)},1429002:i=>{o.Ea("Mul",i,void 0)},1429053:i=>{o.Ea("Div",i,void 0)},1429104:i=>{o.Ea("Pow",i,void 0)},1429155:i=>{o.Ea("Equal",i,void 0)},1429208:i=>{o.Ea("Greater",i,void 0)},1429263:i=>{o.Ea("GreaterOrEqual",i,void 0)},1429325:i=>{o.Ea("Less",i,void 0)},1429377:i=>{o.Ea("LessOrEqual",i,void 0)},1429436:(i,c,f,v,T)=>{o.Ea("ReduceMean",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(T>>>0,T+v>>>0)):[]})},1429600:(i,c,f,v,T)=>{o.Ea("ReduceMax",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(T>>>0,T+v>>>0)):[]})},1429763:(i,c,f,v,T)=>{o.Ea("ReduceMin",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(T>>>0,T+v>>>0)):[]})},1429926:(i,c,f,v,T)=>{o.Ea("ReduceProd",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(T>>>0,T+v>>>0)):[]})},1430090:(i,c,f,v,T)=>{o.Ea("ReduceSum",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(T>>>0,T+v>>>0)):[]})},1430253:(i,c,f,v,T)=>{o.Ea("ReduceL1",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(T>>>0,T+v>>>0)):[]})},1430415:(i,c,f,v,T)=>{o.Ea("ReduceL2",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(T>>>0,T+v>>>0)):[]})},1430577:(i,c,f,v,T)=>{o.Ea("ReduceLogSum",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(T>>>0,T+v>>>0)):[]})},1430743:(i,c,f,v,T)=>{o.Ea("ReduceSumSquare",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(T>>>0,T+v>>>0)):[]})},1430912:(i,c,f,v,T)=>{o.Ea("ReduceLogSumExp",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(T>>>0,T+v>>>0)):[]})},1431081:i=>{o.Ea("Where",i,void 0)},1431134:(i,c,f)=>{o.Ea("Transpose",i,{perm:c?Array.from(n().subarray(f>>>0,f+c>>>0)):[]})},1431247:(i,c,f,v,T,R,V,ae,ee,Z,re,he,be)=>{o.Ea("Conv",i,{format:ee?"NHWC":"NCHW",auto_pad:c,dilations:[f],group:v,kernel_shape:[T],pads:R?Array.from(n().subarray(V>>>0,V+R>>>0)):[],strides:[ae],w_is_const:()=>!!r()[Z>>>0],activation:Ne(re),activation_params:he?Array.from(u().subarray(be>>>0,be+he>>>0)):[]})},1431628:(i,c,f,v,T,R,V,ae,ee,Z,re,he,be,O,ue,ye)=>{o.Ea("Conv",i,{format:he?"NHWC":"NCHW",auto_pad:c,dilations:[f,v],group:T,kernel_shape:[R,V],pads:ae?Array.from(n().subarray(ee>>>0,ee+ae>>>0)):[],strides:[Z,re],w_is_const:()=>!!r()[be>>>0],activation:Ne(O),activation_params:ue?Array.from(u().subarray(ye>>>0,ye+ue>>>0)):[]})},1432030:(i,c,f,v,T,R,V,ae,ee,Z,re,he,be,O,ue)=>{o.Ea("ConvTranspose",i,{format:ee?"NHWC":"NCHW",autoPad:c,dilations:[f],group:v,kernel_shape:[T],pads:[R,V],strides:[ae],wIsConst:()=>!!r()[Z>>>0],outputPadding:re?Array.from(n().subarray(he>>>0,he+re>>>0)):[],outputShape:be?Array.from(n().subarray(O>>>0,O+be>>>0)):[],activation:Ne(ue)})},1432444:(i,c,f,v,T,R,V,ae,ee,Z,re,he,be,O)=>{o.Ea("ConvTranspose",i,{format:ae?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(f>>>0,f+2>>>0)),group:v,kernelShape:Array.from(n().subarray(T>>>0,T+2>>>0)),pads:Array.from(n().subarray(R>>>0,R+4>>>0)),strides:Array.from(n().subarray(V>>>0,V+2>>>0)),wIsConst:()=>!!r()[ee>>>0],outputPadding:0<Z?Array.from(n().subarray(re>>>0,re+Z>>>0)):[],outputShape:0<he?Array.from(n().subarray(be>>>0,be+he>>>0)):[],activation:Ne(O)})},1433001:(i,c,f,v,T,R,V,ae,ee,Z,re,he,be,O,ue)=>{o.Ea("ConvTranspose",i,{format:ee?"NHWC":"NCHW",autoPad:c,dilations:[f],group:v,kernel_shape:[T],pads:[R,V],strides:[ae],wIsConst:()=>!!r()[Z>>>0],outputPadding:re?Array.from(n().subarray(he>>>0,he+re>>>0)):[],outputShape:be?Array.from(n().subarray(O>>>0,O+be>>>0)):[],activation:Ne(ue)})},1433415:(i,c,f,v,T,R,V,ae,ee,Z,re,he,be,O)=>{o.Ea("ConvTranspose",i,{format:ae?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(f>>>0,f+2>>>0)),group:v,kernelShape:Array.from(n().subarray(T>>>0,T+2>>>0)),pads:Array.from(n().subarray(R>>>0,R+4>>>0)),strides:Array.from(n().subarray(V>>>0,V+2>>>0)),wIsConst:()=>!!r()[ee>>>0],outputPadding:0<Z?Array.from(n().subarray(re>>>0,re+Z>>>0)):[],outputShape:0<he?Array.from(n().subarray(be>>>0,be+he>>>0)):[],activation:Ne(O)})},1433972:(i,c)=>{o.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},1434063:(i,c,f,v,T,R,V,ae,ee,Z,re,he,be,O,ue,ye)=>{o.Ea("AveragePool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:v,storage_order:T,dilations:[R,V],kernel_shape:[ae,ee],pads:[Z,re,he,be],strides:[O,ue]})},1434347:(i,c)=>{o.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},1434438:(i,c,f,v,T,R,V,ae,ee,Z,re,he,be,O,ue,ye)=>{o.Ea("AveragePool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:v,storage_order:T,dilations:[R,V],kernel_shape:[ae,ee],pads:[Z,re,he,be],strides:[O,ue]})},1434722:(i,c)=>{o.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},1434809:(i,c,f,v,T,R,V,ae,ee,Z,re,he,be,O,ue,ye)=>{o.Ea("MaxPool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:v,storage_order:T,dilations:[R,V],kernel_shape:[ae,ee],pads:[Z,re,he,be],strides:[O,ue]})},1435089:(i,c)=>{o.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},1435176:(i,c,f,v,T,R,V,ae,ee,Z,re,he,be,O,ue,ye)=>{o.Ea("MaxPool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:v,storage_order:T,dilations:[R,V],kernel_shape:[ae,ee],pads:[Z,re,he,be],strides:[O,ue]})},1435456:(i,c,f,v,T)=>{o.Ea("Gemm",i,{alpha:c,beta:f,transA:v,transB:T})},1435560:i=>{o.Ea("MatMul",i,void 0)},1435614:(i,c,f,v)=>{o.Ea("ArgMax",i,{keepDims:!!c,selectLastIndex:!!f,axis:v})},1435722:(i,c,f,v)=>{o.Ea("ArgMin",i,{keepDims:!!c,selectLastIndex:!!f,axis:v})},1435830:(i,c)=>{o.Ea("Softmax",i,{axis:c})},1435893:(i,c)=>{o.Ea("Concat",i,{axis:c})},1435953:(i,c,f,v,T)=>{o.Ea("Split",i,{axis:c,numOutputs:f,splitSizes:v?Array.from(n().subarray(T>>>0,T+v>>>0)):[]})},1436098:i=>{o.Ea("Expand",i,void 0)},1436152:(i,c)=>{o.Ea("Gather",i,{axis:Number(c)})},1436223:(i,c)=>{o.Ea("GatherElements",i,{axis:Number(c)})},1436302:(i,c,f,v,T,R,V,ae,ee,Z,re)=>{o.Ea("Resize",i,{antialias:c,axes:f?Array.from(n().subarray(v>>>0,v+f>>>0)):[],coordinateTransformMode:Ne(T),cubicCoeffA:R,excludeOutside:V,extrapolationValue:ae,keepAspectRatioPolicy:Ne(ee),mode:Ne(Z),nearestMode:Ne(re)})},1436653:(i,c,f,v,T,R,V)=>{o.Ea("Slice",i,{starts:c?Array.from(n().subarray(f>>>0,f+c>>>0)):[],ends:v?Array.from(n().subarray(T>>>0,T+v>>>0)):[],axes:R?Array.from(n().subarray(V>>>0,V+R>>>0)):[]})},1436884:i=>{o.Ea("Tile",i,void 0)},1436936:(i,c,f)=>{o.Ea("LayerNormalization",i,{axis:Number(c),epsilon:Number(f)})},1437043:(i,c,f)=>{o.Ea("InstanceNormalization",i,{epsilon:c,format:f?"NHWC":"NCHW"})},1437157:(i,c,f)=>{o.Ea("InstanceNormalization",i,{epsilon:c,format:f?"NHWC":"NCHW"})},1437271:i=>{o.Ea("Range",i,void 0)},1437324:(i,c)=>{o.Ea("Einsum",i,{equation:Ne(c)})},1437405:(i,c,f,v,T)=>{o.Ea("Pad",i,{mode:c,value:f,pads:v?Array.from(n().subarray(T>>>0,T+v>>>0)):[]})},1437537:i=>{o.Ea("Gelu",i,void 0)},1437589:i=>{o.Ea("BiasAdd",i,void 0)},1437644:i=>{o.Ea("BiasSplitGelu",i,void 0)},1437705:(i,c)=>{o.Ea("SkipLayerNormalization",i,{epsilon:c})},1437786:i=>o.wb(i),1437819:i=>o.yb(i),1437851:(i,c,f)=>{o.jb(i,c,f,!0)},1437890:(i,c,f)=>{o.jb(i,c,f)}};function ct(i){this.name="ExitStatus",this.message=`Program terminated with exit(${i})`,this.status=i}function Rt(i){i.terminate(),i.onmessage=()=>{}}function Pt(i){(i=ne.Qa[i])||Ke(),ne.Eb(i)}function Ut(i){var c=ne.tb();if(!c)return 6;ne.Ya.push(c),ne.Qa[i.Xa]=c,c.Xa=i.Xa;var f={cmd:"run",start_routine:i.Gb,arg:i.rb,pthread_ptr:i.Xa};return S&&c.unref(),c.postMessage(f,i.Mb),0}var Bt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,hr=(i,c,f)=>{c>>>=0;var v=c+f;for(f=c;i[f]&&!(f>=v);)++f;if(16<f-c&&i.buffer&&Bt)return Bt.decode(i.buffer instanceof SharedArrayBuffer?i.slice(c,f):i.subarray(c,f));for(v="";c<f;){var T=i[c++];if(T&128){var R=i[c++]&63;if((T&224)==192)v+=String.fromCharCode((T&31)<<6|R);else{var V=i[c++]&63;T=(T&240)==224?(T&15)<<12|R<<6|V:(T&7)<<18|R<<12|V<<6|i[c++]&63,65536>T?v+=String.fromCharCode(T):(T-=65536,v+=String.fromCharCode(55296|T>>10,56320|T&1023))}}else v+=String.fromCharCode(T)}return v},Ne=(i,c)=>(i>>>=0)?hr(a(),i,c):"";function Gt(i){if(A)return N(1,1,i);Ie=i,Xe()||(ne.Hb(),o.onExit&&o.onExit(i),Oe=!0),y(i,new ct(i))}var Ft=i=>{if(Ie=i,A)throw gr(i),"unwind";Gt(i)},ne={ab:[],Ya:[],mb:[],Qa:{},gb:function(){A?ne.vb():ne.ub()},ub:function(){Ge.unshift(()=>{zt(),ne.Bb(()=>fr())})},vb:function(){ne.receiveObjectTransfer=ne.Db,ne.threadInitTLS=ne.lb,ne.setExitStatus=ne.kb,ie=!1},kb:function(i){Ie=i},Sb:["$terminateWorker"],Hb:function(){for(var i of ne.Ya)Rt(i);for(i of ne.ab)Rt(i);ne.ab=[],ne.Ya=[],ne.Qa=[]},Eb:function(i){var c=i.Xa;delete ne.Qa[c],ne.ab.push(i),ne.Ya.splice(ne.Ya.indexOf(i),1),i.Xa=0,sn(c)},Db:function(){},lb:function(){ne.mb.forEach(i=>i())},Cb:i=>new Promise(c=>{i.onmessage=R=>{R=R.data;var V=R.cmd;if(R.targetThread&&R.targetThread!=Tr()){var ae=ne.Qa[R.Rb];ae?ae.postMessage(R,R.transferList):K(\'Internal error! Worker sent a message "\'+V+\'" to target pthread \'+R.targetThread+", but that thread no longer exists!")}else V==="checkMailbox"?$t():V==="spawnThread"?Ut(R):V==="cleanupThread"?Pt(R.thread):V==="killThread"?(R=R.thread,V=ne.Qa[R],delete ne.Qa[R],Rt(V),sn(R),ne.Ya.splice(ne.Ya.indexOf(V),1),V.Xa=0):V==="cancelThread"?ne.Qa[R.thread].postMessage({cmd:"cancel"}):V==="loaded"?(i.loaded=!0,c(i)):V==="alert"?alert("Thread "+R.threadId+": "+R.text):R.target==="setimmediate"?i.postMessage(R):V==="callHandler"?o[R.handler](...R.args):V&&K("worker sent an unknown command "+V)},i.onerror=R=>{throw K("worker sent an error! "+R.filename+":"+R.lineno+": "+R.message),R},S&&(i.on("message",function(R){i.onmessage({data:R})}),i.on("error",function(R){i.onerror(R)}));var f=[],v=["onExit","onAbort","print","printErr"],T;for(T of v)o.hasOwnProperty(T)&&f.push(T);i.postMessage({cmd:"load",handlers:f,urlOrBlob:o.mainScriptUrlOrBlob||e,wasmMemory:we,wasmModule:Se})}),Bb:function(i){i()},qb:function(){var i=z("ort-wasm-simd-threaded.worker.js");i=new Worker(i),ne.ab.push(i)},tb:function(){return ne.ab.length==0&&(ne.qb(),ne.Cb(ne.ab[0])),ne.ab.pop()}};o.PThread=ne;var st=i=>{for(;0<i.length;)i.shift()(o)};o.establishStackSpace=function(){var i=Tr(),c=n()[i+52>>2>>>0];i=n()[i+56>>2>>>0],ao(c,c-i),Er(c)};function gr(i){if(A)return N(2,0,i);Ft(i)}o.invokeEntryPoint=function(i,c){i=io.apply(null,[i,c]),Xe()?ne.kb(i):un(i)};function Je(i){this.fb=i-24,this.pb=function(c){s()[this.fb+4>>2>>>0]=c},this.ob=function(c){s()[this.fb+8>>2>>>0]=c},this.gb=function(c,f){this.nb(),this.pb(c),this.ob(f)},this.nb=function(){s()[this.fb+16>>2>>>0]=0}}var He=0,yr=0;function wt(i,c,f,v){return A?N(3,1,i,c,f,v):Lt(i,c,f,v)}function Lt(i,c,f,v){if(i>>>=0,c>>>=0,f>>>=0,v>>>=0,typeof SharedArrayBuffer>"u")return K("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var T=[];return A&&T.length===0?wt(i,c,f,v):(i={Gb:f,Xa:i,rb:v,Mb:T},A?(i.Ob="spawnThread",postMessage(i,T),0):Ut(i))}function Ht(i,c,f){return A?N(4,1,i,c,f):0}function br(i,c){if(A)return N(5,1,i,c)}var vt=i=>{for(var c=0,f=0;f<i.length;++f){var v=i.charCodeAt(f);127>=v?c++:2047>=v?c+=2:55296<=v&&57343>=v?(c+=4,++f):c+=3}return c},wr=(i,c,f,v)=>{if(f>>>=0,!(0<v))return 0;var T=f;v=f+v-1;for(var R=0;R<i.length;++R){var V=i.charCodeAt(R);if(55296<=V&&57343>=V){var ae=i.charCodeAt(++R);V=65536+((V&1023)<<10)|ae&1023}if(127>=V){if(f>=v)break;c[f++>>>0]=V}else{if(2047>=V){if(f+1>=v)break;c[f++>>>0]=192|V>>6}else{if(65535>=V){if(f+2>=v)break;c[f++>>>0]=224|V>>12}else{if(f+3>=v)break;c[f++>>>0]=240|V>>18,c[f++>>>0]=128|V>>12&63}c[f++>>>0]=128|V>>6&63}c[f++>>>0]=128|V&63}}return c[f>>>0]=0,f-T},vr=(i,c,f)=>wr(i,a(),c,f);function $r(i,c){if(A)return N(6,1,i,c)}function xr(i,c,f){if(A)return N(7,1,i,c,f)}function Sr(i,c,f){return A?N(8,1,i,c,f):0}function Cr(i,c){if(A)return N(9,1,i,c)}function Mt(i,c,f){if(A)return N(10,1,i,c,f)}function jt(i,c,f,v){if(A)return N(11,1,i,c,f,v)}function Kt(i,c,f,v){if(A)return N(12,1,i,c,f,v)}function qt(i,c,f,v){if(A)return N(13,1,i,c,f,v)}function Yt(i){if(A)return N(14,1,i)}function Xt(i,c){if(A)return N(15,1,i,c)}function Jt(i,c,f){if(A)return N(16,1,i,c,f)}var Zt=i=>{if(!Oe)try{if(i(),!Xe())try{A?un(Ie):Ft(Ie)}catch(c){c instanceof ct||c=="unwind"||y(1,c)}}catch(c){c instanceof ct||c=="unwind"||y(1,c)}};function kt(i){i>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(n(),i>>2,i).value.then($t),i+=128,Atomics.store(n(),i>>2,1))}o.__emscripten_thread_mailbox_await=kt;function $t(){var i=Tr();i&&(kt(i),Zt(()=>no()))}o.checkMailbox=$t;var pt=i=>i%4===0&&(i%100!==0||i%400===0),xt=[0,31,60,91,121,152,182,213,244,274,305,335],Qt=[0,31,59,90,120,151,181,212,243,273,304,334];function l(i,c,f,v,T,R,V,ae){return A?N(17,1,i,c,f,v,T,R,V,ae):-52}function p(i,c,f,v,T,R,V){if(A)return N(18,1,i,c,f,v,T,R,V)}var h=i=>{var c=vt(i)+1,f=an(c);return f&&vr(i,f,c),f},C=[],I=(i,c)=>{C.length=0;var f;for(c>>=2;f=a()[i++>>>0];)c+=f!=105&c,C.push(f==105?n()[c>>>0]:d()[c++>>>1]),++c;return C},U=i=>{var c=ln();return i=i(),Er(c),i};function N(i,c){var f=arguments.length-2,v=arguments;return U(()=>{for(var T=dn(8*f),R=T>>3,V=0;V<f;V++){var ae=v[2+V];d()[R+V>>>0]=ae}return ro(i,f,T,c)})}var oe=[],q={},Q=()=>{if(!J){var i={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:b||"./this.program"},c;for(c in q)q[c]===void 0?delete i[c]:i[c]=q[c];var f=[];for(c in i)f.push(`${c}=${i[c]}`);J=f}return J},J;function ce(i,c){if(A)return N(19,1,i,c);i>>>=0,c>>>=0;var f=0;return Q().forEach(function(v,T){var R=c+f;for(T=s()[i+4*T>>2>>>0]=R,R=0;R<v.length;++R)r()[T++>>0>>>0]=v.charCodeAt(R);r()[T>>0>>>0]=0,f+=v.length+1}),0}function me(i,c){if(A)return N(20,1,i,c);i>>>=0,c>>>=0;var f=Q();s()[i>>2>>>0]=f.length;var v=0;return f.forEach(function(T){v+=T.length+1}),s()[c>>2>>>0]=v,0}function E(i){return A?N(21,1,i):52}function te(i,c,f,v){return A?N(22,1,i,c,f,v):52}function fe(i,c,f,v,T){return A?N(23,1,i,c,f,v,T):70}var ut=[null,[],[]];function er(i,c,f,v){if(A)return N(24,1,i,c,f,v);c>>>=0,f>>>=0,v>>>=0;for(var T=0,R=0;R<f;R++){var V=s()[c>>2>>>0],ae=s()[c+4>>2>>>0];c+=8;for(var ee=0;ee<ae;ee++){var Z=a()[V+ee>>>0],re=ut[i];Z===0||Z===10?((i===1?B:K)(hr(re,0)),re.length=0):re.push(Z)}T+=ae}return s()[v>>2>>>0]=T,0}var qn=[31,29,31,30,31,30,31,31,30,31,30,31],Yn=[31,28,31,30,31,30,31,31,30,31,30,31];function yu(i){var c=Array(vt(i)+1);return wr(i,c,0,c.length),c}var bu=(i,c)=>{r().set(i,c>>>0)};function Xn(i,c,f,v){function T(O,ue,ye){for(O=typeof O=="number"?O.toString():O||"";O.length<ue;)O=ye[0]+O;return O}function R(O,ue){return T(O,ue,"0")}function V(O,ue){function ye(fo){return 0>fo?-1:0<fo?1:0}var St;return(St=ye(O.getFullYear()-ue.getFullYear()))===0&&(St=ye(O.getMonth()-ue.getMonth()))===0&&(St=ye(O.getDate()-ue.getDate())),St}function ae(O){switch(O.getDay()){case 0:return new Date(O.getFullYear()-1,11,29);case 1:return O;case 2:return new Date(O.getFullYear(),0,3);case 3:return new Date(O.getFullYear(),0,2);case 4:return new Date(O.getFullYear(),0,1);case 5:return new Date(O.getFullYear()-1,11,31);case 6:return new Date(O.getFullYear()-1,11,30)}}function ee(O){var ue=O.Za;for(O=new Date(new Date(O.$a+1900,0,1).getTime());0<ue;){var ye=O.getMonth(),St=(pt(O.getFullYear())?qn:Yn)[ye];if(ue>St-O.getDate())ue-=St-O.getDate()+1,O.setDate(1),11>ye?O.setMonth(ye+1):(O.setMonth(0),O.setFullYear(O.getFullYear()+1));else{O.setDate(O.getDate()+ue);break}}return ye=new Date(O.getFullYear()+1,0,4),ue=ae(new Date(O.getFullYear(),0,4)),ye=ae(ye),0>=V(ue,O)?0>=V(ye,O)?O.getFullYear()+1:O.getFullYear():O.getFullYear()-1}i>>>=0,c>>>=0,f>>>=0,v>>>=0;var Z=n()[v+40>>2>>>0];v={Kb:n()[v>>2>>>0],Jb:n()[v+4>>2>>>0],cb:n()[v+8>>2>>>0],ib:n()[v+12>>2>>>0],eb:n()[v+16>>2>>>0],$a:n()[v+20>>2>>>0],Wa:n()[v+24>>2>>>0],Za:n()[v+28>>2>>>0],Tb:n()[v+32>>2>>>0],Ib:n()[v+36>>2>>>0],Lb:Z?Ne(Z):""},f=Ne(f),Z={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var re in Z)f=f.replace(new RegExp(re,"g"),Z[re]);var he="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),be="January February March April May June July August September October November December".split(" ");Z={"%a":O=>he[O.Wa].substring(0,3),"%A":O=>he[O.Wa],"%b":O=>be[O.eb].substring(0,3),"%B":O=>be[O.eb],"%C":O=>R((O.$a+1900)/100|0,2),"%d":O=>R(O.ib,2),"%e":O=>T(O.ib,2," "),"%g":O=>ee(O).toString().substring(2),"%G":O=>ee(O),"%H":O=>R(O.cb,2),"%I":O=>(O=O.cb,O==0?O=12:12<O&&(O-=12),R(O,2)),"%j":O=>{for(var ue=0,ye=0;ye<=O.eb-1;ue+=(pt(O.$a+1900)?qn:Yn)[ye++]);return R(O.ib+ue,3)},"%m":O=>R(O.eb+1,2),"%M":O=>R(O.Jb,2),"%n":()=>`\n`,"%p":O=>0<=O.cb&&12>O.cb?"AM":"PM","%S":O=>R(O.Kb,2),"%t":()=>"	","%u":O=>O.Wa||7,"%U":O=>R(Math.floor((O.Za+7-O.Wa)/7),2),"%V":O=>{var ue=Math.floor((O.Za+7-(O.Wa+6)%7)/7);if(2>=(O.Wa+371-O.Za-2)%7&&ue++,ue)ue==53&&(ye=(O.Wa+371-O.Za)%7,ye==4||ye==3&&pt(O.$a)||(ue=1));else{ue=52;var ye=(O.Wa+7-O.Za-1)%7;(ye==4||ye==5&&pt(O.$a%400-1))&&ue++}return R(ue,2)},"%w":O=>O.Wa,"%W":O=>R(Math.floor((O.Za+7-(O.Wa+6)%7)/7),2),"%y":O=>(O.$a+1900).toString().substring(2),"%Y":O=>O.$a+1900,"%z":O=>{O=O.Ib;var ue=0<=O;return O=Math.abs(O)/60,(ue?"+":"-")+("0000"+(O/60*100+O%60)).slice(-4)},"%Z":O=>O.Lb,"%%":()=>"%"},f=f.replace(/%%/g,"\\0\\0");for(re in Z)f.includes(re)&&(f=f.replace(new RegExp(re,"g"),Z[re](v)));return f=f.replace(/\\0\\0/g,"%"),re=yu(f),re.length>c?0:(bu(re,i),re.length-1)}function Ar(i){try{i()}catch(c){Ke(c)}}function wu(i){var c={},f;for(f in i)(function(v){var T=i[v];c[v]=typeof T=="function"?function(){Ir.push(v);try{return T.apply(null,arguments)}finally{Oe||(Ir.pop()===v||Ke(),Ze&&ft===1&&Ir.length===0&&(ft=0,Ve+=1,Ar(uo),typeof Fibers<"u"&&Fibers.Ub()))}}:T})(f);return c}var ft=0,Ze=null,Jn=0,Ir=[],Zn={},Qn={},vu=0,on=null,$u=[];function xu(){return new Promise((i,c)=>{on={resolve:i,reject:c}})}function Su(){var i=an(65548),c=i+12;s()[i>>2>>>0]=c,s()[i+4>>2>>>0]=c+65536,c=Ir[0];var f=Zn[c];return f===void 0&&(f=vu++,Zn[c]=f,Qn[f]=c),c=f,n()[i+8>>2>>>0]=c,i}function Cu(){var i=n()[Ze+8>>2>>>0];return i=j[Qn[i]],--Ve,i()}function Au(i){if(!Oe){if(ft===0){var c=!1,f=!1;i((v=0)=>{if(!Oe&&(Jn=v,c=!0,f)){ft=2,Ar(()=>lo(Ze)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),v=!1;try{var T=Cu()}catch(ae){T=ae,v=!0}var R=!1;if(!Ze){var V=on;V&&(on=null,(v?V.reject:V.resolve)(T),R=!0)}if(v&&!R)throw T}}),f=!0,c||(ft=1,Ze=Su(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),Ar(()=>so(Ze)))}else ft===2?(ft=0,Ar(co),eo(Ze),Ze=null,$u.forEach(v=>Zt(v))):Ke(`invalid state: ${ft}`);return Jn}}function Iu(i){return Au(c=>{i().then(c)})}ne.gb();var Tu=[null,Gt,gr,wt,Ht,br,$r,xr,Sr,Cr,Mt,jt,Kt,qt,Yt,Xt,Jt,l,p,ce,me,E,te,fe,er],Eu={r:function(i,c,f){return Iu(async()=>{await o.xb(i,c,f)})},b:function(i,c,f){throw i>>>=0,new Je(i).gb(c>>>0,f>>>0),He=i,yr++,He},P:function(i){to(i>>>0,!w,1,!$,131072,!1),ne.lb()},n:function(i){i>>>=0,A?postMessage({cmd:"cleanupThread",thread:i}):Pt(i)},K:Lt,g:Ht,V:br,F:$r,H:xr,y:Sr,T:Cr,L:Mt,S:jt,p:Kt,G:qt,D:Yt,U:Xt,E:Jt,q:()=>!0,B:function(i,c){i>>>=0,i==c>>>0?setTimeout(()=>$t()):A?postMessage({targetThread:i,cmd:"checkMailbox"}):(i=ne.Qa[i])&&i.postMessage({cmd:"checkMailbox"})},N:function(){return-1},O:kt,X:function(i){S&&ne.Qa[i>>>0].ref()},u:function(i,c,f){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,f>>>=0,i=new Date(1e3*i),n()[f>>2>>>0]=i.getUTCSeconds(),n()[f+4>>2>>>0]=i.getUTCMinutes(),n()[f+8>>2>>>0]=i.getUTCHours(),n()[f+12>>2>>>0]=i.getUTCDate(),n()[f+16>>2>>>0]=i.getUTCMonth(),n()[f+20>>2>>>0]=i.getUTCFullYear()-1900,n()[f+24>>2>>>0]=i.getUTCDay(),i=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,n()[f+28>>2>>>0]=i},v:function(i,c,f){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,f>>>=0,i=new Date(1e3*i),n()[f>>2>>>0]=i.getSeconds(),n()[f+4>>2>>>0]=i.getMinutes(),n()[f+8>>2>>>0]=i.getHours(),n()[f+12>>2>>>0]=i.getDate(),n()[f+16>>2>>>0]=i.getMonth(),n()[f+20>>2>>>0]=i.getFullYear()-1900,n()[f+24>>2>>>0]=i.getDay(),c=(pt(i.getFullYear())?xt:Qt)[i.getMonth()]+i.getDate()-1|0,n()[f+28>>2>>>0]=c,n()[f+36>>2>>>0]=-(60*i.getTimezoneOffset()),c=new Date(i.getFullYear(),6,1).getTimezoneOffset();var v=new Date(i.getFullYear(),0,1).getTimezoneOffset();i=(c!=v&&i.getTimezoneOffset()==Math.min(v,c))|0,n()[f+32>>2>>>0]=i},w:function(i){i>>>=0;var c=new Date(n()[i+20>>2>>>0]+1900,n()[i+16>>2>>>0],n()[i+12>>2>>>0],n()[i+8>>2>>>0],n()[i+4>>2>>>0],n()[i>>2>>>0],0),f=n()[i+32>>2>>>0],v=c.getTimezoneOffset(),T=new Date(c.getFullYear(),6,1).getTimezoneOffset(),R=new Date(c.getFullYear(),0,1).getTimezoneOffset(),V=Math.min(R,T);return 0>f?n()[i+32>>2>>>0]=+(T!=R&&V==v):0<f!=(V==v)&&(T=Math.max(R,T),c.setTime(c.getTime()+6e4*((0<f?V:T)-v))),n()[i+24>>2>>>0]=c.getDay(),f=(pt(c.getFullYear())?xt:Qt)[c.getMonth()]+c.getDate()-1|0,n()[i+28>>2>>>0]=f,n()[i>>2>>>0]=c.getSeconds(),n()[i+4>>2>>>0]=c.getMinutes(),n()[i+8>>2>>>0]=c.getHours(),n()[i+12>>2>>>0]=c.getDate(),n()[i+16>>2>>>0]=c.getMonth(),n()[i+20>>2>>>0]=c.getYear(),i=c.getTime()/1e3,oo((it=i,1<=+Math.abs(it)?0<it?+Math.floor(it/4294967296)>>>0:~~+Math.ceil((it-+(~~it>>>0))/4294967296)>>>0:0)),i>>>0},s:l,t:p,A:function(i,c,f){function v(Z){return(Z=Z.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?Z[1]:"GMT"}i>>>=0,c>>>=0,f>>>=0;var T=new Date().getFullYear(),R=new Date(T,0,1),V=new Date(T,6,1);T=R.getTimezoneOffset();var ae=V.getTimezoneOffset(),ee=Math.max(T,ae);s()[i>>2>>>0]=60*ee,n()[c>>2>>>0]=+(T!=ae),i=v(R),c=v(V),i=h(i),c=h(c),ae<T?(s()[f>>2>>>0]=i,s()[f+4>>2>>>0]=c):(s()[f>>2>>>0]=c,s()[f+4>>2>>>0]=i)},e:()=>{Ke("")},c:function(i,c,f){return i>>>=0,c=I(c>>>0,f>>>0),_t[i].apply(null,c)},l:function(i,c,f){return i>>>=0,c=I(c>>>0,f>>>0),_t[i].apply(null,c)},o:function(){},k:function(){return Date.now()},W:()=>{throw Ve+=1,"unwind"},C:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),j:function(){return S?(vo(),Dt(wo)).cpus().length:navigator.hardwareConcurrency},M:function(i,c,f,v){for(ne.Pb=c>>>0,oe.length=f,c=v>>>0>>3,v=0;v<f;v++)oe[v]=d()[c+v>>>0];return(0>i?_t[-i-1]:Tu[i]).apply(null,oe)},z:function(i){i>>>=0;var c=a().length;if(i<=c||4294901760<i)return!1;for(var f=1;4>=f;f*=2){var v=c*(1+.2/f);v=Math.min(v,i+100663296);var T=Math;v=Math.max(i,v);e:{T=T.min.call(T,4294901760,v+(65536-v%65536)%65536)-we.buffer.byteLength+65535>>>16;try{we.grow(T),pe();var R=1;break e}catch{}R=void 0}if(R)return!0}return!1},Q:ce,R:me,J:Ft,h:E,m:te,x:fe,i:er,a:we||o.wasmMemory,I:Xn,d:function(i,c,f,v){return Xn(i>>>0,c>>>0,f>>>0,v>>>0)}};(function(){function i(f,v){return f=f.exports,f=wu(f),j=f=Ou(f),ne.mb.push(j.Da),Ee.unshift(j.Y),Se=v,fr(),f}var c={a:Eu};if(zt(),o.instantiateWasm)try{return o.instantiateWasm(c,i)}catch(f){K("Module.instantiateWasm callback failed with error: "+f),g(f)}return mr(c,function(f){i(f.instance,f.module)}).catch(g),{}})(),o._OrtInit=(i,c)=>(o._OrtInit=j.Z)(i,c),o._OrtGetLastError=(i,c)=>(o._OrtGetLastError=j._)(i,c),o._OrtCreateSessionOptions=(i,c,f,v,T,R,V,ae,ee,Z)=>(o._OrtCreateSessionOptions=j.$)(i,c,f,v,T,R,V,ae,ee,Z),o._OrtAppendExecutionProvider=(i,c)=>(o._OrtAppendExecutionProvider=j.aa)(i,c),o._OrtAddFreeDimensionOverride=(i,c,f)=>(o._OrtAddFreeDimensionOverride=j.ba)(i,c,f),o._OrtAddSessionConfigEntry=(i,c,f)=>(o._OrtAddSessionConfigEntry=j.ca)(i,c,f),o._OrtReleaseSessionOptions=i=>(o._OrtReleaseSessionOptions=j.da)(i),o._OrtCreateSession=(i,c,f)=>(o._OrtCreateSession=j.ea)(i,c,f),o._OrtReleaseSession=i=>(o._OrtReleaseSession=j.fa)(i),o._OrtGetInputOutputCount=(i,c,f)=>(o._OrtGetInputOutputCount=j.ga)(i,c,f),o._OrtGetInputName=(i,c)=>(o._OrtGetInputName=j.ha)(i,c),o._OrtGetOutputName=(i,c)=>(o._OrtGetOutputName=j.ia)(i,c),o._OrtFree=i=>(o._OrtFree=j.ja)(i),o._OrtCreateTensor=(i,c,f,v,T,R)=>(o._OrtCreateTensor=j.ka)(i,c,f,v,T,R),o._OrtGetTensorData=(i,c,f,v,T)=>(o._OrtGetTensorData=j.la)(i,c,f,v,T),o._OrtReleaseTensor=i=>(o._OrtReleaseTensor=j.ma)(i),o._OrtCreateRunOptions=(i,c,f,v)=>(o._OrtCreateRunOptions=j.na)(i,c,f,v),o._OrtAddRunConfigEntry=(i,c,f)=>(o._OrtAddRunConfigEntry=j.oa)(i,c,f),o._OrtReleaseRunOptions=i=>(o._OrtReleaseRunOptions=j.pa)(i),o._OrtCreateBinding=i=>(o._OrtCreateBinding=j.qa)(i),o._OrtBindInput=(i,c,f)=>(o._OrtBindInput=j.ra)(i,c,f),o._OrtBindOutput=(i,c,f,v)=>(o._OrtBindOutput=j.sa)(i,c,f,v),o._OrtClearBoundOutputs=i=>(o._OrtClearBoundOutputs=j.ta)(i),o._OrtReleaseBinding=i=>(o._OrtReleaseBinding=j.ua)(i),o._OrtRunWithBinding=(i,c,f,v,T)=>(o._OrtRunWithBinding=j.va)(i,c,f,v,T),o._OrtRun=(i,c,f,v,T,R,V,ae)=>(o._OrtRun=j.wa)(i,c,f,v,T,R,V,ae),o._OrtEndProfiling=i=>(o._OrtEndProfiling=j.xa)(i),o._JsepOutput=(i,c,f)=>(o._JsepOutput=j.ya)(i,c,f),o._JsepGetNodeName=i=>(o._JsepGetNodeName=j.za)(i);var Tr=o._pthread_self=()=>(Tr=o._pthread_self=j.Aa)(),an=o._malloc=i=>(an=o._malloc=j.Ba)(i),eo=o._free=i=>(eo=o._free=j.Ca)(i);o.__emscripten_tls_init=()=>(o.__emscripten_tls_init=j.Da)();var to=o.__emscripten_thread_init=(i,c,f,v,T,R)=>(to=o.__emscripten_thread_init=j.Fa)(i,c,f,v,T,R);o.__emscripten_thread_crashed=()=>(o.__emscripten_thread_crashed=j.Ga)();var ro=(i,c,f,v)=>(ro=j.Ha)(i,c,f,v),sn=i=>(sn=j.Ia)(i),un=o.__emscripten_thread_exit=i=>(un=o.__emscripten_thread_exit=j.Ja)(i),no=o.__emscripten_check_mailbox=()=>(no=o.__emscripten_check_mailbox=j.Ka)(),oo=i=>(oo=j.La)(i),ao=(i,c)=>(ao=j.Ma)(i,c),ln=()=>(ln=j.Na)(),Er=i=>(Er=j.Oa)(i),dn=i=>(dn=j.Pa)(i),io=o.dynCall_ii=(i,c)=>(io=o.dynCall_ii=j.Ra)(i,c),so=i=>(so=j.Sa)(i),uo=()=>(uo=j.Ta)(),lo=i=>(lo=j.Ua)(i),co=()=>(co=j.Va)();o.___start_em_js=1437923,o.___stop_em_js=1438084;function Ou(i){i=Object.assign({},i);var c=v=>()=>v()>>>0,f=v=>T=>v(T)>>>0;return i.__errno_location=c(i.__errno_location),i.pthread_self=c(i.pthread_self),i.malloc=f(i.malloc),i.stackSave=c(i.stackSave),i.stackAlloc=f(i.stackAlloc),i}o.keepRuntimeAlive=Xe,o.wasmMemory=we,o.stackAlloc=dn,o.stackSave=ln,o.stackRestore=Er,o.UTF8ToString=Ne,o.stringToUTF8=vr,o.lengthBytesUTF8=vt,o.ExitStatus=ct,o.PThread=ne;var Or;bt=function i(){Or||po(),Or||(bt=i)};function po(){function i(){if(!Or&&(Or=!0,o.calledRun=!0,!Oe)&&(A||st(Ee),m(o),o.onRuntimeInitialized&&o.onRuntimeInitialized(),!A)){if(o.postRun)for(typeof o.postRun=="function"&&(o.postRun=[o.postRun]);o.postRun.length;){var c=o.postRun.shift();ke.unshift(c)}st(ke)}}if(!(0<Le))if(A)m(o),A||st(Ee),startWorker(o);else{if(o.preRun)for(typeof o.preRun=="function"&&(o.preRun=[o.preRun]);o.preRun.length;)Ge.unshift(o.preRun.shift());st(Ge),0<Le||(o.setStatus?(o.setStatus("Running..."),setTimeout(function(){setTimeout(function(){o.setStatus("")},1),i()},1)):i())}}if(o.preInit)for(typeof o.preInit=="function"&&(o.preInit=[o.preInit]);0<o.preInit.length;)o.preInit.pop()();return po(),t.ready}})();typeof xo=="object"&&typeof yn=="object"?yn.exports=$o:typeof define=="function"&&define.amd&&define([],()=>$o)});var Co=tr((xc,Wu)=>{Wu.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\\n\'});var vn,nr,or,Pr,ar,_o,$n,De=L(()=>{"use strict";vn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},nr=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},or=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Pr=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},ar=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},_o=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",$n=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var Br=L(()=>{});var Ro=L(()=>{Br()});var Po,Bo=L(()=>{Po="1.17.0"});var Mo,xn,ko=L(()=>{Bo();Mo="warning",xn={wasm:{},webgl:{},webgpu:{},versions:{common:Po},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Mo=e}},get logLevel(){return Mo}};Object.defineProperty(xn,"logLevel",{enumerable:!0})});var Do,Wo=L(()=>{ko();Do=xn});var zo=L(()=>{});var No=L(()=>{Mr()});var Uo=L(()=>{});var Go=L(()=>{Mr()});var Mr=L(()=>{zo();No();Uo();Go()});var kr=L(()=>{Mr()});var Fo,Lo,Sn,Ho,Ct,At,Cn=L(()=>{Lo=e=>{Fo=e},Sn=(e,t)=>{console.timeStamp(`${e}::ORT::${t}`)},Ho=(e,t)=>{let r=new Error().stack?.split(/\\r\\n|\\r|\\n/g)||[],a=!1;for(let n=0;n<r.length;n++){if(a&&!r[n].includes("TRACE_FUNC")){let s=`FUNC_${e}::${r[n].trim().split(" ")[1]}`;t&&(s+=`::${t}`),Sn("CPU",s);return}r[n].includes("TRACE_FUNC")&&(a=!0)}},Ct=e=>{Ho("BEGIN",e)},At=e=>{Ho("END",e)}});var jo=L(()=>{Br();kr();Cn()});var Ko=L(()=>{jo()});var qo=L(()=>{});var Yo=L(()=>{Br();kr()});var Xo=L(()=>{Yo()});var Dr=L(()=>{Ro();Wo();Ko();kr();Cn();qo();Xo()});var qu,Yu,Jo,Zo,Qo,Xu,Te,mt=L(()=>{"use strict";De();qu=["V","I","W","E","F"],Yu=(e,t)=>{console.log(`[${qu[e]},${new Date().toISOString()}]${t}`)},Qo=(e,t)=>{Jo=e,Zo=t},Xu=(e,t)=>{let r=ar(e),a=ar(Jo);r>=a&&Yu(r,typeof t=="function"?t():t)},Te=(...e)=>{Zo&&Xu(...e)}});var ea,ta=L(()=>{"use strict";De();ea=(e,t)=>new(Pr(t))(e)});var Wr=L(()=>{"use strict"});var zr,Ju,ra,In,An,na,oa=L(()=>{"use strict";mt();Wr();zr=e=>Math.ceil(e/16)*16,Ju=1,ra=()=>Ju++,In=async(e,t,r,a)=>{let n=zr(r),s=e.device.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=e.getCommandEncoder();e.endComputePass(),u.copyBufferToBuffer(t,0,s,0,n),e.flush(),await s.mapAsync(GPUMapMode.READ);let d=s.getMappedRange();if(a){let o=a();return o.set(new Uint8Array(d,0,r)),o}else return new Uint8Array(d.slice(0,r))}finally{s.destroy()}},An=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let a=r.buffer,n=r.byteOffset,s=r.byteLength,u=zr(s),d=this.storageCache.get(t);if(!d)throw new Error("gpu data for uploading does not exist");if(d.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${d.originalSize}, data size=${s}`);let o=this.backend.device.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),m=o.getMappedRange();new Uint8Array(m).set(new Uint8Array(a,n,s)),o.unmap();let g=this.backend.getCommandEncoder();this.backend.endComputePass(),g.copyBufferToBuffer(o,0,d.gpuData.buffer,0,u),Te("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(o)}memcpy(t,r){let a=this.storageCache.get(t);if(!a)throw new Error("source gpu data for memcpy does not exist");let n=this.storageCache.get(r);if(!n)throw new Error("destination gpu data for memcpy does not exist");if(a.originalSize!==n.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=zr(a.originalSize),u=this.backend.getCommandEncoder();this.backend.endComputePass(),u.copyBufferToBuffer(a.gpuData.buffer,0,n.gpuData.buffer,0,s)}registerExternalBuffer(t,r,a){let n;if(a){if(n=this.externalBuffers.get(a),n===void 0)throw new Error("previous buffer is not registered");if(t===a)return Te("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, buffer is the same, skip.`),n;this.externalBuffers.delete(a)}else n=ra();return this.storageCache.set(n,{gpuData:{id:n,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,n),Te("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, registered.`),n}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Te("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let a=zr(t),n,s=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,u=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||u){let o=s?this.freeBuffers:this.freeUniformBuffers,m=o.get(a);m||(m=[],o.set(a,m)),m.length>0?n=m.pop():n=this.backend.device.createBuffer({size:a,usage:r})}else n=this.backend.device.createBuffer({size:a,usage:r});let d={id:ra(),type:0,buffer:n};return this.storageCache.set(d.id,{gpuData:d,originalSize:t}),Te("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${d.id}`),d}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Te("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let a=this.storageCache.get(t);if(!a)throw new Error("data does not exist");await In(this.backend,a.gpuData.buffer,a.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},na=(...e)=>new An(...e)});var Tn,se,Pe=L(()=>{"use strict";Tn=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this._cacheKey}},se=e=>new Tn(e)});var En,Qe,M,It,Nr,Vr,Ur,ge=L(()=>{"use strict";En=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},Qe=class{static calcShape(t,r,a=!1){let n=t.length,s=r.length;if(n===0)return r;if(s===0)return t;let u=Math.max(t.length,r.length),d=new Array(u);if(a){if(n<2||s<2)return;let o=En.calcMatMulShape([t[n-2],t[n-1]],[r[s-2],r[s-1]]);if(o===void 0)return;[d[u-2],d[u-1]]=o}for(let o=a?3:1;o<=u;o++){let m=n-o<0?1:t[n-o],g=s-o<0?1:r[s-o];if(m!==g&&m>1&&g>1)return;d[u-o]=Math.max(m,g)}return d}static isValidBroadcast(t,r){let a=t.length,n=r.length;if(a>n)return!1;for(let s=1;s<=a;s++)if(t[a-s]!==1&&t[a-s]!==r[n-s])return!1;return!0}},M=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,a){let n=1;for(let s=r;s<a;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");n*=t[s]}return n}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let a=new Array(r);a[r-1]=1,a[r-2]=t[r-1];for(let n=r-3;n>=0;--n)a[n]=a[n+1]*t[n+1];return a}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(a=>this.normalizeAxis(a,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(a=>t[a]):t.slice().reverse()}static padShape(t,r){let a=t.length;return t.map((n,s)=>n+r[s]+r[s+a])}static areEqual(t,r){return t.length!==r.length?!1:t.every((a,n)=>a===r[n])}},It=class e{static adjustPoolAttributes(t,r,a,n,s,u){if(!t&&a.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let d=0;d<r.length-2;d++)d>=a.length?a.push(r[d+2]):a[d]=r[d+2];for(let d=0;d<a.length;d++)if(d<n.length){if(n[d]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let d=0;d<a.length;d++)if(d<s.length){if(s[d]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let d=0;d<a.length*2;d++)if(d<u.length){if(u[d]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let d=0;d<a.length;d++){if(a[d]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[d]>=a[d]||u[d+a.length]>=a[d])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,a,n,s,u,d){if(d){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let o=0;o<t.length-2;o++)e.adjustPadAndReturnShape(t[o+(u?1:2)],r[o],a[o],n[o],s,o,o+t.length-2,d)}}static computePoolOutputShape(t,r,a,n,s,u,d){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let o=[r[0],r[1]];return e.computeShapeHelper(t,r,o,a,n,s,u,d),o}static computeConvOutputShape(t,r,a,n,s,u,d){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let o=[t[0],r[0]];return e.computeShapeHelper(!1,t,o,a,n,s,u,d),o}static computeShapeHelper(t,r,a,n,s,u,d,o){if(t)for(let m=0;m<r.length-2;m++)a.push(1);else for(let m=0;m<r.length-2;m++)a.push(e.adjustPadAndReturnShape(r[m+2],n[m],s[m],u[m],d,m,m+r.length-2,o))}static adjustPadAndReturnShape(t,r,a,n,s,u,d,o){let m=a*(n-1)+1;if(o&&o!=="NOTSET")switch(o){case"VALID":return s[u]=0,s[d]=0,Math.floor((t-m)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(a!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let x=((t+r-1)/r-1)*r+n-t;return s[u]=Math.floor(o==="SAME_LOWER"?(x+1)/2:x/2),s[d]=x-s[u],Math.floor((t+x-n)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[u]+s[d]-m)/r+1)}},Nr=class{static getShapeOfGemmResult(t,r,a,n,s){if(t.length!==2||a.length!==2)throw new Error("shape need to be of size 2");let u,d,o;r?(u=t[1],d=t[0]):(u=t[0],d=t[1]);let m=-1;if(n?(o=a[0],m=1):(o=a[1],m=0),a[m]!==d)throw new Error("dimension mismatch");if(u<=0||o<=0||d<=0)throw new Error("invalid shape specified");if(s&&!Qe.isValidBroadcast(s,[u,o]))throw new Error("gemm: invalid bias shape for broadcast");return[u,o,d]}},Vr=-34028234663852886e22,Ur=34028234663852886e22});var Zu,aa,Be,Tt,lt,qe,Et,ht,ia,F,Y,On,sa,_n,Wt,ve=L(()=>{"use strict";De();ge();Zu=64,aa=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Be=(e,t=1)=>{let r=aa(e,t);return typeof r=="string"?r:r[0]},Tt=e=>[{type:"uint32",data:e},{type:"uint32",data:M.computeStrides(e)}],lt=e=>e%4===0?4:e%2===0?2:1,qe=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,Et=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,ht=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,ia=(e,t,r,a,n)=>{let s=typeof r=="number",u=s?r:r.length,d=[...new Array(u).keys()],o=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,m=aa(t,n),g=typeof m=="string"?m:m[1],x=typeof m=="string"?m:m[0],b={indices:o,value:g,storage:x,tensor:t},y=G=>typeof G=="string"?G:`${G}u`,$={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},w=s?"uniforms.":"",S=`${w}${e}_shape`,A=`${w}${e}_strides`,_="";for(let G=0;G<u-1;G++)_+=`\n    let dim${G} = current / ${A}[${G}];\n    let rest${G} = current % ${A}[${G}];\n    indices[${G}] = dim${G};\n    current = rest${G};\n    `;_+=`indices[${u-1}] = current;`;let z=u<2?"":`\n  fn o2i_${e}(offset: u32) -> ${b.indices} {\n    var indices: ${b.indices};\n    var current = offset;\n    ${_}\n    return indices;\n  }`,D=G=>($.offsetToIndices=!0,u<2?G:`o2i_${e}(${G})`),W=[];if(u>=2)for(let G=u-1;G>=0;G--)W.push(`${A}[${G}] * (indices[${G}])`);let P=u<2?"":`\n  fn i2o_${e}(indices: ${b.indices}) -> u32 {\n    return ${W.join("+")};\n  }`,k=G=>($.indicesToOffset=!0,u<2?G:`i2o_${e}(${G})`),H=(...G)=>u===0?"0u":`${b.indices}(${G.map(y).join(",")})`,X=(G,de)=>u<2?`${G}`:`${G}[${de}]`,le=(G,de,pe)=>u<2?`${G}=${pe};`:`${G}[${de}]=${pe};`,B={},K=(G,de)=>{$.broadcastedIndicesToOffset=!0;let pe=`${de.name}broadcastedIndicesTo${e}Offset`;if(pe in B)return`${pe}(${G})`;let ze=[];for(let Ge=u-1;Ge>=0;Ge--){let Ee=de.indicesGet("outputIndices",Ge+de.rank-u);ze.push(`${X(A,Ge)} * (${Ee} % ${X(S,Ge)})`)}return B[pe]=`fn ${pe}(outputIndices: ${de.type.indices}) -> u32 {\n             return ${ze.length>0?ze.join("+"):"0u"};\n           }`,`${pe}(${G})`},xe=(G,de)=>(()=>{if(b.storage===b.value)return`${e}[${G}]=${de};`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`${e}[${G}]=vec2<u32>(u32(${de}), select(0u, 0xFFFFFFFFu, ${de} < 0));`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`${e}[${G}]=vec2<u32>(u32(${de}), 0u);`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`${e}[${G}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${de}));`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),ie=G=>(()=>{if(b.storage===b.value)return`${e}[${G}]`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`i32(${e}[${G}].x)`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`u32(${e}[${G}].x)`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${G}] & 0xFFu), bool(${e}[${G}] & 0xFF00u), bool(${e}[${G}] & 0xFF0000u), bool(${e}[${G}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),we=u<2?"":`\n  fn get_${e}ByIndices(indices: ${b.indices}) -> ${g} {\n    return ${ie(`i2o_${e}(indices)`)};\n  }`,j=u<2?"":(()=>{let G=d.map(pe=>`d${pe}: u32`).join(", "),de=d.map(pe=>`d${pe}`).join(", ");return`\n  fn get_${e}(${G}) -> ${g} {\n    return get_${e}ByIndices(${H(de)});\n  }`})(),Se=(...G)=>{if(G.length!==u)throw new Error(`indices length must be ${u}`);let de=G.map(y).join(",");return u===0?ie("0u"):u===1?ie(de[0]):($.get=!0,$.getByIndices=!0,$.indicesToOffset=!0,`get_${e}(${de})`)},Oe=G=>u<2?ie(G):($.getByIndices=!0,$.indicesToOffset=!0,`get_${e}ByIndices(${G})`),Ie=u<2?"":`\n  fn set_${e}ByIndices(indices: ${b.indices}, value: ${g}) {\n    ${xe(`i2o_${e}(indices)`,"value")}\n  }`,Ce=u<2?"":(()=>{let G=d.map(pe=>`d${pe}: u32`).join(", "),de=d.map(pe=>`d${pe}`).join(", ");return`\n  fn set_${e}(${G}, value: ${g}) {\n    set_${e}ByIndices(${H(de)}, value);\n  }`})();return{impl:()=>{let G=[];return s||(G.push(`const ${S} = ${b.indices}(${r.join(",")});`),G.push(`const ${A} = ${b.indices}(${M.computeStrides(r).join(",")});`)),$.offsetToIndices&&G.push(z),$.indicesToOffset&&G.push(P),$.broadcastedIndicesToOffset&&Object.values(B).forEach(de=>G.push(de)),$.set&&G.push(Ce),$.setByIndices&&G.push(Ie),$.get&&G.push(j),$.getByIndices&&G.push(we),G.join(`\n`)},type:b,offsetToIndices:D,indicesToOffset:k,broadcastedIndicesToOffset:K,indices:H,indicesGet:X,indicesSet:le,set:(...G)=>{if(G.length!==u+1)throw new Error(`indices length must be ${u}`);let de=G[u];if(typeof de!="string")throw new Error("value must be string");let pe=G.slice(0,u).map(y).join(",");return u===0?xe("0u",de):u===1?xe(pe[0],de):($.set=!0,$.setByIndices=!0,$.indicesToOffset=!0,`set_${e}(${pe}, ${de})`)},setByOffset:xe,setByIndices:(G,de)=>u<2?xe(G,de):($.setByIndices=!0,$.indicesToOffset=!0,`set_${e}ByIndices(${G}, ${de});`),get:Se,getByOffset:ie,getByIndices:Oe,usage:a?"input":"output",name:e,strides:A,shape:S,rank:u}},F=(e,t,r,a=1)=>ia(e,t,r,!0,a),Y=(e,t,r,a=1)=>ia(e,t,r,!1,a),On=class{constructor(t){this.normalizedDispatchGroup=t;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=Zu){let r=typeof t=="number"?t:t[0],a=typeof t=="number"?1:t[1],n=typeof t=="number"?1:t[2],s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,u=s?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>`,d=s?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${r*a*n}u + local_index;`;return`@compute @workgroup_size(${r}, ${a}, ${n})\n  fn main(${u}) {\n    ${d}\n  `}declareVariable(t,r){this.indicesHelpers.push(t),t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:t.type.indices}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:t.type.indices});let a=t.usage==="input"?"read":"read_write",n=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${a}> ${t.name}: array<${n}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerUniform(t,r){return this.uniforms.push({name:t,type:r}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:a}of this.uniforms)t.push(`${r}:${a}`);return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(t=>t.impl()).join(`\n`)}},sa=e=>new On(e),_n=(e,t)=>{let r=e.length,a=[];for(let n=0;n<r;n++){let s=r-1-n,u=e[s]||1;(t[t.length-1-n]||1)>1&&u===1&&a.unshift(s)}return a},Wt=e=>e<=4&&e>0});var Qu,ua,el,tl,gt,la,da,ir=L(()=>{"use strict";ge();Pe();ve();Qu=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},ua=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,el=(e,t)=>M.sortBasedOnPerm(e,ua(e.length,t)),tl=(e,t,r,a)=>{let n=[];n.push(`fn perm(i: ${a.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let s=0;s<t;++s)n.push(r.indicesSet("a",e[s],`i[${s}]`));return n.push("return a;}"),n.join(`\n`)},gt=(e,t)=>{let r=e.dataType,a=e.dims.length,n=ua(a,t),s=Wt(a),u=el(e.dims,n),d=s?u.length:u,o=s?a:e.dims,m=Y("output",r,d),g=F("a",r,o),x=b=>`\n  ${b.registerUniform("output_size","u32").declareVariables(g,m)}\n\n  ${tl(n,a,g,m)}\n\n  ${b.mainStart()}\n    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${m.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${m.setByOffset("global_idx",g.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:s?["rank"]:["dims"]},getRunData:b=>{let y=M.size(u);return{outputs:[{dims:u,dataType:b[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:s?[{type:"uint32",data:y},...Tt(b[0].dims),...Tt(u)]:[{type:"uint32",data:y}]}},getShaderSource:x}},la=(e,t)=>{Qu(e.inputs),e.compute(gt(e.inputs[0],t.perm))},da=e=>se({perm:e.perm})});var rl,nl,ol,al,il,sl,ul,ll,dl,cl,et,ca,pa,fa,ma,ha,ga,ya,ba,wa,va,$a=L(()=>{"use strict";ge();ve();Gr();ir();rl={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},nl={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},ol={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},al={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},il=(e,t)=>{let r=[];for(let a=t-e;a<t;++a)r.push(a);return r},sl=(e,t)=>{let r=[],a=e.length;for(let s=0;s<a;s++)t.indexOf(s)===-1&&r.push(e[s]);let n=t.map(s=>e[s]);return[r,n]},ul=(e,t)=>{let r=e.length+t.length,a=[],n=0;for(let s=0;s<r;s++)t.indexOf(s)===-1?a.push(e[n++]):a.push(1);return a},ll=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},dl=(e,t)=>{let r=[];if(!ll(e,t)){for(let a=0;a<t;++a)e.indexOf(a)===-1&&r.push(a);e.forEach(a=>r.push(a))}return r},cl=(e,t,r,a,n,s,u)=>{let d=r[0].dims,o=M.size(s),m=M.size(u),g=F("_A",r[0].dataType,d),x=Y("output",n,s),b=32,y=`\n          var<workgroup> aBestValues : array<${x.type.storage}, ${b}>;\n       `;return{name:e,shaderCache:t,getShaderSource:w=>`\n        ${w.registerUniform("reduceSize","u32").declareVariables(g,x)}\n        ${y}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${w.mainStart(b)}\n          let local_idx = local_id.x;\n\n          let outputIndex = global_idx / ${b};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${x.type.storage}(${ol[a]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${b}) {\n           let candidate = ${x.type.storage}(${g.getByOffset("offset + k")});\n           bestValue = ${rl[a]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${b}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${nl[a]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${x.setByOffset("outputIndex",`${a==="mean"?`bestValue / ${x.type.storage}(uniforms.reduceSize)`:`${al[a]}`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:s,dataType:n}],dispatchGroup:{x:o},programUniforms:[{type:"uint32",data:m}]})}},et=(e,t,r,a)=>{let n=e.inputs.length===1?r:Rn(e.inputs,r),s=n.axes;s.length===0&&!n.noopWithEmptyAxes&&(s=e.inputs[0].dims.map((y,$)=>$));let u=M.normalizeAxes(s,e.inputs[0].dims.length),d=u,o=e.inputs[0],m=dl(d,e.inputs[0].dims.length);m.length>0&&(o=e.compute(gt(e.inputs[0],m),{inputs:[0],outputs:[-1]})[0],d=il(d.length,o.dims.length));let[g,x]=sl(o.dims,d),b=g;n.keepDims&&(b=ul(g,u)),e.compute(cl(t,{hint:n.cacheKey,inputDependencies:["type"]},[o],a,e.inputs[0].dataType,b,x),{inputs:[o]})},ca=(e,t)=>{et(e,"ReduceMeanShared",t,"mean")},pa=(e,t)=>{et(e,"ReduceL1Shared",t,"l1")},fa=(e,t)=>{et(e,"ReduceL2Shared",t,"l2")},ma=(e,t)=>{et(e,"ReduceLogSumExpShared",t,"logSumExp")},ha=(e,t)=>{et(e,"ReduceMaxShared",t,"max")},ga=(e,t)=>{et(e,"ReduceMinShared",t,"min")},ya=(e,t)=>{et(e,"ReduceProdShared",t,"prod")},ba=(e,t)=>{et(e,"ReduceSumShared",t,"sum")},wa=(e,t)=>{et(e,"ReduceSumSquareShared",t,"sumSquare")},va=(e,t)=>{et(e,"ReduceLogSumShared",t,"logSum")}});var tt,pl,Fr,Rn,rt,fl,ml,hl,gl,yl,bl,wl,vl,$l,xl,nt,xa,Sa,Ca,Aa,Ia,Ta,Ea,Oa,_a,Ra,Ye,Gr=L(()=>{"use strict";ge();Pe();ve();$a();tt=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},pl=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],Fr=(e,t,r,a,n,s,u=!1,d=!1)=>{let o=[],m=r[0].dims,g=M.normalizeAxes(n,r[0].dims.length),x=!d&&g.length===0;m.forEach((k,H)=>{x||g.indexOf(H)>=0?u&&o.push(1):o.push(k)});let b=[],y=F("_A",r[0].dataType,m),$=Y("output",s,o),w=a(y,$,g),S=`inputOffset = ${y.indicesToOffset("inputIndices")};`,A=`let ${S};`,_=`var ${S};`,z=w[1]===""?"":_,D=(w[1]===""?A:S)+`\n`+w[2];for(let k=0,H=0;k<r[0].dims.length;k++)x||g.indexOf(k)>=0?(u&&H++,D=`for(var j${k}: u32 = 0; j${k} < ${r[0].dims[k]}; j${k}++) {\n                ${w[2].includes("lastIndex")?`let lastIndex = j${k};`:""}\n                ${y.indicesSet("inputIndices",k,`j${k}`)}\n                ${D}\n              }`):(b.push(`${y.indicesSet("inputIndices",k,$.indicesGet("outputIndices",H))};`),H++);let W=M.size(o);return{name:e,shaderCache:t,getShaderSource:k=>`\n        ${k.declareVariables(y,$)}\n\n        ${k.mainStart()}\n          ${k.guardAgainstOutOfBoundsWorkgroupSizes(W)}\n          var inputIndices: ${y.type.indices};\n          let outputIndices = ${$.offsetToIndices("global_idx")};\n\n          ${b.join(`\n`)}\n          ${w[0]}       // init ops for reduce max/min\n          ${z}\n          ${w[1]}\n          ${D}\n          ${w[3]}\n          ${w.length===4?$.setByOffset("global_idx","value"):w.slice(4).join(`\n`)}\n        }`,getRunData:()=>({outputs:[{dims:o,dataType:s}],dispatchGroup:{x:Math.ceil(W/64)}})}},Rn=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(a=>r.push(Number(a))),se({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},rt=(e,t,r,a)=>{let n=e.inputs,s=n.length===1?r:Rn(n,r);e.compute(Fr(t,{hint:s.cacheKey},[n[0]],s.noopWithEmptyAxes&&s.axes.length===0?pl:a,s.axes,n[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},fl=(e,t)=>{tt(e.inputs),rt(e,"ReduceLogSum",t,(a,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${a.getByOffset("inputOffset")};`,"value = log(value);"])},ml=(e,t)=>{tt(e.inputs),rt(e,"ReduceL1",t,(a,n)=>[`var value = ${n.type.storage}(0);`,"",`value += abs(${a.getByOffset("inputOffset")});`,""])},hl=(e,t)=>{tt(e.inputs),rt(e,"ReduceL2",t,(a,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${a.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},gl=(e,t)=>{tt(e.inputs),rt(e,"ReduceLogSumExp",t,(a,n)=>[`var value = ${n.type.storage}(0);`,"",`value += exp(${a.getByOffset("inputOffset")});`,"value = log(value);"])},yl=(e,t)=>{tt(e.inputs),rt(e,"ReduceMax",t,(a,n,s)=>{let u=[];for(let d=0;d<a.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(a.indicesSet("inputIndices",d,0));return[`${u.join(`\n`)}`,`var value = ${a.getByOffset("inputOffset")};`,`value = max(value, ${a.getByOffset("inputOffset")});`,""]})},bl=(e,t)=>{tt(e.inputs),rt(e,"ReduceMean",t,(a,n,s)=>{let u=1;for(let d=0;d<a.rank;d++)(s.indexOf(d)>=0||s.length===0)&&(u*=e.inputs[0].dims[d]);return["var sum = f32(0);","",`sum += f32(${a.getByOffset("inputOffset")});`,`let value = ${n.type.value}(sum / ${u});`]})},wl=(e,t)=>{tt(e.inputs),rt(e,"ReduceMin",t,(a,n,s)=>{let u=[];for(let d=0;d<a.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(`inputIndices[${d}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${a.getByOffset("inputOffset")};`,`value = min(value, ${a.getByOffset("inputOffset")});`,""]})},vl=(e,t)=>{tt(e.inputs),rt(e,"ReduceProd",t,(a,n)=>[`var value = ${n.type.storage}(1);`,"",`value *= ${a.getByOffset("inputOffset")};`,""])},$l=(e,t)=>{tt(e.inputs),rt(e,"ReduceSum",t,(a,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${a.getByOffset("inputOffset")};`,""])},xl=(e,t)=>{tt(e.inputs),rt(e,"ReduceSumSquare",t,(a,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${a.getByOffset("inputOffset")}; value += t * t;`,""])},nt=(e,t,r)=>{if(t.length===0)return!!r;let a=1,n=1;for(let s=0;s<t.length;s++)t.indexOf(s)===-1?a*=e[s]:n*=e[s];return n<32&&a>1024},xa=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?bl(e,t):ca(e,t)},Sa=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ml(e,t):pa(e,t)},Ca=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?hl(e,t):fa(e,t)},Aa=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?gl(e,t):ma(e,t)},Ia=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?yl(e,t):ha(e,t)},Ta=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?wl(e,t):ga(e,t)},Ea=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?vl(e,t):ya(e,t)},Oa=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?$l(e,t):ba(e,t)},_a=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?xl(e,t):wa(e,t)},Ra=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?fl(e,t):va(e,t)},Ye=e=>se(e)});var Pa,Ba,Ma,ka,Pn,Da=L(()=>{"use strict";De();Pe();Gr();Pa=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},Ba=(e,t)=>se({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}),Ma=(e,t)=>{Pa(e.inputs);let r=(n,s,u)=>{let d=[];for(let o=0;o<n.rank;o++)(u.indexOf(o)>=0||u.length===0)&&d.push(`inputIndices[${o}] = 0;`);return[`${d.join(`\n`)}`,`var value = ${n.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${n.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${n.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",s.setByOffset("global_idx","bestIndex")]},a=e.inputs.length===1?t:Ba(e.inputs,t);e.compute(Fr("ArgMin",{hint:a.cacheKey},[e.inputs[0]],r,[a.axis],7,a.keepDims),{inputs:[0]})},ka=(e,t)=>{Pa(e.inputs);let r=(n,s,u)=>{let d=[];for(let o=0;o<n.rank;o++)(u.indexOf(o)>=0||u.length===0)&&d.push(`inputIndices[${o}] = 0;`);return[`${d.join(`\n`)}`,`var value = ${n.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${n.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${n.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",s.setByOffset("global_idx","bestIndex")]},a=e.inputs.length===1?t:Ba(e.inputs,t);e.compute(Fr("argMax",{hint:a.cacheKey},[e.inputs[0]],r,[a.axis],7,a.keepDims),{inputs:[0]})},Pn=e=>se(e)});var Sl,Cl,Wa,za=L(()=>{"use strict";ge();ve();Sl=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Cl=e=>{let t=e[0].dims,r=e[0].dims[2],a=M.size(t)/4,n=e[0].dataType,s=F("input",n,t,4),u=F("bias",n,[r],4),d=F("residual",n,t,4),o=Y("output",n,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:g=>`\n  const channels = ${r}u / 4;\n  ${g.declareVariables(s,u,d,o)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let value = ${s.getByOffset("global_idx")}\n      + ${u.getByOffset("global_idx % channels")} + ${d.getByOffset("global_idx")};\n    ${o.setByOffset("global_idx","value")}\n  }`}},Wa=e=>{Sl(e.inputs),e.compute(Cl(e.inputs))}});var Al,$e,Na,Va,Ua,Ga,Fa,La,Ha,ja,Ka,Bn,Il,qa,Ya,Xa,Ja,Lr,Za,Hr,Qa,ei,ti,ri,ni,oi,ai,ii,si,ui,li,di,ci,pi,fi,mi,hi,Mn=L(()=>{"use strict";De();ge();Pe();ve();Al=(e,t,r,a,n,s)=>{let u=Math.ceil(t/4),d="";typeof n=="string"?d=`${n}(a)`:d=n("a");let o=F("inputData",r,[u],4),m=Y("outputData",a,[u],4);return`\n      ${e.registerUniform("vec_size","u32").declareVariables(o,m)}\n\n  ${s??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${o.getByOffset("global_idx")};\n    ${m.setByOffset("global_idx",d)}\n  }`},$e=(e,t,r,a,n,s=e.dataType)=>({name:t,shaderCache:{hint:n,inputDependencies:["type"]},getShaderSource:u=>Al(u,M.size(e.dims),e.dataType,s,r,a),getRunData:u=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(M.size(u[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(M.size(e.dims)/4)}]})}),Na=e=>{e.compute($e(e.inputs[0],"Abs","abs"))},Va=e=>{e.compute($e(e.inputs[0],"Acos","acos"))},Ua=e=>{e.compute($e(e.inputs[0],"Acosh","acosh"))},Ga=e=>{e.compute($e(e.inputs[0],"Asin","asin"))},Fa=e=>{e.compute($e(e.inputs[0],"Asinh","asinh"))},La=e=>{e.compute($e(e.inputs[0],"Atan","atan"))},Ha=e=>{e.compute($e(e.inputs[0],"Atanh","atanh"))},ja=e=>se(e),Ka=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute($e(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},Bn=(e,t)=>{let r=Be(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Clip",a=>`clamp(${a}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${r}> = vec4(${r}(${t.min}));\n    const clip_max_: vec4<${r}> = vec4(${r}(${t.max}));\n`,t.cacheKey),{inputs:[0]})},Il=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:Vr,r=e.length>=3?e[2].getFloat32Array()[0]:Ur;return se({min:t,max:r})},qa=e=>{let t=Il(e.inputs);Bn(e,t)},Ya=e=>{e.compute($e(e.inputs[0],"Ceil","ceil"))},Xa=e=>{e.compute($e(e.inputs[0],"Cos","cos"))},Ja=e=>{e.compute($e(e.inputs[0],"Cosh","cosh"))},Lr=e=>se(e),Za=(e,t)=>{e.compute($e(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`\n  const elu_alpha_: f32 = f32(${t.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Hr=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,Qa=e=>{let t=Be(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,Hr(`vec4<${t}>`,t)))},ei=e=>{e.compute($e(e.inputs[0],"Exp","exp"))},ti=e=>{e.compute($e(e.inputs[0],"Floor","floor"))},ri=e=>{let t=Be(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Hr(`vec4<${t}>`,t)))},ni=(e,t)=>{e.compute($e(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},oi=e=>{e.compute($e(e.inputs[0],"Not",t=>`!${t}`))},ai=e=>{e.compute($e(e.inputs[0],"Neg",t=>`-${t}`))},ii=e=>{e.compute($e(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},si=e=>{e.compute($e(e.inputs[0],"Relu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > vec4<f32>(0.0))`))},ui=e=>{e.compute($e(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},li=e=>{e.compute($e(e.inputs[0],"Sin","sin"))},di=e=>{e.compute($e(e.inputs[0],"Sinh","sinh"))},ci=e=>{e.compute($e(e.inputs[0],"Sqrt","sqrt"))},pi=e=>{e.compute($e(e.inputs[0],"Tan","tan"))},fi=e=>{e.compute($e(e.inputs[0],"Tanh","tanh"))},mi=(e,t)=>(e.compute($e(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),hi=e=>{e.compute($e(e.inputs[0],"Log","log"))}});var El,Ol,gi,yi=L(()=>{"use strict";ge();ve();Mn();El=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Ol=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=F("input",e[0].dataType,e[0].dims,4),a=F("bias",e[0].dataType,[e[0].dims[2]],4),n=Y("output",e[0].dataType,t,4),s=M.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:d=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${d.declareVariables(r,a,n)}\n\n  ${Hr("vec4f")}\n\n  ${d.mainStart()}\n    ${d.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${n.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},gi=e=>{El(e.inputs),e.compute(Ol(e.inputs))}});var _l,Rl,ot,bi,wi,vi,$i,xi,Si,Ci,Ai,Ii,Ti,Ei=L(()=>{"use strict";De();ge();ve();_l=(e,t,r,a,n,s,u,d,o,m,g,x)=>{let b,y;typeof u=="string"?b=y=(W,P)=>`${u}((${W}),(${P}))`:typeof u=="function"?b=y=u:(b=u.scalar,y=u.vector);let $=g?t.length:t,w=g?r.length:r,S=g?a.length:a,A=Y("outputData",m,S,4),_=F("aData",d,$,4),z=F("bData",o,w,4),D;if(n)if(s){let W=M.size(t)===1,P=M.size(r)===1;W||P?D=A.setByOffset("global_idx",y(W?`${_.type.value}(${_.getByOffset("0")}.x)`:_.getByOffset("global_idx"),P?`${z.type.value}(${z.getByOffset("0")}.x)`:z.getByOffset("global_idx"))):D=`\n            let outputIndices = ${A.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${_.broadcastedIndicesToOffset("outputIndices",A)};\n            let offsetB = ${z.broadcastedIndicesToOffset("outputIndices",A)};\n            ${A.setByOffset("global_idx",y(_.getByOffset("offsetA / 4u"),z.getByOffset("offsetB / 4u")))}\n          `}else D=A.setByOffset("global_idx",y(_.getByOffset("global_idx"),z.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let W=(P,k,H="")=>{let X=`aData[indexA${k}][componentA${k}]`,le=`bData[indexB${k}][componentB${k}]`;return`\n            let outputIndices${k} = ${A.offsetToIndices(`global_idx * 4u + ${k}u`)};\n            let offsetA${k} = ${_.broadcastedIndicesToOffset(`outputIndices${k}`,A)};\n            let offsetB${k} = ${z.broadcastedIndicesToOffset(`outputIndices${k}`,A)};\n            let indexA${k} = offsetA${k} / 4u;\n            let indexB${k} = offsetB${k} / 4u;\n            let componentA${k} = offsetA${k} % 4u;\n            let componentB${k} = offsetB${k} % 4u;\n            ${P}[${k}] = ${H}(${b(X,le)});\n          `};m===9?D=`\n            var data = vec4<u32>(0);\n            ${W("data",0,"u32")}\n            ${W("data",1,"u32")}\n            ${W("data",2,"u32")}\n            ${W("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:D=`\n            ${W("outputData[global_idx]",0)}\n            ${W("outputData[global_idx]",1)}\n            ${W("outputData[global_idx]",2)}\n            ${W("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(_,z,A)}\n\n        ${x??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${D}\n      }`},Rl=(e,t,r,a,n,s,u=r.dataType)=>{let d=!M.areEqual(r.dims,a.dims),o=r.dims,m=M.size(r.dims),g=!1,x=[d];if(d){let y=Qe.calcShape(r.dims,a.dims,!1);if(!y)throw new Error("Can\'t perform binary op on the given tensors");o=y,m=M.size(o);let $=M.size(r.dims)===1,w=M.size(a.dims)===1;x.push($),x.push(w);let S=1;for(let A=1;A<o.length;A++){let _=r.dims[r.dims.length-A]??1,z=a.dims[a.dims.length-A]??1;if(_===z)S*=_;else break}(S%4===0||$||w)&&(g=!0)}else g=!0;x.push(g);let b=Wt(r.dims.length)&&Wt(a.dims.length)&&Wt(o.length);return{name:e,shaderCache:{hint:t+x.map(y=>y.toString()).join("_"),inputDependencies:b?["rank","rank"]:[r.dims.length>0?"dims":"type",a.dims.length>0?"dims":"type"]},getShaderSource:y=>_l(y,r.dims,a.dims,o,g,d,n,r.dataType,a.dataType,u,b,s),getRunData:()=>({outputs:[{dims:o,dataType:u}],dispatchGroup:{x:Math.ceil(m/64/4)},programUniforms:b?[{type:"uint32",data:Math.ceil(M.size(o)/4)},...Tt(r.dims),...Tt(a.dims),...Tt(o)]:[{type:"uint32",data:Math.ceil(M.size(o)/4)}]})}},ot=(e,t,r,a,n,s)=>{e.compute(Rl(t,n??"",e.inputs[0],e.inputs[1],r,a,s))},bi=e=>{ot(e,"Add",(t,r)=>`${t}+${r}`)},wi=e=>{ot(e,"Div",(t,r)=>`${t}/${r}`)},vi=e=>{ot(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},$i=e=>{ot(e,"Mul",(t,r)=>`${t}*${r}`)},xi=e=>{let t=F("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;ot(e,"Pow",{scalar:(a,n)=>`pow_custom(${a},${n})`,vector:(a,n)=>`pow_vector_custom(${a},${n})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Si=e=>{ot(e,"Sub",(t,r)=>`${t}-${r}`)},Ci=e=>{ot(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},Ai=e=>{ot(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Ii=e=>{ot(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Ti=e=>{ot(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var Bl,Ml,kl,Dl,Oi,_i,Ri=L(()=>{"use strict";ge();Pe();ve();Bl=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let a of e){if(a.dataType!==t)throw new Error("input tensors should be one type");if(a.dims.length!==r)throw new Error("input tensors should have the same shape")}},Ml=e=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,kl=(e,t)=>{let r=e.length,a=[];for(let n=0;n<r;++n){let s=t.setByOffset("global_idx",e[n].getByIndices("indices"));r===1?a.push(s):n===0?a.push(`if (inputIndex == ${n}u) { ${s} }`):n===r-1?a.push(`else { ${s} }`):a.push(`else if (inputIndex == ${n}) { ${s} }`)}return a.join(`\n`)},Dl=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let a=t<0?r.length+t:t,n=r.slice(0);for(let y=1;y<e.length;y++){let $=e[y].dims.slice();for(let w=0;w<r.length;w++)if(w===a)n[a]+=$[w];else if(r[w]!==$[w])throw new Error("non concat dimensions must match")}let s=M.size(n),u=new Array(e.length),d=new Array(e.length),o=e[0].dataType,m=0;for(let y=0;y<e.length;++y)m+=e[y].dims[a],u[y]=m,d[y]=F(`input${y}`,o,e[y].dims);let g=Y("output",o,n),x=g.indicesGet("indices",a),b=y=>`\n  ${y.declareVariables(...d,g)}\n\n  const sizeInConcatAxis = array<u32, ${u.length}>(${u.map($=>`${$}u`).join(",")});\n  ${Ml(u.length)}\n\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n\n    var indices = ${g.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${x});\n    if (inputIndex != 0u) {\n      ${x} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${kl(d,g)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:b}},Oi=(e,t)=>{Bl(e.inputs),e.compute(Dl(e.inputs,t.axis))},_i=e=>se({axis:e.axis})});var We,jr,Kr,qr=L(()=>{"use strict";We=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},jr=(e,t=!1,r=!1,a=3)=>"",Kr=(e,t)=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      // TODO uncomment the following line when activation is supported above.\n      // ${t?"value = activation(value, coords);":""}\n      `});var Yr,kn=L(()=>{"use strict";Yr=`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n`});var Xr,Jr,sr=L(()=>{"use strict";ge();Xr=(e,t=!1)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:t?"value = max(value, vec4(0.0));":"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:t?"value = clamp(value, vec4(clip_min_), vec4(clip_max_));":"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Jr=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,a]=e?.activation_params||[Vr,Ur];return{activation:t,clipMax:a,clipMin:r,activationCacheKey:`${t}:${r},${a}`}}return{activation:t,activationCacheKey:t}}});var Wl,zl,ur,Pi,Nl,lr,Vl,Zr,dr=L(()=>{"use strict";ge();ve();sr();qr();Wl=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,zl=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,ur=(e,t,r="f32",a,n=!1,s=32,u=!1,d=32)=>{let o=t[1]*e[1],m=t[0]*e[0],g=n?o:s,x=n?s:o,b=g/t[0],y=s/t[1];if(!((n&&b===4&&e[1]===4||!n&&(b===3||b===4))&&g%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${n} is true, innerElementSize ${b} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${b} must be 3 or 4.\n  tileAWidth ${g} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${b}<${r}>, ${g/b}>, ${x}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${m/e[0]}>, ${s}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${b};\nconst tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${u?"0":"i32(globalId.z)"};\n  ${a?`let batchIndices = ${a.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${o};\n\n  let numTiles = ${u?`${Math.ceil(d/s)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${u?`i32(globalId.z) * ${d}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${y};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${Wl(n,a)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${y}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${a?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${b===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${zl(n,b)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Pi=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,Nl=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",lr=(e,t,r="f32",a,n=!1,s=32,u=!1,d=32,o=!1)=>{let m=e[1]*t[1],g=e[0]*t[0],x=n?m:s,b=n?s:m;if(!(b%t[1]===0&&x%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${b} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${x} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let y=b/t[1],$=x/t[0],w=s/t[1],S=o?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${m};\n    let globalColStart = i32(workgroupId.x) * ${g};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${b}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${x}; inputCol = inputCol + ${t[0]}) {\n          ${Pi(n,a)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${g}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${a?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${m};\n\nlet tileRowA = i32(localId.y) * ${y};\nlet tileColA = i32(localId.x) * ${$};\nlet tileRowB = i32(localId.y) * ${w};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${y}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${$}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Pi(n,a)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${a?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${Nl(n)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${x}>, ${b}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${g}>, ${s}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${u?"0":"i32(globalId.z)"};\n    ${a?`let batchIndices = ${a.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${u?`${Math.ceil(d/s)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${u?`i32(globalId.z) * ${d}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${S}\n  }\n`},Vl=(e,t,r,a,n,s=!1)=>{let u=n[0],d=n[1],o=n[2],m=a[0],g=a[1],x=a[2],b=a[3],y=_n(u,o),$=_n(d,o),w=Be(a[0].type.tensor),S=()=>{let z=g.rank,D=m.rank,W=`var aIndices: ${g.type.indices};`;for(let P=z-2-1,k=D-1;P>=0;P--,k--)W+=`\naIndices[${P}] = ${D>1?`batchIndices[${k}]`:"batchIndices"};`;return y.forEach(P=>{W+=`\naIndices[${P}] = 0;`}),W+=`\naIndices[${z-2}] = u32(row);\n                   aIndices[${z-1}] = u32(colIn);`,W},A=()=>{let z=x.rank,D=m.rank,W=`var bIndices: ${x.type.indices};`;for(let P=z-2-1,k=D-1;P>=0;P--,k--)W+=`\nbIndices[${P}] = ${D>1?`batchIndices[${k}]`:"batchIndices"};`;return $.forEach(P=>{W+=`\nbIndices[${P}] = 0;`}),W+=`\nbIndices[${z-2}] = u32(row);\n                   bIndices[${z-1}] = u32(colIn);`,W};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${m.type.indices}) -> ${We(e,w)} {\n      var value = ${We(e,w)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimAOuter && col < dimInner)\n      {\n        ${S()}\n        value = ${g.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${m.type.indices}) -> ${We(e,w)} {\n      var value = ${We(e,w)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimInner && col < dimBOuter)\n      {\n        ${A()}\n        value = ${x.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${We(e,w)}) {\n      let col = colIn * ${e};\n      if (row < dimAOuter && col < dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${s?"bias[colIn]":`${We(e,w)}(bias[row])`};`:""}\n        ${r}\n        ${b.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Zr=(e,t,r,a,n=!1)=>{let s=e[0].dims,u=e[1].dims,d=s.slice(0,-2),o=u.slice(0,-2),m=a?a.slice(0,-2):r.slice(0,-2),g=F("batchDims",e[0].dataType,m),x=[g],b=[d,o,m],y=M.size(m),$=s[s.length-2],w=s[s.length-1],S=u[u.length-1],A=w%4===0&&S%4===0,{activationFunction:_,applyActivation:z}=Xr(t,A),D=$<=8?[4,1,1]:[4,4,1],W=[8,8,1],P=[Math.ceil(S/W[0]/D[0]),Math.ceil($/W[1]/D[1]),Math.ceil(y/W[2]/D[2])],k=Be(e[0].dataType),H=A?4:1,X=F("a",e[0].dataType,[...d,$,w/H],H),le=F("b",e[1].dataType,[...o,w,S/H],H),B=Y("result",e[0].dataType,[y,$,S/H],H);x.push(X),x.push(le),x.push(B);let K=[X,le],xe=e.length>2,ie=Vl(H,xe,z,x,b,n);if(xe){let j=n?H:1;K.push(F("bias",e[2].dataType,e[2].dims,j))}let we=j=>`\n  const dimAOuter: i32 = ${$};\n  const dimBOuter: i32 = ${S};\n  const dimInner: i32 = ${w};\n  ${j.declareVariables(...K,B)}\n  ${_}\n  ${ie}\n  ${A?ur(D,W,k,g):lr(D,W,k,g)}\n                   ${g.impl()}`;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:P[0],y:P[1],z:P[2]}}),getShaderSource:we}}});var Ul,Bi,Mi=L(()=>{"use strict";mt();ge();ve();qr();kn();dr();Ul=(e,t,r,a,n=!1,s,u=!1,d=4,o=4,m=4,g="f32")=>{let x=le=>{switch(le){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${g}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},b=le=>{switch(le){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},y=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,$=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,w=e?"xShape[1]":"xShape[2]",S=e?"xShape[2]":"xShape[3]",A=e?"row":"col",_=e?"col":"row",z=`\n    let inChannels = wShape[2];\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\n    let outRow = ${A} / outWidth;\n    let outCol = ${A} % outWidth;\n\n    let WRow = ${_} / (filterDims[1] * inChannels);\n    let WCol = ${_} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${_} % inChannels;\n    var resData = ${We(d,g)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${w} && xCol >= 0 && xCol < ${S}) {\n      ${y}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${x(d)}\n    }\n    return resData;`,D=e?t&&a?`\n    let col = colIn * ${d};\n    ${z}`:`\n    let col = colIn * ${d};\n    if (row < dimAOuter && col < dimInner) {\n      ${z}\n    }\n    return ${We(d,g)}(0.0);`:a&&r?`\n    let col = colIn * ${d};\n    ${z}`:`\n    let col = colIn * ${d};\n    if (row < dimInner && col < dimBOuter) {\n      ${z}\n    }\n    return ${We(d,g)}(0.0);`,W=`${b(o)}`,P=We(m,g),k=e?We(d,g):We(o,g),H=e?We(o,g):We(d,g);return`\n    ${jr(s,u,m===4,4)}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${k} {\n      ${e?D:W}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${H} {\n      ${e?W:D}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${P}) {\n      let col = colIn * ${m};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${$}\n      ${Kr(n,s)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Bi=(e,t,r,a,n,s,u,d)=>{let o=t.format==="NHWC",m=o?e[0].dims[3]:e[0].dims[1],g=r[0],x=o?r[2]:r[3],b=o?r[1]:r[2],y=o?r[3]:r[1],$=o&&(m%4===0||m%3===0)&&y%4===0,w=o?y:x*b,S=o?x*b:y,A=[8,8,1],_=a<=8?[4,1,1]:[4,4,1],z=[Math.ceil(w/A[0]/_[0]),Math.ceil(S/A[1]/_[1]),Math.ceil(g/A[2]/_[2])];Te("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${z}`);let D=$?o&&m%4!==0?3:4:_[0],W=A[1]*_[1],P=A[0]*_[0],k=Math.max(A[0]*D,A[1]),H=a%W===0,X=n%P===0,le=s%k===0,B=$?[D,4,4]:[1,1,1],K=Be(e[0].dataType),xe=[`@group(0) @binding(0) var<storage, read> x: array<${$&&D===4?`vec4<${K}>`:K}>;`,`@group(0) @binding(1) var<storage, read> w: array<${$?`vec4<${K}>`:K}>;`],ie=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${$?`vec4<${K}>`:K}) {\n        result[flatIndex] = ${$?`vec4<${K}>`:K}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${$?`vec4<${K}>`:K}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${$?"/ 4":""}, value);\n      }`;return u&&(xe.push(`@group(0) @binding(2) var<storage, read> bias: array<${$?`vec4<${K}>`:K}>;`),ie+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${$?`vec4<${K}>`:K} {\n          return bias[coords.${o?"w":"y"}${$?"/ 4":""}];\n        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:z[0],y:z[1],z:z[2]}}),getShaderSource:()=>`\n        ${Yr}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${xe.join("")}\n        @group(0) @binding(${xe.length}) var<storage, read_write> result: array<${$?`vec4<${K}>`:K}>;\n        //@group(0) @binding(${xe.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${M.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${a};\n        const dimBOuter : i32 = ${n};\n        const dimInner : i32 = ${s};\n        ${ie}\n        ${Ul(o,H,X,le,u,t.activation.toLowerCase(),!1,B[0],B[1],B[2],K)}\n            ${$?ur(_,A,K,void 0,!o,k):lr(_,A,K,void 0,!o,k,!1,void 0,d)}`}}});var Dn,ki=L(()=>{"use strict";ge();ve();zn();sr();Dn=(e,t,r)=>{let a=e.length>2,n=a?"value += b[output_channel];":"",s=e[0].dims,u=e[1].dims,d=u[0]/t.group,{activationFunction:o,applyActivation:m}=Xr(t),g=t.format==="NHWC",x=Wn(s,u,t.dilations,t.pads,t.strides,g),b=M.size(x),y=Y("output",e[0].dataType,x),$=F("x",e[0].dataType,s),w=F("w",e[1].dataType,u),S=[$,w];a&&S.push(F("b",e[2].dataType,e[2].dims));let A=_=>`\n  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);\n  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);\n\n  ${_.declareVariables(...S,y)}\n\n  ${o}\n\n  ${_.mainStart()}\n    ${_.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n    let outputIndices = ${y.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${g?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${g?1:2}], outputIndices[${g?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${d}u;\n\n    var value: ${y.type.value} = ${y.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${u[1]}u; wInChannel++) {\n      let input_channel = group_id * ${u[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${u[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${s[g?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${u[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${s[g?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${g?$.get("batch","xHeight","xWidth","input_channel"):$.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${w.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${n}\n    ${m}\n    ${y.setByOffset("global_idx","value")}\n  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(x):x,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)}}),getShaderSource:A}}});var Wn,Di,Gl,Wi,Nn,Fl,Ll,Vn,zn=L(()=>{"use strict";ge();Pe();Mi();dr();ki();sr();ir();Wn=(e,t,r,a,n,s)=>{let u=e[0],d=e.slice(s?1:2,s?3:4),o=d.length,m=t[0],x=t.slice(2).map(($,w)=>$+($-1)*(r[w]-1)),y=d.map(($,w)=>$+a[w]+a[w+o]).map(($,w)=>Math.floor(($-x[w]+n[w])/n[w]));return y.splice(0,0,u),y.splice(s?3:1,0,m),y},Di=[2,3,1,0],Gl=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],a=e[1].dims[1]*t.group;if(r!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Wi=(e,t)=>{let r=e.kernelShape.slice();for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let a=e.pads.slice();It.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,a,e.format==="NHWC",e.autoPad);let n=Object.assign({},e);return Object.assign(n,{kernelShape:r,pads:a,cacheKey:e.cacheKey}),n},Nn=e=>{let t=Jr(e),r=e.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],n=e.dilations,s=e.group,u=e.kernel_shape,d=e.pads,o=e.strides,m=e.w_is_const();return se({autoPad:a,format:r,dilations:n,group:s,kernelShape:u,pads:d,strides:o,wIsConst:m,...t})},Fl=(e,t,r)=>{let a=Wi(r,t);if(r.group!==1){e.compute(Dn(t,a));return}let n=r.format==="NHWC",s=t.length===3,u=t[0].dims[n?1:2],d=t[0].dims[n?2:3],o=t[0].dims[n?3:1],m=t[1].dims[2],g=t[1].dims[3],x=Wn(t[0].dims,t[1].dims,r.dilations,a.pads,r.strides,n),b=x[n?1:2],y=x[n?2:3],$=x[n?3:1],w=n&&m===u&&g===d&&r.pads[0]===0&&r.pads[1]===0;if(w||m===1&&g===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let P=x[0],k,H,X,le=[];if(n){let B=e.kernelCustomData.wT??e.compute(gt(t[1],Di),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=B),w){let K=u*d*o;k=t[0].reshape([1,P,K]),H=B.reshape([1,K,$]),X=[1,P,$]}else k=t[0].reshape([P,u*d,o]),H=B.reshape([1,o,$]),X=[P,b*y,$];le.push(k),le.push(H)}else k=t[0].reshape([P,o,u*d]),H=t[1].reshape([1,$,o]),X=[P,$,b*y],le.push(H),le.push(k);s&&le.push(t[2]),e.compute(Zr(le,a,x,X,n),{inputs:le});return}let S=!0,A=e.kernelCustomData.wT??e.compute(gt(t[1],Di),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);let _=[t[0],A];s&&_.push(t[2]);let z=n?b*y:$,D=n?$:b*y,W=m*g*o;e.compute(Bi(_,a,x,z,D,W,s,S),{inputs:_})},Ll=(e,t)=>{let r=t.format==="NHWC",a=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&a.push(e.inputs[2]);let n=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),u=[1].concat(t.dilations),d=[1].concat(t.kernelShape),o=Wi({...t,pads:n,strides:s,dilations:u,kernelShape:d},a);e.compute(Dn(a,o,m=>r?[m[0],m[2],m[3]]:[]))},Vn=(e,t)=>{Gl(e.inputs,t),e.inputs[0].dims.length===3?Ll(e,t):Fl(e,e.inputs,t)}});var Hl,zi,Ni=L(()=>{"use strict";mt();ge();qr();kn();dr();Hl=(e,t=!1,r,a=!1,n=4)=>{let s=We(n,"f32"),u=A=>{switch(A){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${A} is not supported.`)}},d=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,o=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,m=e?"outBackprop[1]":"outBackprop[2]",g=e?"outBackprop[2]":"outBackprop[3]",x=e?"row":"col",b=e?"col":"row",y=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      let outRow = ${x} / outWidth;\n      let outCol = ${x} % outWidth;\n\n      let WRow = ${b} / (filterDims[1] * inChannels);\n      let WCol = ${b} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${m}) || fract(xR) > 0.0) {\n        return ${s}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${g}) || fract(xC) > 0.0) {\n        return ${s}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${b} % inChannels;\n      ${d}\n      return x[getIndexFromCoords4D(coord, xShape)/${n}];`,$=e?`\n      let col = colIn * ${n};\n      if (row < dimAOuter && col < dimInner) {\n        ${y}\n      }\n      return ${s}(0.0);`:`\n      let col = colIn * ${n};\n      if (row < dimInner && col < dimBOuter) {\n        ${y}\n      }\n      return ${s}(0.0);`,w=`\n      let col = colIn * ${n};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${u(n)}\n      }\n      return ${s}(0.0);\n      `;return`\n  ${jr(r,a,n===4,4)}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${s} {\n    ${e?$:w}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${s} {\n    ${e?w:$}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${s}) {\n    let col = colIn * ${n};\n    if (row < dimAOuter && col < dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${o}\n      ${Kr(t,r)}\n      result[getIndexFromCoords4D(coords, outShape)/${n}] = value;\n    }\n  }`},zi=(e,t,r,a,n,s,u,d)=>{let o=t.format==="NHWC",m=o?e[0].dims[3]:e[0].dims[1],g=r[0],x=o?r[2]:r[3],b=o?r[1]:r[2],y=o?r[3]:r[1],$=o?m%4===0&&y%4===0:x%4===0&&y%4===0,w=o?y:x*b,S=o?x*b:y,A=$?[8,8,1]:[w<=4||S<=4?4:16,w>4&&S<=4?4:16,1],_=$?[4,4,1]:[w<=4?1:4,w>4&&S<=4?1:4,1],z=[Math.ceil(w/A[0]/_[0]),Math.ceil(S/A[1]/_[1]),Math.ceil(g/A[2]/_[2])];Te("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${z}`);let D=$?4:1,W=Math.max(A[0]*D,A[1]),P=[`@group(0) @binding(0) var<storage, read> x: array<${$?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],k="";return u&&(P.push(`@group(0) @binding(2) var<storage, read> bias: array<${$?"vec4<f32>":"f32"}>;`),k+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${$?"vec4<f32>":"f32"} {\n          return bias[coords.${o?"w":"y"}${$?"/ 4":""}];\n        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:z[0],y:z[1],z:z[2]}}),getShaderSource:()=>`\n        ${Yr}\n        ${P.join(`\n`)}\n        @group(0) @binding(${P.length}) var<storage, read_write> result: array<${$?"vec4<f32>":"f32"}>;\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${M.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[o?1:2]}, ${t.kernelShape[o?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${t.dilations[0]<=1?0:(t.kernelShape[o?1:2]-1)*(t.dilations[0]-1)},\n              ${t.dilations[1]<=1?0:(t.kernelShape[o?2:3]-1)*(t.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${a};\n        const dimBOuter : i32 = ${n};\n        const dimInner : i32 = ${s};\n        ${k}\n        ${Hl(o,u,t.activation.toLowerCase(),!1,D)}\n        ${$?ur(_,A,"f32",void 0,!o,W):lr(_,A,"f32",void 0,!o,W,!1,void 0,d)}`}}});var jl,Un,Vi=L(()=>{"use strict";mt();ge();ve();jl=(e,t,r,a,n,s,u=!1,d)=>{let o=r.format==="NHWC",m=o?1:2,g=o?2:3,x=o?3:1,b=M.size(a),y=u?2:1,$=r.group,w=t[1].dims,S=w[0]/$,A=w[1],_=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${d}>`:d}) {\n    result[flatIndex] = ${u?`vec4<${d}>`:d}(value);\n  }`;n&&(_+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${d}>`:d} {\n      return bias[coords.${o?"w":"y"}${u?"/ 4":""}];\n    }`);let z=u?4:1,D=F("W",t[1].dataType,t[1].dims,z),W=F("Dy",t[0].dataType,t[0].dims,z),P=[W,D];n&&P.push(F("bias",t[2].dataType,[a[x]],z));let k=Y("result",t[0].dataType,a,z),H=`{\n        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${s?"global_id.y":"workgroup_id.y"} * ${y};\n        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${d}>, ${y}>;\n        for (var i = 0; i < ${y}; i++) {\n          dotProd[i] = vec4<${d}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${d}(dyCorner.x) + ${d}(wR)) / ${d}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${d}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${d}(dyCorner.y) + ${d}(wC)) / ${d}(strides.y);\n            let dyC2 = (${d}(dyCorner.y) + 1.0 + ${d}(wC)) / ${d}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${d}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${d}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${W.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${W.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${d}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${x}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${W.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${W.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${y}; i = i + 1) {\n          let value = dotProd[i] + ${n?"bias[c+i]":"0.0"};\n          ${k.set("batch","r","c + i","d1","value")};\n        }\n      }`,X=`\n          let outputIndices = ${k.offsetToIndices("global_idx")};\n          let batch = ${k.indicesGet("outputIndices",0)};\n          let d1 = ${k.indicesGet("outputIndices",x)};\n          let r = ${k.indicesGet("outputIndices",m)};\n          let c = ${k.indicesGet("outputIndices",g)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${A};\n          let wOutChannel = d1 - groupId * ${A};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${d}(dyRCorner) + ${d}(wR)) / ${d}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${d}(outBackprop[${m}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${d}(dyCCorner) + ${d}(wC)) / ${d}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${d}(outBackprop[${g}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${S};\n              for (var d2: u32 = 0; d2 < ${S}; d2 = d2 + 1) {\n                let xValue = ${o?W.get("batch","idyR","idyC","inputChannel"):W.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${D.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${n?"bias[d1]":"0.0"};\n          ${k.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(...P,k)}\n  ${_}\n  const outShape : vec4<u32> = vec4<u32>(${a.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[o?1:2]}, ${r.kernelShape[o?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${r.dilations[0]<=1?0:(r.kernelShape[o?1:2]-1)*(r.dilations[0]-1)},\n          ${r.dilations[1]<=1?0:(r.kernelShape[o?2:3]-1)*(r.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)};\n  ${u?H:X}}`},Un=(e,t,r)=>{let a=e.length>2,n=t.outputShape,s=M.size(n),u=[Math.ceil(s/64),1,1];Te("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${u}`);let d=Be(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:u[0],y:u[1],z:u[2]},outputs:[{dims:r?r(n):n,dataType:e[0].dataType}]}),getShaderSource:o=>jl(o,e,t,n,a,u[1]===1&&u[2]===1,!1,d)}}});var Kl,ql,Yl,Ui,Gi,Xl,Jl,Zl,Ql,Fi,Li=L(()=>{"use strict";Pe();Ni();Vi();sr();ir();Kl=(e,t,r,a,n,s)=>(e-1)*t+r+(a-1)*n+1-s,ql=(e,t,r,a,n)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[a]=s,r[n]=e-s):t==="SAME_LOWER"&&(r[a]=e-s,r[n]=s)},Yl=(e,t,r,a,n,s,u,d,o,m)=>{let g=e.length-2,x=m.length===0;if(o.length===0)for(let $=0;$<g;++$)o.push(0);let b=e[0],y=t[d?3:1]*n;for(let $=0,w=e.length-g-(d?1:0);$<g;++$,++w){let S=e[w],A=x?S*u[$]:m[$],_=Kl(S,u[$],s[$],t[w],r[$],A);ql(_,a,s,$,$+g),x&&m.push(u[$]*(S-1)+o[$]+(t[w]-1)*r[$]+1-s[$]-s[$+g])}m.splice(0,0,b),m.splice(d?3:1,0,y)},Ui=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((b,y)=>b*y,1)===0){r.length=0;for(let b=2;b<t[1].dims.length;++b)r.push(t[1].dims[b])}let a=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(a?3:1,0,t[1].dims[1]);let n=e.pads.slice(),s=e.outputShape.slice(),u=e.outputPadding.slice(),d=t[0].dims,o=e.dilations.slice();if(o.reduce((b,y)=>b+y,0)===0){let b=t[0].dims.length-2;o=new Array(b).fill(1)}let m=e.strides.slice();if(m.reduce((b,y)=>b+y,0)===0){let b=t[0].dims.length-2;m=new Array(b).fill(1)}Yl(d,r,o,e.autoPad,e.group,n,m,a,u,s);let g=Object.assign({},e),x=e.cacheKey+[r.join("n,"),n.join(","),m.join(","),u.join(","),s.join(","),o.join(",")].join("_");return Object.assign(g,{kernelShape:r,pads:n,outputPadding:u,outputShape:s,dilations:o,strides:m,cacheKey:x}),g},Gi=e=>{let t=Jr(e),r=e.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],n=e.dilations,s=e.group,u=e.kernelShape,d=e.pads,o=e.strides,m=e.wIsConst(),g=e.outputPadding,x=e.outputShape;return se({autoPad:a,format:r,dilations:n,group:s,kernelShape:u,outputPadding:g,outputShape:x,pads:d,strides:o,wIsConst:m,...t})},Xl=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],a=e[1].dims[0];if(r!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==n))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((g,x)=>g+x,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((g,x)=>g+x,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((g,x)=>g+x,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((g,x)=>g+x,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Jl=[2,3,1,0],Zl=(e,t,r)=>{let a=Ui(r,t),n=r.format==="NHWC",s=t.length===3;if(a.group!==1){e.compute(Un(t,a));return}let u=a.outputShape,d=u[n?1:2],o=u[n?2:3],m=u[n?3:1],g=t[1].dims[2],x=t[1].dims[3],b=t[0].dims[n?3:1],y=n?d*o:m,$=n?m:d*o,w=g*x*b,S=!0,A=e.kernelCustomData.wT??e.compute(gt(t[1],Jl),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);let _=[t[0],A];s&&(!n&&t[2].dims.length===1?_.push(t[2].reshape([t[2].dims[0],1,1])):_.push(t[2])),e.compute(zi(_,a,u,y,$,w,s,S),{inputs:_})},Ql=(e,t)=>{let r=t.format==="NHWC",a=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];a.length===3&&a.push(e.inputs[2]);let n=t.kernelShape;(n.length===0||n[0]===0)&&(n=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let u=t.strides;(u.length===0||u[0]===0)&&(u=[1]);let d=t.pads;d.length===0&&(d=[0,0]),d=[0,d[0],0,d[1]],u=[1].concat(u),s=[1].concat(s),n=[1].concat(n);let o=Ui({...t,pads:d,strides:u,dilations:s,kernelShape:n},a);e.compute(Un(a,o,m=>r?[m[0],m[2],m[3]]:[m[0],m[1],m[3]]))},Fi=(e,t)=>{Xl(e.inputs,t),e.inputs[0].dims.length===3?Ql(e,t):Zl(e,e.inputs,t)}});var Gn,Qr,Hi,ed,td,Fn,Ln,rd,ji,Ki,qi=L(()=>{"use strict";ge();Pe();ve();Gn="[a-zA-Z]|\\\\.\\\\.\\\\.",Qr="("+Gn+")+",Hi="^"+Qr+"$",ed="("+Qr+",)*"+Qr,td="^"+ed+"$",Fn=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let a=this.symbolToIndices.get(t);a===void 0?a=[r]:a.push(r),this.symbolToIndices.set(t,a)}},Ln=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[a,n]=r.includes("->")?r.split("->",2):[r,""];if(!a.match(RegExp(td)))throw new Error("Invalid LHS term");if(a.split(",").forEach((d,o)=>{let m=t[o].dims.slice();if(!d.match(RegExp(Hi)))throw new Error("Invalid LHS term");let g=this.processTerm(d,!0,m,o);this.lhs.push(g)}),n==="")n+=[...this.symbolToInfo.entries()].filter(([d,o])=>o.count===1||d==="...").map(([d])=>d).join("");else if(!n.match(RegExp(Qr)))throw new Error("Invalid RHS");n.match(RegExp(Gn,"g"))?.forEach(d=>{if(d==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let o=this.symbolToInfo.get(d);if(o===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(o.dimValue)}}),this.rhs=this.processTerm(n,!0,this.outputDims)}addSymbol(t,r,a){let n=this.symbolToInfo.get(t);if(n!==void 0){if(n.dimValue!==r&&n.count!==1)throw new Error("Dimension mismatch");n.count++,n.inputIndices.push(a)}else n={count:1,dimValue:r,inputIndices:[a]};this.symbolToInfo.set(t,n)}processTerm(t,r,a,n=-1){let s=a.length,u=!1,d=[],o=0;if(!t.match(RegExp(Hi))&&!r&&t!=="")throw new Error("Invalid LHS term");let m=t.match(RegExp(Gn,"g")),g=new Fn(n);return m?.forEach((x,b)=>{if(x==="..."){if(u)throw new Error("Only one ellipsis is allowed per input term");u=!0;let y=s-m.length+1;if(y<0)throw new Error("Ellipsis out of bounds");if(d=a.slice(o,o+y),this.hasEllipsis){if(this.ellipsisDims.length!==d.length||this.ellipsisDims.toString()!==d.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=d;else throw new Error("Ellipsis must be specified in the LHS");for(let $=0;$<d.length;$++){let w=String.fromCharCode("0".charCodeAt(0)+b);g.addSymbol(w,b+$),this.addSymbol(w,a[o++],n)}}else g.addSymbol(x,b),this.addSymbol(x,a[o++],n)}),g}},rd=(e,t)=>{let r=e[0].dataType,a=new Array(e.length);for(let z=0;z<e.length;++z)a[z]=F(`input${z}`,r,e[z].dims);let n=t.outputDims,s=M.size(n),u=Y("output",r,n),d=[],o=Array.from(t.rhs.symbolToIndices.keys()),m="var prod = 1.0;",g="var sum = 0.0;",x="sum += prod;",b=[],y=[],$=[],w=[],S=t.symbolToInfo.size===o.length;t.symbolToInfo.forEach((z,D)=>{if(o.includes(D)){let W=o.indexOf(D);t.lhs.forEach((P,k)=>{if(z.inputIndices.includes(k)){let H=P.symbolToIndices.get(D);if(H===void 0)throw new Error("Invalid symbol error");H.forEach(X=>{d.push(`${a[k].indicesSet(`input${k}Indices`,X,u.indicesGet("outputIndices",W))}`)})}})}else t.lhs.forEach((W,P)=>{let k=t.symbolToInfo.get(D);if(k===void 0)throw new Error("Invalid symbol error");if(k.inputIndices.includes(P)){let H=W.symbolToIndices.get(D);if(H===void 0)throw new Error("Invalid symbol error");H.forEach(X=>{b.push(`${a[P].indicesSet(`input${P}Indices`,X,`${D}`)}`)}),w.push(`prod *= ${a[P].getByIndices(`input${P}Indices`)};`)}}),y.push(`for(var ${D}: u32 = 0; ${D} < ${t.symbolToInfo.get(D)?.dimValue}; ${D}++) {`),$.push("}")});let A=S?[...d,`let sum = ${a.map((z,D)=>z.getByIndices(`input${D}Indices`)).join(" * ")};`]:[...d,g,...y,...b,m,...w,x,...$],_=z=>`\n      ${z.declareVariables(...a,u)}\n\n      ${z.mainStart()}\n        ${z.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n        var outputIndices = ${u.offsetToIndices("global_idx")};\n        ${a.map((D,W)=>`var input${W}Indices: ${a[W].type.indices};`).join(`\n`)}\n        ${A.join(`\n`)};\n        ${u.setByOffset("global_idx","sum")};\n      }`;return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:_}},ji=(e,t)=>{let r=new Ln(e.inputs,t.equation);e.compute(rd(e.inputs,r))},Ki=e=>{let t=e.equation.replace(/\\s+/g,"");return se({equation:t})}});var nd,Yi,od,ad,Xi,Ji=L(()=>{"use strict";ge();ve();nd=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),a=r.length<t.length?0:r.length-t.length,n=t.length<r.length?0:t.length-r.length;for(;a<r.length&&n<t.length;++a,++n)if(r[a]!==t[n]&&r[a]!==1&&t[n]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Yi=(e,t)=>{let r=e.length-t.length,a=[];for(let n=0;n<r;++n)a.push(e[n]);for(let n=0;n<t.length;++n)a.push(t[n]===1?e[n+r]:t[n]);return a},od=(e,t)=>e.length>t.length?Yi(e,t):Yi(t,e),ad=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),a=od(t,r),n=M.size(a),s=e[0].dataType,u=F("input",s,t),d=Y("output",s,a),o=m=>`\n  const inputShape = ${u.indices(...t)};\n  ${m.declareVariables(u,d)}\n  ${m.mainStart()}\n  ${m.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n    let outputIndices = ${d.offsetToIndices("global_idx")};\n    var inputIndices: ${u.type.indices};\n    for (var i = 0; i < ${t.length}; i++) {\n      if (${u.indicesGet("inputShape","i")} == 1) {\n        ${u.indicesSet("inputIndices","i",0)}\n      } else {\n        ${u.indicesSet("inputIndices","i",d.indicesGet("outputIndices",`i + ${a.length-t.length}`))}\n      }\n    }\n    ${d.setByOffset("global_idx",u.getByIndices("inputIndices"))}\n  }`;return{name:"Expand",shaderCache:{hint:`${a}`},getShaderSource:o,getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}})}},Xi=e=>{nd(e.inputs),e.compute(ad(e.inputs),{inputs:[0]})}});var id,sd,Zi,Qi,es=L(()=>{"use strict";ge();Pe();ve();id=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},sd=(e,t)=>{let r=e[0].dims,a=e[1].dims,n=r.length,s=M.normalizeAxis(t.axis,n),u=r.slice(0);u.splice(s,1,...a);let d=r[s],o=M.size(u),m=F("data",e[0].dataType,e[0].dims),g=F("inputIndices",e[1].dataType,e[1].dims),x=Y("output",e[0].dataType,u),b=()=>{let $=a.length,w=`var indicesIndices  = ${g.type.indices}(0);`;for(let S=0;S<$;S++)w+=`${$>1?`indicesIndices[${S}]`:"indicesIndices"} = ${u.length>1?`outputIndices[${s+S}]`:"outputIndices"};`;w+=`\n        var idx = ${g.getByIndices("indicesIndices")};\n        if (idx < 0) {\n          idx = idx + ${d};\n        }\n        var dataIndices = ${m.type.indices}(0);\n      `;for(let S=0,A=0;S<n;S++)S===s?(w+=`${n>1?`dataIndices[${S}]`:"dataIndices"} = u32(idx);`,A+=$):(w+=`${n>1?`dataIndices[${S}]`:"dataIndices"} = ${u.length>1?`outputIndices[${A}]`:"outputIndices"};`,A++);return w},y=$=>`\n      ${$.declareVariables(m,g,x)}\n      ${$.mainStart()}\n        ${$.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n        let outputIndices = ${x.offsetToIndices("global_idx")};\n        ${b()};\n        let value = ${m.getByIndices("dataIndices")};\n        ${x.setByOffset("global_idx","value")};\n      }`;return{name:"Gather",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:y}},Zi=e=>se({axis:e.axis}),Qi=(e,t)=>{let r=e.inputs;id(r),e.compute(sd(e.inputs,t))}});var ud,ld,ts,rs,ns=L(()=>{"use strict";ge();Pe();ve();ud=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},ld=(e,t)=>{let r=e[0].dims,a=e[0].dataType,n=r.length,s=M.computeStrides(r),u=M.size(r),d=e[1].dims,o=e[1].dataType,m=M.size(d),g=M.normalizeAxis(t.axis,n),x=r[g],b=d.slice(0),y=M.size(b),$=F("input",a,r),w=F("indices",o,[m]),S=Y("output",a,b),A=_=>`\n      const inputStrides = array<u32, ${s.length}>(${s.map(z=>`${z}u`).join(",")});\n      ${_.declareVariables($,w,S)}\n      ${_.mainStart()}\n      ${_.guardAgainstOutOfBoundsWorkgroupSizes(y)}\n\n      let outputIndices = ${S.offsetToIndices("global_idx")};\n\n      var idx = ${w.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + ${x};\n      }\n\n      var srcOffset = u32(0);\n\n      for (var i = 0; i < ${r.length}; i++) {\n        if (i == ${g}) {\n          srcOffset +=  u32(idx) * inputStrides[i];\n        } else {\n          srcOffset += ${S.indicesGet("outputIndices","i")} * inputStrides[i];\n        }\n      }\n\n      // Should never hit this with valid values in indices\n      // This is a guard against malicious data in the indices input\n      if (srcOffset < 0 || srcOffset >= ${u}) {\n        return;\n      }\n\n      output[global_idx] = input[srcOffset];\n  }`;return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:b,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)}}),getShaderSource:A}},ts=e=>se({axis:e.axis}),rs=(e,t)=>{let r=e.inputs;ud(r),e.compute(ld(e.inputs,t))}});var dd,cd,pd,os,as,is=L(()=>{"use strict";ge();Pe();ve();dd=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},cd=(e,t,r)=>{if(r.length===0)return"0u";let a=r.length===1&&e!==1||r.length===2&&r[0]!==e,n=r[r.length-1]!==t,s="0u";return a||(s+=`+ m * ${r[r.length-1]}u`),n||(s+="+n"),s},pd=(e,t)=>{let r=e[0].dims.slice(),a=e[1].dims.slice(),[n,s,u]=Nr.getShapeOfGemmResult(r,t.transA,a,t.transB,e.length===3?e[2].dims:void 0),d=[n,s];if(!d)throw new Error("Can\'t use gemm on the given tensors");let o=M.size(d),m="";t.transA&&t.transB?m="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?m="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?m="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(m="value += a[m * K + k] * b[k * N + n];");let g=Be(e[0].dataType),x=t.alpha===1?"":"value *= alpha;",b=e.length===3?`value += beta * c[${cd(n,s,e[2].dims)}];`:"",y=[`@group(0) @binding(0) var<storage, read> a : array<${g}>;`,`@group(0) @binding(1) var<storage, read> b : array<${g}>;`];e.length===3&&y.push(`@group(0) @binding(2) var<storage, read> c : array<${g}>;`);let $=w=>`\n  const M: u32 = ${n}u;\n  const N: u32 = ${s}u;\n  const K: u32 = ${u}u;\n  const alpha = ${g}(${t.alpha});\n  const beta = ${g}(${t.beta});\n\n  ${y.join(`\n`)}\n  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${g}>;\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${g}(0);\n    for (var k: u32 = 0u; k<${u}u; k++) {\n      ${m}\n    }\n\n    ${x}\n    ${b}\n    output[global_id.x] = value;\n\n  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:$}},os=(e,t)=>{dd(e.inputs),e.compute(pd(e.inputs,t))},as=e=>se(e)});var fd,md,hd,gd,ss,us,ls=L(()=>{"use strict";De();ge();Pe();ve();fd={name:"InstanceNormalization"},md=(e,t)=>{let r=e[0].dims,a=r,n=2,s=M.sizeToDimension(r,n),u=M.sizeFromDimension(r,n),d=r[1],o=F("x",e[0].dataType,[r[0],r[1],u]),m=F("scale",e[1].dataType,e[1].dims),g=F("bias",e[2].dataType,e[2].dims),x=Y("output",e[0].dataType,[r[0],r[1],u]),b=[o,m,g,x],y=o.type.value,$=64,w=S=>`\n\n  const C: u32 = ${d};\n  const normSize: u32 = ${u};\n  const epsilon: f32 = ${t.epsilon};\n  var<workgroup> meanShared : ${y};\n  var<workgroup> squaredNormShared : ${y};\n  var<workgroup> workgroupShared : array<${y}, ${$}>;\n  const workgroupSize = ${$}u;\n  ${S.declareVariables(...b)}\n  ${S.mainStart($)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial: ${y} = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      initial = initial + ${o.get("batch","channel","h")};\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = workgroupShared[0] / ${y}(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let deviation =  ${o.get("batch","channel","h")} - meanShared;\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = workgroupShared[0];\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / ${y}(normSize) + epsilon);\n    let channelScale = invStdDev * ${m.getByOffset("channel")};\n    let channelShift = ${g.getByOffset("channel")} - meanShared * channelScale;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let value = ${o.get("batch","channel","h")} * channelScale + channelShift;\n      ${x.set("batch","channel","h","value")};\n    }\n  }`;return{...fd,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:s}}),getShaderSource:w}},hd=(e,t,r,a,n,s,u,d)=>{let o=lt(u),m=F("input",t.dataType,t.dims,o),g=F("scale",r.dataType,r.dims,o),x=F("bias",a.dataType,a.dims,o),b=64,y=o===1?"vec2f":`mat2x${o}f`,$=o===1?"f32":`vec${o}f`,w=(W,P)=>`${y}(${W}, ${P})`,S=n*u/o,A=Math.ceil(s/b),_=W=>`\n  const H: u32 = ${s};\n  const C: u32 = ${u/o};\n  const imageSize: u32 = ${s*u/o};\n\n  ${W.declareVariables(m)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${y}>;\n\n  ${W.mainStart(b)}\n    let currentImageNumber = global_idx / ${b} / C;\n    let currentChannelNumber = (global_idx / ${b}) % C;\n    let wgId = global_idx % ${b};\n    let wgOffset = wgId * ${A};\n    if (wgOffset >= H) {\n        return;\n    }\n    let wgMax = min(wgOffset + ${A}, H);\n\n    let offset = currentImageNumber * imageSize + currentChannelNumber;\n    var sum = ${qe("f32",o)};\n    var squaredSum = ${qe("f32",o)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${$}(input[offset + i * C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${w("sum","squaredSum")};\n  }`,z=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:o,n,h:s,c:u})},getRunData:()=>({outputs:[{dims:[n,u,b,2],dataType:1}],dispatchGroup:{x:n*u/o}}),getShaderSource:_},{inputs:[t],outputs:[-1]})[0],D=W=>`\n  const H: u32 = ${s};\n  const C: u32 = ${u/o};\n  const imageSize: u32 = ${b*u/o};\n  const epsilon: f32 = ${d};\n\n  @group(0) @binding(0) var<storage, read> input : array<${y}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${g.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${x.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${y}>;\n\n  ${W.mainStart()}\n    ${W.guardAgainstOutOfBoundsWorkgroupSizes(S)}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    let offset = currentImageNumber * imageSize;\n    var sum = ${qe("f32",o)};\n    var squaredSum = ${qe("f32",o)};\n    for (var i: u32 = 0; i < ${b}; i++) {\n        let value = input[offset + i + currentChannelNumber * ${b}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(H);\n    squaredSum = squaredSum / f32(H);\n    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);\n    let channelScale = invStdDev * ${$}(scale[currentChannelNumber]);\n    let channelShift = ${$}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${w("channelScale","channelShift")};\n  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:o,n,h:s,c:u,epsilon:d})},getRunData:()=>({outputs:[{dims:[n,u,2],dataType:1}],dispatchGroup:{x:Math.ceil(S/64)}}),getShaderSource:D},{inputs:[z,r,a],outputs:[-1]})[0]},gd=(e,t,r)=>{let a=t[0].dims,n=a,s=a[0],u=a[a.length-1],d=M.sizeFromDimension(a,1)/u,o=lt(u),m=M.size(n)/o,g=F("input",t[0].dataType,t[0].dims,o),x=Y("output",t[0].dataType,n,o),b=Be(t[0].dataType),y=o===1?"vec2f":`mat2x${o}f`,$=o===1?b:`vec${o}<${b}>`,w=hd(e,t[0],t[1],t[2],s,d,u,r.epsilon),S=A=>`\n  const H: u32 = ${d};\n  const C: u32 = ${u/o};\n\n  @group(0) @binding(0) var<storage, read> input : array<${g.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${y}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${x.type.storage}>;\n\n  ${A.mainStart()}\n    let currentImageNumber = global_idx / (C * H);\n    let currentChannelNumber = global_idx % C;\n\n    let scaleOffset = currentImageNumber * C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${$}(scale[0]), ${$}(scale[1]));\n  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${r.cacheKey}`},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:S},{inputs:[t[0],w]})},ss=e=>se({epsilon:e.epsilon,format:e.format}),us=(e,t)=>{t.format==="NHWC"?gd(e,e.inputs,t):e.compute(md(e.inputs,t))}});var yd,bd,ds,cs,ps=L(()=>{"use strict";De();ge();Pe();ve();yd=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},bd=(e,t,r)=>{let a=e[0].dims,n=e[1],s=e[2],u=a,d=M.normalizeAxis(t.axis,a.length),o=M.sizeToDimension(a,d),m=M.sizeFromDimension(a,d),g=M.size(n.dims),x=s?M.size(s.dims):0;if(g!==m||s&&x!==m)throw new Error(`Size of X.shape()[axis:] == ${m}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${g} and bias size of ${x}`);let b=[];for(let D=0;D<a.length;++D)D<d?b.push(a[D]):b.push(1);let y=lt(m),$=Be(e[0].dataType),w=[F("x",e[0].dataType,e[0].dims,y),F("scale",n.dataType,n.dims,y)];s&&w.push(F("bias",s.dataType,s.dims,y)),w.push(Y("output",e[0].dataType,u,y));let S=r>1,A=r>2;S&&w.push(Y("meanDataOutput",1,b)),A&&w.push(Y("invStdOutput",1,b));let _=D=>`\n  const normSize: f32 = ${m};\n  const normSizeVectorized: u32 = ${m/y};\n  const epsilon: f32 = ${t.epsilon};\n\n  ${D.declareVariables(...w)}\n  ${D.mainStart()}\n    ${D.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let offset = global_idx * normSizeVectorized;\n    var meanVector = ${qe("f32",y)};\n    var meanSquareVector = ${qe("f32",y)};\n\n    for (var h: u32 = 0u; h < normSizeVectorized; h++) {\n      let value = ${Et($,y,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${ht("meanVector",y)} / normSize;\n    let meanSquare = sqrt(${ht("meanSquareVector",y)} \n      / normSize - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSizeVectorized; j++) {\n      let f32input = ${Et($,y,"x[j + offset]")};\n      let f32scale = ${Et($,y,"scale[j]")};\n      output[j + offset] = ${w[0].type.value}((f32input - mean) / meanSquare * f32scale\n        ${s?`+ ${Et($,y,"bias[j]")}`:""}\n      );\n    }\n\n    ${S?"meanDataOutput[global_idx] = mean":""};\n    ${A?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`,z=[{dims:u,dataType:e[0].dataType}];return S&&z.push({dims:b,dataType:1}),A&&z.push({dims:b,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:z,dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:_}},ds=e=>se({axis:e.axis,epsilon:e.epsilon}),cs=(e,t)=>{yd(e.inputs),e.compute(bd(e.inputs,t,e.outputCount))}});var wd,fs,ms=L(()=>{"use strict";ge();dr();wd=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},fs=e=>{wd(e.inputs);let t=Qe.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");e.compute(Zr(e.inputs,{activation:"",activationCacheKey:""},t))}});var vd,$d,xd,Sd,Cd,Ad,Id,Td,Ed,hs,gs,ys=L(()=>{"use strict";De();ge();Pe();ve();vd=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},$d=(e,t,r,a,n,s,u)=>{let d=r.length,o="";for(let m=d-1;m>=0;--m)o+=`\n            k = i32(${e.indicesGet("indices",m)}) - ${n[m]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${r[m]}) {\n              break;\n            }\n            offset += k * ${a[m]};\n        `;return`\n          value = ${s}(${u});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${o}\n            value = x[offset];\n          }\n      `},xd=(e,t,r,a,n)=>{let s=r.length,u="";for(let d=s-1;d>=0;--d)u+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${n[d]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(r[d]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${r[d]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${a[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${u}\n              value = x[offset];\n          `},Sd=(e,t,r,a,n)=>{let s=r.length,u="";for(let d=s-1;d>=0;--d)u+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${n[d]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${r[d]}) {\n                  k = ${r[d]-1};\n                }\n                offset += k * ${a[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${u}\n              value = x[offset];\n          `},Cd=(e,t,r,a,n)=>{let s=r.length,u="";for(let d=s-1;d>=0;--d)u+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${n[d]};\n                if (k < 0)  {\n                  k += ${r[d]};\n                }\n                if (k >= ${r[d]}) {\n                  k -= ${r[d]};\n                }\n                offset += k * ${a[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${u}\n              value = x[offset];\n          `},Ad=(e,t,r,a,n,s)=>{switch(n.mode){case 0:return $d(e,t,r,a,n.pads,s,n.value);case 1:return xd(e,t,r,a,n.pads);case 2:return Sd(e,t,r,a,n.pads);case 3:return Cd(e,t,r,a,n.pads);default:throw new Error("Invalid mode")}},Id=(e,t,r,a)=>{let n=t[0].dims,s=M.padShape(n.slice(),r.pads),u=M.size(s),d=M.computeStrides(n),o=Y("output",t[0].dataType,s),m=F("x",t[0].dataType,n),g=Ad(o,s,n,d,r,a);return`\n              ${e.declareVariables(m,o)}\n              ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n\n              let indices = ${o.offsetToIndices("global_idx")};\n\n              var value = ${a}(0);\n              ${g}\n              output[global_idx] = value;\n          }`},Td=(e,t)=>{let r=M.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(M.size(r)/64)}}),getShaderSource:a=>Id(a,e,t,"f32")}},Ed=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),a=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,n=e[0].dims.length,s=new Int32Array(2*n).fill(0);if(e.length>=4){let d=e[3].getBigInt64Array();for(let o=0;o<d.length;o++)s[Number(d[o])]=Number(r[o]),s[Number(d[o])+n]=Number(r[o+d.length])}else r.forEach((d,o)=>s[Number(o)]=Number(d));let u=[];return s.forEach(d=>u.push(d)),se({mode:t.mode,value:a,pads:u})}else return t},hs=(e,t)=>{vd(e.inputs);let r=Ed(e.inputs,t);e.compute(Td(e.inputs,r),{inputs:[0]})},gs=e=>{let t=e.mode,r=e.value,a=e.pads;return se({mode:t,value:r,pads:a})}});var en,bs,ws,vs,$s,xs,Ss,Cs,As,Is,Ts,Es,Os,_s,Rs,Ps=L(()=>{"use strict";ge();Pe();ve();en=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},bs=(e,t,r)=>{let a=t.format==="NHWC",n=e.dims.slice();a&&n.splice(1,0,n.pop());let s=Object.hasOwnProperty.call(t,"dilations"),u=t.kernelShape.slice(),d=t.strides.slice(),o=s?t.dilations.slice():[],m=t.pads.slice();It.adjustPoolAttributes(r,n,u,d,o,m);let g=It.computePoolOutputShape(r,n,d,o,u,m,t.autoPad),x=Object.assign({},t);s?Object.assign(x,{kernelShape:u,strides:d,pads:m,dilations:o,cacheKey:t.cacheKey}):Object.assign(x,{kernelShape:u,strides:d,pads:m,cacheKey:t.cacheKey});let b=g.slice();return b.push(b.splice(1,1)[0]),[x,a?b:g]},ws=(e,t,r,a,n,s,u,d)=>{let o=n.format==="NHWC",m=r,g=t.type.value,x=m.length,b=M.size(a),y=Y("output",t.type.tensor,a);if(n.kernelShape.length<=2){let $=n.kernelShape[n.kernelShape.length-1],w=n.strides[n.strides.length-1],S=n.pads[n.pads.length/2-1],A=n.pads[n.pads.length-1],_=x-(o?2:1),z="",D="",W="";if(S+A!==0?z=`\n                for (var i: u32 = 0u; i < ${$}u; i++) {\n                  xIndices[${_}] = indices[${_}] * ${w} - ${S} + i;\n                  if (xIndices[${_}] < 0 || xIndices[${_}] >= ${m[_]}) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`:z=`\n                for (var i: u32 = 0u; i < ${$}u; i++) {\n                  xIndices[${_}] = indices[${_}] * ${w} - ${S} + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`,n.kernelShape.length===2){let k=n.kernelShape[n.kernelShape.length-2],H=n.strides[n.strides.length-2],X=n.pads[n.pads.length/2-2],le=n.pads[n.pads.length-2],B=x-(o?3:2),K=m[B];X+le!==0?D=`\n                for (var j: u32 = 0u; j < ${k}u; j++) {\n                  xIndices[${B}] = indices[${B}] * ${H} - ${X} + j;\n                  if (xIndices[${B}] < 0 || xIndices[${B}] >= ${K}) {\n                    pad+= ${$};\n                    continue;\n                  }\n              `:D=`\n                for (var j: u32 = 0u; j < ${k}u; j++) {\n                  xIndices[${B}] = indices[${B}] * ${H} - ${X} + j;\n                `,W=`\n              }\n            `}return`\n            ${e.declareVariables(t,y)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n              let indices = ${y.offsetToIndices("global_idx")};\n              var xIndices = ${y.offsetToIndices("global_idx")};\n\n              var value: ${g} = ${g}(${d});\n              var pad = 0;\n              ${D}\n              ${z}\n              ${W}\n              ${u}\n\n              output[global_idx] = value;\n            }`}else{if(o)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let $=M.size(n.kernelShape),w=M.computeStrides(n.kernelShape),S=w.length,A=n.pads.length,_=n.pads.reduce((W,P)=>W+P),z="";return _?z=`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${s}\n              }`:z=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${s}\n            `,`\n            ${e.declareVariables(t,y)}\n\n            const pads = array<u32, ${A}>(${n.pads.map(W=>`${W}u`).join(",")});\n            const inputDims = array<u32, ${x}>(${m.map(W=>`${W}u`).join(",")});\n            const kernelStrides = array<u32, ${S}>(${w.map(W=>`${W}u`).join(",")});\n            const strides = array<u32, ${S}>(${n.strides.map(W=>`${W}u`).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n              let indices = ${y.offsetToIndices("global_idx")};\n              let xIndices = ${y.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${S}>;\n\n              var value = ${y.type.value}(${d});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${$}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${S-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${S-1}] = offset;\n\n                isPad = false;\n                for (var j = ${x-S}u; j < ${x}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${x-S}u]\n                    + offsets[j - ${x-S}u] - pads[j - 2u];\n                  ${z}\n              }\n              ${u}\n\n              output[global_idx] = value;\n            }`}},vs=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),$s=(e,t,r,a)=>{let[n,s]=bs(t,a,r),u=M.size(n.kernelShape),d=F("x",t.dataType,t.dims),o=d.type.value,m="value += x_val;",g="";return n.countIncludePad?g+=`value /= ${o}(${u});`:g+=`value /= ${o}(${u} - pad);`,{name:e,shaderCache:{hint:a.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(M.size(s)/64)}}),getShaderSource:x=>ws(x,d,t.dims,s,n,m,g,"0.0")}},xs=e=>{let t=e.count_include_pad!==0,r=vs(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return se({countIncludePad:t,...r})},Ss=(e,t)=>{en(e.inputs),e.compute($s("AveragePool",e.inputs[0],!1,t))},Cs={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},As=e=>{let t=e.format;return{format:t,...Cs,cacheKey:t}},Is=(e,t)=>{en(e.inputs),e.compute($s("GlobalAveragePool",e.inputs[0],!0,t))},Ts=(e,t,r,a)=>{let[n,s]=bs(t,a,r),u=`\n      value = max(x_val, value);\n    `,d="",o=F("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:a.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(M.size(s)/64)}}),getShaderSource:m=>ws(m,o,t.dims,s,n,u,d,"-1e5")}},Es=(e,t)=>{en(e.inputs),e.compute(Ts("MaxPool",e.inputs[0],!1,t))},Os=e=>{let t=e.storage_order,r=e.dilations,a=vs(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(a.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return se({storageOrder:t,dilations:r,...a})},_s=e=>{let t=e.format;return{format:t,...Cs,cacheKey:t}},Rs=(e,t)=>{en(e.inputs),e.compute(Ts("GlobalMaxPool",e.inputs[0],!0,t))}});var _d,Rd,Bs,Ms=L(()=>{"use strict";Dr();De();ve();_d=(e,t,r)=>{let a=e===t,n=e<t&&r<0,s=e>t&&r>0;if(a||n||s)throw new Error("Range these inputs\' contents are invalid.")},Rd=(e,t,r,a)=>{let n=Math.abs(Math.ceil((t-e)/r)),s=[n],u=n,d=Y("output",a,s),o=d.type.storage,m=g=>`\n        ${g.declareVariables(d)}\n        ${g.mainStart()}\n        ${g.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        output[global_idx] = ${o}(${e}) + ${o}(global_idx) * ${o}(${r});\n      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(g=>g.toString()).join("_")},getShaderSource:m,getRunData:()=>({outputs:[{dims:s,dataType:a}],dispatchGroup:{x:Math.ceil(u/64)}})}},Bs=e=>{let t=0,r=0,a=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],a=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],a=e.inputs[2].getFloat32Array()[0]),Do.webgpu.validateInputContent&&_d(t,r,a),e.compute(Rd(t,r,a,e.inputs[0].dataType),{inputs:[]})}});var Pd,Bd,Md,kd,Dd,Wd,zd,Nd,Vd,Ud,Gd,Fd,Ld,Hd,jd,ks,Ds,Ws=L(()=>{"use strict";ge();Pe();ve();Pd=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Bd=(e,t,r)=>{t.every(n=>n>=0&&n<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let a=new Array(r).fill(1);return t.forEach((n,s)=>a[n]=e[s]),a},Md=(e,t,r,a,n,s)=>{let[u,d,o]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],m=e[0].dims.length;if(u>0&&e.length>u&&e[u].dims.length>0)e[u].getFloat32Array().forEach(g=>s.push(g));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(d>0&&e.length>d&&e[d].dims.length>0){if(e[d].getFloat32Array().forEach(g=>a.push(g)),a.length!==0&&a.length!==m&&r>=18&&a.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Pd(a,t),t.axes.length>0&&Bd(a,t.axes,m).forEach((g,x)=>a[x]=g)}if(o>0&&e.length>o&&(e[o].getBigInt64Array().forEach(g=>n.push(Number(g))),n.length!==m||r>=18&&n.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(a.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(n.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof a<"u"&&typeof n<"u"&&a.length>0&&n.length>m)throw new Error("Resize requires only of scales or sizes to be specified")},kd=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`\n`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",Dd=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Wd=(e,t,r)=>{let a=new Array(r).fill(0).concat(new Array(r).fill(1)),n=e.length===0?a:e.slice();return t.length>0?(t.forEach((s,u)=>{a[s]=n[u],a[u+r]=n[t.length+u]}),a):n},zd=(e,t,r,a)=>{let n=[];if(r.length>0)if(a.length>0){if(e.forEach(s=>n.push(s)),Math.max(...a)>e.length)throw new Error("axes is out of bound");a.forEach((s,u)=>n[s]=r[u])}else r.forEach(s=>n.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");n=e.map((s,u)=>Math.round(s*t[u]))}return n},Nd=(e,t,r,a)=>{let n=(()=>{switch(a.keepAspectRatioPolicy){case"not_larger":return a.axes.length>0?Math.min(...a.axes.map(u=>r[u]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return a.axes.length>0?Math.max(...a.axes.map(u=>r[u]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${a.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let s=e.slice();return a.axes.length>0?(a.axes.forEach(u=>r[u]=n),a.axes.forEach(u=>s[u]=Math.round(e[u]*r[u]))):(r.fill(n,0,r.length),s.forEach((u,d)=>s[d]=Math.round(u*r[d]))),s},Vd=(e,t,r,a,n)=>`\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${r.length}> {\n      const inputShape = array<u32, ${t.length}>(${t.map(s=>`${s}u`).join(",")});\n      const outputShape = array<u32, ${r.length}>(${r.map(s=>`${s}u`).join(",")});\n      const scales = array<f32, ${a.length}>(${a.map(s=>`${s}f`).join(",")});\n      const roi = array<f32, ${n.length}>(${n.map(s=>`${s}f`).join(",")});\n      var originalIndices: array<f32, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};\n        if (scales[i] == 1.0) {\n          originalIndices[i] = f32(outputIndex);\n        } else {\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);\n        }\n      }\n      return originalIndices;\n    }`,Ud=(e,t,r,a,n,s,u)=>`\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n        const inputShape = array<u32, ${r.length}>(${r.map(d=>`${d}u`).join(",")});\n        const outputShape = array<u32, ${a.length}>(${a.map(d=>`${d}u`).join(",")});\n        const scales = array<f32, ${n.length}>(${n.map(d=>`${d}f`).join(",")});\n        const roi = array<f32, ${s.length}>(${s.map(d=>`${d}f`).join(",")});\n        var inputIndices: ${e.type.indices};\n        for (var i:u32 = 0; i < ${a.length}; i++) {\n          var outputIndex = ${a.length===1?"outputIndices":"outputIndices[i]"};\n          var inputIndex: u32;\n          if (scales[i] == 1.0) {\n            inputIndex = outputIndex;\n          } else {\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);\n            if (!${u} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\n              if (original_idx < 0) {\n                inputIndex = 0;\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\n                inputIndex = inputShape[i] - 1;\n              } else {\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\n              }\n            } else {\n              inputIndex = u32(original_idx);\n            }\n          }\n          ${e.indicesSet("inputIndices","i","inputIndex")}\n        }\n        return inputIndices;\n    }`,Gd=(e,t)=>`\n    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {\n      const inputShape = array<u32, ${t.length}>(${t.map(r=>`${r}u`).join(",")});\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var inputIndex = ${t.length===1?"inputIndices":"inputIndices[i]"};\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\n          return false;\n        }\n      }\n      return true;\n    }`,Fd=(e,t,r,a,n,s,u)=>{let[d,o,m,g]=r.length===2?[-1,0,1,-1]:n[1]===1?[0,2,3,1]:[0,1,2,3];return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\n      var inputIndices: ${e.type.indices};\n      inputIndices[${o}] = max(0, min(row, ${r[o]} - 1));\n      inputIndices[${m}] = max(0, min(col, ${r[m]} - 1));\n      if (${r.length} > 2) {\n        inputIndices[${g}] = channel;\n        inputIndices[${d}] = batch;\n      };\n      return input[${e.indicesToOffset("inputIndices")}];\n    }\n\n    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\n      var row:f32 = originalIndices[${o}];\n      var col:f32 = originalIndices[${m}];\n      if (${s} && (row < 0 || row > (${r[o]} - 1) || col < 0 || col > ${r[m]} - 1)) {\n        return ${u};\n      }\n      row = max(0, min(row, ${r[o]} - 1));\n      col = max(0, min(col, ${r[m]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${r.length>2}) {\n        channel = u32(originalIndices[${g}]);\n        batch = u32(originalIndices[${d}]);\n      }\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\n      var dx1: f32 = row - f32(row1);\n      var dx2: f32 = f32(row2 ) - row;\n      var dy1 = col - f32(col1);\n      var dy2 = f32(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Ld=(e,t,r,a,n,s,u,d,o,m)=>{let[g,x]=r.length===2?[0,1]:n[1]===1?[2,3]:[1,2],b=y=>{let $=y===g?"row":"col";return`\n      fn ${$}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {\n        var outputIndex = ${a.length===1?"outputIndices":`outputIndices[${y}]`};\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${n[y]},\n        f32(${a[y]}), f32(${r[y]}), ${s[y]}, ${s[y]} + ${r.length});\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${d} && (originalIdx < 0 || originalIdx > (${r[y]} - 1))) {\n          return ${o};\n        }\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${$}: f32 = originalIdx + f32(i);\n          if (${$} < 0 || ${$} >= ${r[y]}) {\n            if (${m}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${d}) {\n              return ${o};\n            } else {\n              ${$} = max(0, min(${$}, ${r[y]} - 1));\n            }\n          }\n          var inputIndicesCopy: ${e.type.indices} = inputIndices;\n          inputIndicesCopy[${y}] = u32(${$});\n          data[i + 1] = ${y===g?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${b(g)};\n    ${b(x)};\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\n    var absS = abs(s);\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: f32 = 1.0 - absS;\n    var twoMinusAbsS: f32 = 2.0 - absS;\n    var onePlusAbsS: f32 = 1.0 + absS;\n    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};\n    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n    var inputIndices: ${e.type.indices} = outputIndices;\n    return colCubicInterpolation(inputIndices, outputIndices);\n  }\n    `},Hd=(e,t,r,a,n,s)=>{let u=e.dims,d=Wd(s,t.axes,u.length),o=zd(u,a,n,t.axes),m=a.slice();a.length===0&&(m=u.map((S,A)=>S===0?1:o[A]/S),t.keepAspectRatioPolicy!=="stretch"&&(o=Nd(u,o,m,t)));let g=Y("output",e.dataType,o),x=F("input",e.dataType,u),b=M.size(o),y=u.length===o.length&&u.every((S,A)=>S===o[A]),$=t.coordinateTransformMode==="tf_crop_and_resize",w=S=>`\n      ${y?"":`\n      ${kd(t.coordinateTransformMode)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${Gd(x,u)};\n              ${Dd(t.nearestMode,r)};\n              ${Ud(x,g,u,o,m,d,$)};\n              `;case"linear":return`\n              ${Vd(g,u,o,m,d)};\n              ${Fd(x,g,u,o,m,$,t.extrapolationValue)};\n              `;case"cubic":return`\n            ${Ld(x,g,u,o,m,d,t.cubicCoeffA,$,t.extrapolationValue,t.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${S.declareVariables(x,g)}\n      ${S.mainStart()}\n        ${S.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n        ${y?"output[global_idx] = input[global_idx];":`\n        let outputIndices = ${g.offsetToIndices("global_idx")};\n        var inputIndices: ${x.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\n                if (checkInputIndices(inputIndices)) {\n                  output[global_idx] = input[${x.indicesToOffset("inputIndices")}];\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n        `}\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${m.length>0?m:""}|${n.length>0?n:""}|${y}`},getShaderSource:w,getRunData:()=>({outputs:[{dims:o,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(b/64)}})}},jd=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},ks=(e,t)=>{let r=[],a=[],n=[],s=jd(e);Md(e.inputs,t,s,r,a,n),e.compute(Hd(e.inputs[0],t,s,r,a,n),{inputs:[0]})},Ds=e=>{let t=e.antialias,r=e.axes,a=e.coordinateTransformMode,n=e.cubicCoeffA,s=e.excludeOutside!==0,u=e.extrapolationValue,d=e.keepAspectRatioPolicy,o=e.mode,m=e.nearestMode===""?"simple":e.nearestMode;return se({antialias:t,axes:r,coordinateTransformMode:a,cubicCoeffA:n,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:d,mode:o,nearestMode:m})}});var Kd,qd,zs,Ns,Vs=L(()=>{"use strict";De();ge();Pe();ve();Kd=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],a=e[2];if(t.dataType!==r.dataType||t.dataType!==a.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let n=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==n)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(a.dims.length!==1)throw new Error("Gamma must be 1D");if(a.dims[a.dims.length-1]!==n)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let u=e[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let u=e[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Bias must have the same hidden size as input")}},qd=(e,t,r,a)=>{let n=e[0].dims,s=M.size(n),u=n,d=s,o=n.slice(-1)[0],m=a?n.slice(0,-1).concat(1):[],g=e.length>3,x=e.length>4,b=a&&r>1,y=a&&r>2,$=r>3,w=lt(o),S=[F("x",e[0].dataType,e[0].dims,w),F("skip",e[1].dataType,e[1].dims,w),F("gamma",e[2].dataType,e[2].dims,w)];g&&S.push(F("beta",e[3].dataType,e[3].dims,w)),x&&S.push(F("bias",e[4].dataType,e[4].dims,w)),S.push(Y("output",e[0].dataType,u,w)),b&&S.push(Y("meanOutput",1,m)),y&&S.push(Y("invStdOutput",1,m)),$&&S.push(Y("inputSkipBiasSum",e[0].dataType,u,w));let A=Be(e[0].dataType),_=D=>`\n      const hiddenSize: f32 = ${o};\n      const hiddenSizeVectorized: u32 = ${o/w};\n      const epsilon: f32 = ${t.epsilon};\n\n      ${D.declareVariables(...S)}\n\n      ${D.mainStart()}\n        ${D.guardAgainstOutOfBoundsWorkgroupSizes(d/o)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${qe("f32",w)};\n        var squareSum = ${qe("f32",w)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${x?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${$?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${Et(A,w,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${ht("sum",w)} / hiddenSize;\n        let variance = sqrt(${ht("squareSum",w)} / hiddenSize - mean * mean + epsilon);\n        ${b?"meanOutput[global_idx] = mean;":""}\n        ${y?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${A}(mean)) / ${A}(variance) * gamma[i]\n           + ${g?"beta[i]":"0.0"};\n        }\n      }`,z=[{dims:u,dataType:e[0].dataType}];return r>1&&z.push({dims:m,dataType:1}),r>2&&z.push({dims:m,dataType:1}),r>3&&z.push({dims:n,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:_,getRunData:()=>({outputs:z,dispatchGroup:{x:Math.ceil(d/o/64)}})}},zs=(e,t)=>{Kd(e.inputs);let a=[0];e.outputCount>1&&a.push(-3),e.outputCount>2&&a.push(-3),e.outputCount>3&&a.push(3),e.compute(qd(e.inputs,t,e.outputCount,!1),{outputs:a})},Ns=e=>{let t=e.epsilon;return se({epsilon:t})}});var Yd,tn,Xd,Us,Jd,Zd,Gs,Fs,Ls=L(()=>{"use strict";De();ge();Pe();ve();Yd=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,a)=>{if(e[a+1].dataType!==6&&e[a+1].dataType!==7)throw new Error(`Input ${a} must be an array of int32 or int64`)})},tn=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(a=>r.push(Number(a)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(a=>r.push(Number(a)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Xd=(e,t)=>{if(e.length>1){let r=tn(e,1),a=tn(e,2),n=tn(e,3);return n.length===0&&(n=[...Array(e[0].dims.length).keys()]),se({starts:r,ends:a,axes:n})}else return t},Us=(e,t,r,a,n)=>{let s=e;return e<0&&(s+=r[a[t]]),n[t]<0?Math.max(0,Math.min(s,r[a[t]]-1)):Math.max(0,Math.min(s,r[a[t]]))},Jd=(e,t,r,a)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n          var inputIndices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            var outputIndex = ${a.length===1?"outputIndices":"outputIndices[i]"};\n            var inputIndex = outputIndex * steps[i] + starts[i] + carry;\n            carry = inputIndex / inputShape[i];\n            inputIndex = inputIndex % inputShape[i];\n            if (signs[i] < 0) {\n              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];\n            }\n            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;\n          }\n          return inputIndices;\n      }`,Zd=(e,t)=>{let r=e[0].dims,a=M.size(r),n=t.axes.length>0?M.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=tn(e,4);s.forEach(w=>w!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(n.length).fill(1));let u=t.starts.map((w,S)=>Us(w,S,r,n,s)),d=t.ends.map((w,S)=>Us(w,S,r,n,s));if(n.length!==r.length)for(let w=0;w<r.length;++w)n.includes(w)||(u.splice(w,0,0),d.splice(w,0,r[w]),s.splice(w,0,1));let o=s.map(w=>Math.sign(w));s.forEach((w,S,A)=>{if(w<0){let _=(d[S]-u[S])/w,z=u[S],D=z+_*s[S];u[S]=D,d[S]=z,A[S]=-w}});let m=r.slice(0);n.forEach((w,S)=>{m[w]=Math.ceil((d[w]-u[w])/s[w])});let g={dims:m,dataType:e[0].dataType},x=Y("output",e[0].dataType,m),b=F("input",e[0].dataType,r),y=M.size(m),$=w=>`\n      ${w.declareVariables(b,x)}\n        const signs = array<i32, ${o.length}>(${o.map(S=>`${S}i`).join(",")});\n        const starts = array<u32, ${u.length}>(${u.map(S=>`${S}u`).join(",")});\n        const ends = array<u32, ${d.length}>(${d.map(S=>`${S}u`).join(",")});\n        const steps = array<u32, ${s.length}>(${s.map(S=>`${S}u`).join(",")});\n        const inputShape = array<u32, ${r.length}>(${r.map(S=>`${S}u`).join(",")});\n\n        ${Jd(b,x,r,m)}\n        ${w.mainStart()}\n          ${w.guardAgainstOutOfBoundsWorkgroupSizes(y)}\n          let outputIndices = ${x.offsetToIndices("global_idx")};\n          let inputIndices = calculateInputIndices(outputIndices);\n          ${x.setByOffset("global_idx",b.getByIndices("inputIndices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${t.cacheKey}|${e[4]?.dims??""}`},getShaderSource:$,getRunData:()=>({outputs:[g],dispatchGroup:{x:Math.ceil(a/64)}})}},Gs=(e,t)=>{Yd(e.inputs,t);let r=Xd(e.inputs,t);e.compute(Zd(e.inputs,r),{inputs:[0]})},Fs=e=>{let t=e.starts,r=e.ends,a=e.axes;return se({starts:t,ends:r,axes:a})}});var Qd,ec,Hs,js,Ks=L(()=>{"use strict";ge();Pe();ve();Qd=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},ec=(e,t)=>{let r=e.dims,a=M.size(r),n=64,s=t.axis;if(s<0&&(s=r.length+s),s<r.length-1)throw new Error("softmax only supports last axis for now.");let u=r[s],d=a/u,o=lt(u),m=u/o,g=(S,A)=>A===4?`max(max(${S}.x, ${S}.y), max(${S}.z, ${S}.w))`:A===2?`max(${S}.x, ${S}.y)`:A===3?`max(max(${S}.x, ${S}.y), ${S}.z)`:S,x=F("x",e.dataType,e.dims,o),b=Y("result",e.dataType,e.dims,o),y=x.type.value,$=Be(e.dataType)==="f32"?`var threadMax = ${y}(-3.402823e+38f);`:`var threadMax = ${y}(-65504.0h);`,w=S=>`\n      var<workgroup> rowMaxShared : ${y};\n      var<workgroup> rowSumShared : ${y};\n      var<workgroup> threadShared : array<${y}, ${n}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${y} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${y}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${S.registerUniform("packedCols","i32").declareVariables(x,b)}\n      ${S.mainStart()}\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = ${n};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${$}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${y}(${g("threadShared[0]",o)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${y}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${y}(${ht("threadShared[0]",o)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`;return{name:"Softmax",shaderCache:{hint:`${o}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:d},programUniforms:[{type:"uint32",data:m}]}),getShaderSource:w}},Hs=(e,t)=>{Qd(e.inputs),e.compute(ec(e.inputs[0],t))},js=e=>se({axis:e.axis})});var tc,rc,nc,oc,ac,qs,Ys,Xs=L(()=>{"use strict";ge();Pe();ve();tc=e=>{if(!e||e.length<1)throw new Error("too few inputs")},rc=(e,t)=>{let r=[],a=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),a=r.length),se({numOutputs:a,axis:t.axis,splitSizes:r})},nc=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < sizeInConcatAxis[i]) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,oc=e=>{let t=e.length,r=[];for(let a=0;a<t;++a){let n=e[a].setByIndices("indices","input[global_idx]");t===1?r.push(n):a===0?r.push(`if (outputNumber == ${a}u) { ${n} }`):a===t-1?r.push(`else { ${n} }`):r.push(`else if (outputNumber == ${a}) { ${n} }`)}return`\n      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},ac=(e,t)=>{let r=e[0].dims,a=M.size(r),n=e[0].dataType,s=r.length,u=t.axis,d=u<0?r.length+u:u,o=new Array(t.numOutputs),m=F("input",n,r),g=new Array(t.numOutputs),x=[],b=[],y=0;for(let S=0;S<t.numOutputs;S++){y+=t.splitSizes[S],g[S]=y;let A=r.slice();A[t.axis]=t.splitSizes[S],b.push(A),o[S]=Y(`output${S}`,n,b[S]),x.push({dims:b[S],dataType:e[0].dataType})}let $=s<2?"indices":`indices[${d}]`,w=S=>`\n  ${S.declareVariables(m,...o)}\n  const sizeInConcatAxis = array<u32, ${g.length}>(${g.map(A=>`${A}u`).join(",")});\n  ${nc(g.length)}\n  ${oc(o)}\n\n  ${S.mainStart()}\n    ${S.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n\n    var indices = ${m.offsetToIndices("global_idx")};\n    let outputNumber = calculateOutputIndex(${$});\n    if (outputNumber != 0) {\n        ${$} -= sizeInConcatAxis[outputNumber - 1u];\n    }\n    writeBufferData(outputNumber, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:w,getRunData:()=>({outputs:x,dispatchGroup:{x:Math.ceil(a/64)}})}},qs=(e,t)=>{tc(e.inputs);let r=e.inputs.length===1?t:rc(e.inputs,t);e.compute(ac(e.inputs,r),{inputs:[0]})},Ys=e=>{let t=e.axis,r=e.splitSizes,a=e.numOutputs<0?r.length:e.numOutputs;if(a!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return se({axis:t,numOutputs:a,splitSizes:r})}});var Js,ic,sc,uc,Zs,Qs=L(()=>{"use strict";De();ge();ve();Js=e=>Array.from(e.getBigInt64Array(),Number),ic=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Js(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},sc=(e,t)=>{let r=[];for(let a=0;a<e.length;++a)r.push(e[a]*t[a]);return r},uc=e=>{let t=e[0].dims,r=Js(e[1]),a=sc(t,r),n=M.size(a),s=e[0].dataType,u=F("input",s,t),d=Y("output",s,a),o=m=>`\n      const inputShape = ${u.indices(...t)};\n      ${m.declareVariables(u,d)}\n      ${m.mainStart()}\n      ${m.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n      let outputIndices = ${d.offsetToIndices("global_idx")};\n      var inputIndices: ${u.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let inputDimValue = ${d.indicesGet("outputIndices","i")}  % ${u.indicesGet("inputShape","i")};\n\n        ${u.indicesSet("inputIndices","i","inputDimValue")}\n      }\n      ${d.setByOffset("global_idx",u.getByIndices("inputIndices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}}),getShaderSource:o}},Zs=e=>{ic(e.inputs),e.compute(uc(e.inputs),{inputs:[0]})}});var lc,dc,eu,tu=L(()=>{"use strict";De();ge();ve();lc=(e,t,r,a,n)=>{let s=M.size(r),u=Math.ceil(s/4),d=Y("outputData",n,r,4),o=F("aData",t[1].dataType,t[1].dims,4),m=F("bData",t[2].dataType,t[2].dims,4),g=F("cData",t[0].dataType,t[0].dims,4),x,b=(y,$,w)=>`select(${$}, ${y}, ${w})`;if(!a)x=d.setByOffset("global_idx",b(o.getByOffset("global_idx"),m.getByOffset("global_idx"),g.getByOffset("global_idx")));else{let y=($,w,S="")=>{let A=`aData[indexA${w}][componentA${w}]`,_=`bData[indexB${w}][componentB${w}]`,z=`bool(cData[indexC${w}] & ${4278190080>>>(3-w)*8}u)`;return`\n            let outputIndices${w} = ${d.offsetToIndices(`global_idx * 4u + ${w}u`)};\n            let offsetA${w} = ${o.broadcastedIndicesToOffset(`outputIndices${w}`,d)};\n            let offsetB${w} = ${m.broadcastedIndicesToOffset(`outputIndices${w}`,d)};\n            let offsetC${w} = ${g.broadcastedIndicesToOffset(`outputIndices${w}`,d)};\n            let indexA${w} = offsetA${w} / 4u;\n            let indexB${w} = offsetB${w} / 4u;\n            let indexC${w} = offsetC${w} / 4u;\n            let componentA${w} = offsetA${w} % 4u;\n            let componentB${w} = offsetB${w} % 4u;\n            ${$}[${w}] = ${S}(${b(A,_,z)});\n          `};n===9?x=`\n            var data = vec4<u32>(0);\n            ${y("data",0,"u32")}\n            ${y("data",1,"u32")}\n            ${y("data",2,"u32")}\n            ${y("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:x=`\n            ${y("outputData[global_idx]",0)}\n            ${y("outputData[global_idx]",1)}\n            ${y("outputData[global_idx]",2)}\n            ${y("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(g,o,m,d)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        ${x}\n      }`},dc=e=>{let t=e[1].dims,r=e[2].dims,a=e[0].dims,n=e[1].dataType,s=!(M.areEqual(t,r)&&M.areEqual(r,a)),u=t,d=M.size(t);if(s){let o=Qe.calcShape(Qe.calcShape(t,r,!1),a,!1);if(!o)throw new Error("Can\'t perform where op on the given tensors");u=o,d=M.size(u)}return{name:"Where",getShaderSource:o=>lc(o,e,u,s,n),getRunData:()=>({outputs:[{dims:u,dataType:n}],dispatchGroup:{x:Math.ceil(d/64/4)}})}},eu=e=>{e.compute(dc(e.inputs))}});var ru,nu=L(()=>{"use strict";Da();za();yi();Ei();Ri();zn();Li();qi();Ji();es();ns();is();ls();ps();ms();ys();Ps();Ms();Gr();Ws();Vs();Ls();Ks();Xs();Qs();ir();Mn();tu();ru=new Map([["Abs",[Na]],["Acos",[Va]],["Acosh",[Ua]],["Add",[bi]],["ArgMax",[ka,Pn]],["ArgMin",[Ma,Pn]],["Asin",[Ga]],["Asinh",[Fa]],["Atan",[La]],["Atanh",[Ha]],["AveragePool",[Ss,xs]],["BiasAdd",[Wa]],["BiasSplitGelu",[gi]],["Cast",[Ka,ja]],["Ceil",[Ya]],["ClipV10",[Bn]],["Clip",[qa]],["Concat",[Oi,_i]],["Conv",[Vn,Nn]],["ConvTranspose",[Fi,Gi]],["Cos",[Xa]],["Cosh",[Ja]],["Div",[wi]],["Einsum",[ji,Ki]],["Elu",[Za,Lr]],["Equal",[vi]],["Erf",[Qa]],["Exp",[ei]],["Expand",[Xi]],["Floor",[ti]],["FusedConv",[Vn,Nn]],["Gather",[Qi,Zi]],["GatherElements",[rs,ts]],["Gelu",[ri]],["Gemm",[os,as]],["GlobalAveragePool",[Is,As]],["GlobalMaxPool",[Rs,_s]],["Greater",[Ci]],["GreaterOrEqual",[Ii]],["InstanceNormalization",[us,ss]],["LayerNormalization",[cs,ds]],["LeakyRelu",[ni,Lr]],["Less",[Ai]],["LessOrEqual",[Ti]],["Log",[hi]],["MatMul",[fs]],["MaxPool",[Es,Os]],["Mul",[$i]],["Neg",[ai]],["Not",[oi]],["Pad",[hs,gs]],["Pow",[xi]],["Range",[Bs]],["Reciprocal",[ii]],["ReduceMin",[Ta,Ye]],["ReduceMean",[xa,Ye]],["ReduceMax",[Ia,Ye]],["ReduceSum",[Oa,Ye]],["ReduceProd",[Ea,Ye]],["ReduceL1",[Sa,Ye]],["ReduceL2",[Ca,Ye]],["ReduceLogSum",[Ra,Ye]],["ReduceLogSumExp",[Aa,Ye]],["ReduceSumSquare",[_a,Ye]],["Relu",[si]],["Resize",[ks,Ds]],["Sigmoid",[ui]],["Sin",[li]],["Sinh",[di]],["Slice",[Gs,Fs]],["SkipLayerNormalization",[zs,Ns]],["Split",[qs,Ys]],["Sqrt",[ci]],["Softmax",[Hs,js]],["Sub",[Si]],["Tan",[pi]],["Tanh",[fi]],["ThresholdedRelu",[mi,Lr]],["Tile",[Zs]],["Transpose",[la,da]],["Where",[eu]]])});var rn,ou=L(()=>{"use strict";Dr();De();mt();ve();Wr();rn=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,a,n,s,u,d){Ct(t.programInfo.name);let o=this.backend.device,m=this.backend.getComputePassEncoder();this.backend.queryType===1&&m.writeTimestamp(this.backend.querySet,this.backend.pendingDispathNumber*2),m.setPipeline(t.computePipeline);let g=[];for(let b of n)g.push({binding:g.length,resource:{buffer:b.buffer}});for(let b of s)g.push({binding:g.length,resource:{buffer:b.buffer}});d&&g.push({binding:g.length,resource:d});let x=o.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:g,label:t.programInfo.name});if(m.setBindGroup(0,x),m.dispatchWorkgroups(...u),this.backend.queryType!==0){let b=this.backend.currentKernelId,$=this.backend.kernels.get(b)[0];t.programInfo.name!==$&&($=`${$}/${t.programInfo.name}`);let w=[];r.forEach((A,_)=>{w.push(`${_}: [${A.dims}] | ${nr(A.dataType)}`)});let S=[];a.forEach((A,_)=>{S.push(`${_}: [${A.dims}] | ${nr(A.dataType)}`)}),this.backend.pendingKernelInfo.push([b,$,w,S]),this.backend.queryType===1&&m.writeTimestamp(this.backend.querySet,this.backend.pendingDispathNumber*2+1)}this.backend.pendingDispathNumber++,this.backend.pendingDispathNumber>=this.backend.maxDispatchNumber&&this.backend.endComputePass(),this.backend.pendingDispathNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),At(t.programInfo.name)}dispose(){}build(t,r){Ct(t.name);let a=this.backend.device,n=[];a.features.has("shader-f16")&&n.push("enable f16;");let s=sa(r),u=t.getShaderSource(s),d=`${n.join(`\n`)}\n${s.additionalImplementations}\n${u}`,o=a.createShaderModule({code:d,label:t.name});Te("verbose",()=>`[WebGPU] ${t.name} shader code: ${d}`);let m=a.createComputePipeline({compute:{module:o,entryPoint:"main"},layout:"auto",label:t.name});return At(t.name),{programInfo:t,computePipeline:m}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,a=typeof t=="number"?1:t.y||1,n=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=s&&a<=s&&n<=s)return[r,a,n];let u=r*a*n,d=Math.ceil(Math.sqrt(u));if(d>s){if(d=Math.ceil(Math.cbrt(u)),d>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[d,d,d]}else return[d,d,1]}}});var pc,fc,nn,au=L(()=>{"use strict";Dr();mt();ta();oa();nu();ou();Wr();pc=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let a=0;a<e.length;++a){let n=e[a].dataType;switch(t[a]){case"none":{r.push("");break}case"type":{r.push(`${n}`);break}case"rank":{let s=e[a].dims.length;r.push(`${n};${s}`);break}case"dims":{let s=e[a].dims.join(",");r.push(`${n};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[a]}`)}}return r.join("|")},fc=(e,t)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=`:${pc(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},nn=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispathNumber=0;this.maxDispatchNumber=16;this.pendingKernelInfo=[];this.pendingKernelInfoIndexId=0;this.pendingKernelInfoIndexName=1;this.pendingKernelInfoIndexInputs=2;this.pendingKernelInfoIndexOutputs=3;this.pendingQueries={};this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let a=[],n={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:a};r.features.has("chromium-experimental-timestamp-query-inside-passes")?a.push("chromium-experimental-timestamp-query-inside-passes"):r.features.has("timestamp-query")&&a.push("timestamp-query"),r.features.has("shader-f16")&&a.push("shader-f16"),this.device=await r.requestDevice(n),this.gpuDataManager=na(this),this.programManager=new rn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,this.queryType=0,this.env.webgpu.profilingMode,this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType=1:this.device.features.has("timestamp-query")&&(this.queryType=2),this.queryType!==0&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveData=this.gpuDataManager.create(this.maxDispatchNumber*2*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE)),Qo(t.logLevel,!!t.debug),Lo(!!t.trace),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.queryType===2&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispathNumber*2,endOfPassWriteIndex:this.pendingDispathNumber*2+1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Ct();let t;this.queryType!==0&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispathNumber*2,this.queryResolveData.buffer,0),t=this.gpuDataManager.create(this.pendingDispathNumber*2*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.pendingQueries[t.id]=this.pendingKernelInfo,this.pendingKernelInfo=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveData.buffer,0,t.buffer,0,this.pendingDispathNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispathNumber=0,this.queryType!==0&&t.buffer.mapAsync(GPUMapMode.READ).then(()=>{let r=new BigUint64Array(t.buffer.getMappedRange()),a=this.pendingQueries[t.id];for(let n=0;n<r.length/2;n++){let s=a[n][this.pendingKernelInfoIndexName],u=r[n*2],d=r[n*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=u);let o=Number(u-this.queryTimeBase),m=Number(d-this.queryTimeBase);if(!Number.isSafeInteger(o)||!Number.isSafeInteger(m))throw new RangeError("incorrect timestamp range");let g={kernelId:a[n][this.pendingKernelInfoIndexId],kernelName:s,inputs:a[n][this.pendingKernelInfoIndexInputs],outputs:a[n][this.pendingKernelInfoIndexOutputs],duration:m-o};console.log(`[profiling] ${JSON.stringify(g)}`),Sn("GPU",`${s}::${u}::${d}`)}t.buffer.unmap(),this.gpuDataManager.release(t.id)}),At()}run(t,r,a,n,s){Ct(t.name);let u=[];for(let A=0;A<r.length;++A){let _=this.gpuDataManager.get(r[A].data);if(!_)throw new Error(`no GPU data for input: ${r[A].data}`);u[A]=_}let d=fc(t,r),o=this.programManager.getArtifact(d),{outputs:m,dispatchGroup:g,programUniforms:x}=t.getRunData(r),b=a.length===0?m.map((A,_)=>_):a;if(b.length!==m.length)throw new Error(`Output size ${b.length} must be equal to ${m.length}.`);let y=[],$=[];for(let A=0;A<m.length;++A){if(!Number.isInteger(b[A])||b[A]<-3||b[A]>=m.length)throw new Error(`Invalid output index: ${b[A]}`);if(b[A]===-3)continue;let _=b[A]===-1,z=b[A]===-2,D=_||z?s(m[A].dataType,m[A].dims):n(b[A],m[A].dataType,m[A].dims),W=this.gpuDataManager.get(D.data);if(!W)throw new Error(`no GPU data for output: ${D.data}`);if(_&&this.temporaryData.push(W),z){let P=this.kernelPersistentData.get(this.currentKernelId);P||(P=[],this.kernelPersistentData.set(this.currentKernelId,P)),P.push(W)}y.push(D),$.push(W)}let w;if(x){let A=0,_=0,z=[],D=1;x.forEach(k=>{let H=typeof k.data=="number"?[k.data]:k.data,X;switch(H.length){case 1:X=4;break;case 2:X=8;break;case 3:X=16;break;case 4:X=16;break;case 5:X=16;break;case 6:X=16;break;default:throw new Error(`unsupported data length: ${H.length}`)}(_===5||_===6)&&(X=16),X>D&&(D=X),A=Math.ceil(A/X)*X,_=H.length,z.push(A),A+=H.length*4}),A=Math.ceil(A/D)*D;let W=new ArrayBuffer(A);x.forEach((k,H)=>{let X=z[H],le=typeof k.data=="number"?[k.data]:k.data;k.type==="int32"?new Int32Array(W,X,le.length).set(le):k.type==="uint32"?new Uint32Array(W,X,le.length).set(le):new Float32Array(W,X,le.length).set(le)});let P=this.gpuDataManager.create(A,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(P.buffer,0,W,0,A),this.gpuDataManager.release(P.id),w={offset:0,size:A,buffer:P.buffer}}let S=this.programManager.normalizeDispatchGroupSize(g);return o||(o=this.programManager.build(t,S),this.programManager.setArtifact(d,o)),Te("info",()=>`[ProgramManager] run "${t.name}" (key=${d}) with ${S[0]}x${S[1]}x${S[2]}`),this.programManager.run(o,r,y,u,$,S,w),At(t.name),y}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,a,n){let s=ru.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,n,s[0],[s[1],a]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let a of r)this.gpuDataManager.release(a.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,a){let n=this.kernels.get(t);if(!n)throw new Error(`kernel not created: ${t}`);let[s,u,d,o]=n;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${u}" is not allowed to be called recursively`);this.currentKernelId=t,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),Te("info",()=>`[WebGPU] Start to run kernel "[${s}] ${u}"...`);let m=this.env.debug;this.temporaryData=[];try{return m&&this.device.pushErrorScope("validation"),d(r,o[1]),0}catch(g){return a.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${u}" failed. ${g}`)),1}finally{m&&a.push(this.device.popErrorScope().then(g=>g?`GPU validation error for kernel "[${s}] ${u}": ${g.message}`:null));for(let g of this.temporaryData)this.gpuDataManager.release(g.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,a,n){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let u=s.get(r),d=this.gpuDataManager.registerExternalBuffer(a,n,u?.[1]);return s.set(r,[d,a]),d}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(a=>this.gpuDataManager.unregisterExternalBuffer(a[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,a){return async()=>{let n=await In(this,t,r);return ea(n.buffer,a)}}}});var iu={};_r(iu,{init:()=>mc});var cr,Hn,mc,su=L(()=>{"use strict";De();au();mt();ge();cr=class e{constructor(t,r,a,n){this.module=t;this.dataType=r;this.data=a;this.dims=n}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=M.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=M.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=M.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(M.size(t)!==M.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Hn=class{constructor(t,r,a){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let n=t.HEAPU32,s=a>>2;this.opKernelContext=n[s++];let u=n[s++];this.outputCount=n[s++],this.customDataOffset=n[s++],this.customDataSize=n[s++];let d=[];for(let o=0;o<u;o++){let m=n[s++],g=n[s++],x=n[s++],b=[];for(let y=0;y<x;y++)b.push(n[s++]);d.push(new cr(t,m,g,b))}this.inputs=d}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let a=r?.inputs?.map(d=>typeof d=="number"?this.inputs[d]:d)??this.inputs,n=r?.outputs??[],s=(d,o,m)=>new cr(this.module,o,this.output(d,m),m),u=(d,o)=>{let m=or(d);if(!m)throw new Error(`Unsupported data type: ${d}`);let g=m*M.size(o);return new cr(this.module,d,this.backend.gpuDataManager.create(g).id,o)};return this.backend.run(t,a,n,s,u)}output(t,r){let a=this.module.stackSave();try{let n=this.module.stackAlloc((1+r.length)*4),s=n>>2;this.module.HEAPU32[s++]=r.length;for(let u=0;u<r.length;u++)this.module.HEAPU32[s++]=r[u];return this.module._JsepOutput(this.opKernelContext,t,n)}catch(n){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(a)}}},mc=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let a=new nn;await a.initialize(t),r(a,n=>a.alloc(n),n=>a.free(n),(n,s,u,d=!1)=>{if(d)Te("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${n}, dst=${s}, size=${u}`),a.memcpy(n,s);else{Te("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${n}, gpuDataId=${s}, size=${u}`);let o=e.HEAPU8.subarray(n,n+u);a.upload(s,o)}},async(n,s,u)=>{Te("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${s}, size=${u}`),await a.download(n,()=>e.HEAPU8.subarray(s,s+u))},(n,s,u)=>a.createKernel(n,s,u,t.debug||t.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(s)):`${s}`),n=>a.releaseKernel(n),(n,s,u,d)=>{Te("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${n}, contextDataOffset=${s}`);let o=new Hn(e,a,s);return a.computeKernel(n,o,d)})}}});var Io;Io=go();var zu=So(),bn,wn=!1,Rr=!1,Ao=!1,Nu=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},Vu=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Uu=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",To=async e=>{if(wn)return Promise.resolve();if(Rr)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Ao)throw new Error("previous call to \'initializeWebAssembly()\' failed.");Rr=!0;let t=e.initTimeout,r=e.numThreads,a=e.simd,n=r>1&&Nu(),s=a&&Vu(),u=e.wasmPaths,d=typeof u=="string"?u:void 0,o=Uu(s,n),m=typeof u=="object"?u[o]:void 0,g=!1,x=[];if(t>0&&x.push(new Promise(b=>{setTimeout(()=>{g=!0,b()},t)})),x.push(new Promise((b,y)=>{let $=n?zu:Io,w={locateFile:(S,A)=>{if(n&&S.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Co()],{type:"text/javascript"}));if(S.endsWith(".wasm")){if(m)return m;let _=d??A;return o==="ort-wasm-simd.wasm"?_+"ort-wasm-simd.jsep.wasm":o==="ort-wasm-simd-threaded.wasm"?_+"ort-wasm-simd-threaded.jsep.wasm":_+o}return A+S}};if(n)if(typeof Blob>"u")w.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let S=`var ortWasmThreaded=${$.toString()};`;w.mainScriptUrlOrBlob=new Blob([S],{type:"text/javascript"})}$(w).then(S=>{Rr=!1,wn=!0,bn=S,b()},S=>{Rr=!1,Ao=!0,y(S)})})),await Promise.race(x),g)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Re=()=>{if(wn&&bn)return bn;throw new Error("WebAssembly is not initialized yet.")};var Me=(e,t)=>{let r=Re(),a=r.lengthBytesUTF8(e)+1,n=r._malloc(a);return r.stringToUTF8(e,n,a),t.push(n),n},rr=(e,t,r,a)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([n,s])=>{let u=t?t+n:n;if(typeof s=="object")rr(s,u+".",r,a);else if(typeof s=="string"||typeof s=="number")a(u,s.toString());else if(typeof s=="boolean")a(u,s?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof s}`)})},Ae=e=>{let t=Re(),r=t.stackSave();try{let a=t.stackAlloc(8);t._OrtGetLastError(a,a+4);let n=t.HEAP32[a/4],s=t.HEAPU32[a/4+1],u=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${u}`)}finally{t.stackRestore(r)}};var Eo=e=>{let t=Re(),r=0,a=[],n=e||{};try{if(e?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(n.terminate=!1);let s=0;return e?.tag!==void 0&&(s=Me(e.tag,a)),r=t._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,s),r===0&&Ae("Can\'t create run options."),e?.extra!==void 0&&rr(e.extra,"",new WeakSet,(u,d)=>{let o=Me(u,a),m=Me(d,a);t._OrtAddRunConfigEntry(r,o,m)!==0&&Ae(`Can\'t set a run config entry: ${u} - ${d}.`)}),[r,a]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),a.forEach(u=>t._free(u)),s}};var Gu=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Fu=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Lu=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},Hu=(e,t,r)=>{for(let a of t){let n=typeof a=="string"?a:a.name;switch(n){case"xnnpack":n="XNNPACK";break;case"webnn":if(n="WEBNN",typeof a!="string"){let u=a;if(u?.deviceType){let d=Me("deviceType",r),o=Me(u.deviceType,r);Re()._OrtAddSessionConfigEntry(e,d,o)!==0&&Ae(`Can\'t set a session config entry: \'deviceType\' - ${u.deviceType}.`)}if(u?.powerPreference){let d=Me("powerPreference",r),o=Me(u.powerPreference,r);Re()._OrtAddSessionConfigEntry(e,d,o)!==0&&Ae(`Can\'t set a session config entry: \'powerPreference\' - ${u.powerPreference}.`)}}break;case"webgpu":if(n="JS",typeof a!="string"){let u=a;if(u?.preferredLayout){if(u.preferredLayout!=="NCHW"&&u.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${u.preferredLayout}`);let d=Me("preferredLayout",r),o=Me(u.preferredLayout,r);Re()._OrtAddSessionConfigEntry(e,d,o)!==0&&Ae(`Can\'t set a session config entry: \'preferredLayout\' - ${u.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let s=Me(n,r);Re()._OrtAppendExecutionProvider(e,s)!==0&&Ae(`Can\'t append execution provider: ${n}.`)}},Oo=e=>{let t=Re(),r=0,a=[],n=e||{};Lu(n);try{let s=Gu(n.graphOptimizationLevel??"all"),u=Fu(n.executionMode??"sequential"),d=typeof n.logId=="string"?Me(n.logId,a):0,o=n.logSeverityLevel??2;if(!Number.isInteger(o)||o<0||o>4)throw new Error(`log serverity level is not valid: ${o}`);let m=n.logVerbosityLevel??0;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log verbosity level is not valid: ${m}`);let g=typeof n.optimizedModelFilePath=="string"?Me(n.optimizedModelFilePath,a):0;if(r=t._OrtCreateSessionOptions(s,!!n.enableCpuMemArena,!!n.enableMemPattern,u,!!n.enableProfiling,0,d,o,m,g),r===0&&Ae("Can\'t create session options."),n.executionProviders&&Hu(r,n.executionProviders,a),n.freeDimensionOverrides)for(let[x,b]of Object.entries(n.freeDimensionOverrides)){if(typeof x!="string")throw new Error(`free dimension override name must be a string: ${x}`);if(typeof b!="number"||!Number.isInteger(b)||b<0)throw new Error(`free dimension override value must be a non-negative integer: ${b}`);let y=Me(x,a);t._OrtAddFreeDimensionOverride(r,y,b)!==0&&Ae(`Can\'t set a free dimension override: ${x} - ${b}.`)}return n.extra!==void 0&&rr(n.extra,"",new WeakSet,(x,b)=>{let y=Me(x,a),$=Me(b,a);t._OrtAddSessionConfigEntry(r,y,$)!==0&&Ae(`Can\'t set a session config entry: ${x} - ${b}.`)}),[r,a]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),a.forEach(u=>t._free(u)),s}};De();var lu=!1,hc=e=>{let t=Re(),r=t.stackSave();try{let a=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,a,a+4)!==0&&Ae("Can\'t get session input/output count."),[t.HEAP32[a/4],t.HEAP32[a/4+1]]}finally{t.stackRestore(r)}},gc=(e,t)=>{Re()._OrtInit(e,t)!==0&&Ae("Can\'t initialize onnxruntime.")},du=async e=>{gc(e.wasm.numThreads,ar(e.logLevel));{let t=(su(),Dt(iu)).init;await t(Re(),e)}lu=!0},pr=new Map,cu=()=>lu,jn=e=>{let t=Re(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},Kn=(e,t)=>{let r=Re(),a=0,n=0,s=0,u=[],d=[],o=[];try{[n,u]=Oo(t),a=r._OrtCreateSession(e[0],e[1],n),a===0&&Ae("Can\'t create a session.");let[m,g]=hc(a),x=[],b=[],y=[];for(let w=0;w<m;w++){let S=r._OrtGetInputName(a,w);S===0&&Ae("Can\'t get an input name."),d.push(S),x.push(r.UTF8ToString(S))}for(let w=0;w<g;w++){let S=r._OrtGetOutputName(a,w);S===0&&Ae("Can\'t get an output name."),o.push(S);let A=r.UTF8ToString(S);b.push(A);{let _=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[A]??"cpu";if(_!=="cpu"&&_!=="cpu-pinned"&&_!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${_}.`);y.push(_)}}let $=null;return y.some(w=>w==="gpu-buffer")&&(s=r._OrtCreateBinding(a),s===0&&Ae("Can\'t create IO binding."),$={handle:s,outputPreferredLocations:y,outputPreferredLocationsEncoded:y.map(w=>$n(w))}),pr.set(a,[a,d,o,$]),[a,x,b]}catch(m){throw d.forEach(g=>r._OrtFree(g)),o.forEach(g=>r._OrtFree(g)),s!==0&&r._OrtReleaseBinding(s),a!==0&&r._OrtReleaseSession(a),m}finally{r._free(e[0]),n!==0&&r._OrtReleaseSessionOptions(n),u.forEach(m=>r._free(m))}},pu=(e,t)=>{let r=jn(e);return Kn(r,t)},fu=e=>{let t=Re(),r=pr.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[a,n,s,u]=r;u&&t._OrtReleaseBinding(u.handle),t.jsepUnregisterBuffers?.(e),n.forEach(d=>t._OrtFree(d)),s.forEach(d=>t._OrtFree(d)),t._OrtReleaseSession(a),pr.delete(e)},uu=(e,t,r,a,n)=>{if(!e){t.push(0);return}let s=Re(),u=e[0],d=e[1],o=e[3],m,g;if(u==="string"&&o==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(o==="gpu-buffer"){let y=e[2].gpuBuffer,$=or(vn(u));g=d.reduce((w,S)=>w*S,1)*$,m=s.jsepRegisterBuffer(a,n,y,g)}else{let y=e[2];if(Array.isArray(y)){g=4*y.length,m=s._malloc(g),r.push(m);let $=m/4;for(let w=0;w<y.length;w++){if(typeof y[w]!="string")throw new TypeError(`tensor data at index ${w} is not a string`);s.HEAPU32[$++]=Me(y[w],r)}}else g=y.byteLength,m=s._malloc(g),r.push(m),s.HEAPU8.set(new Uint8Array(y.buffer,y.byteOffset,g),m)}let x=s.stackSave(),b=s.stackAlloc(4*d.length);try{let y=b/4;d.forEach(w=>s.HEAP32[y++]=w);let $=s._OrtCreateTensor(vn(u),m,g,b,d.length,$n(o));$===0&&Ae(`Can\'t create tensor for input/output. session=${a}, index=${n}.`),t.push($)}finally{s.stackRestore(x)}},mu=async(e,t,r,a,n,s)=>{let u=Re(),d=pr.get(e);if(!d)throw new Error(`cannot run inference. invalid session id: ${e}`);let[o,m,g,x]=d,b=t.length,y=a.length,$=0,w=[],S=[],A=[],_=[],z=u.stackSave(),D=u.stackAlloc(b*4),W=u.stackAlloc(b*4),P=u.stackAlloc(y*4),k=u.stackAlloc(y*4);try{[$,w]=Eo(s);for(let ie=0;ie<b;ie++)uu(r[ie],S,_,e,t[ie]);for(let ie=0;ie<y;ie++)uu(n[ie],A,_,e,b+a[ie]);let H=D/4,X=W/4,le=P/4,B=k/4;for(let ie=0;ie<b;ie++)u.HEAPU32[H++]=S[ie],u.HEAPU32[X++]=m[t[ie]];for(let ie=0;ie<y;ie++)u.HEAPU32[le++]=A[ie],u.HEAPU32[B++]=g[a[ie]];if(x){let{handle:ie,outputPreferredLocations:we,outputPreferredLocationsEncoded:j}=x;if(m.length!==b)throw new Error(`input count from feeds (${b}) is expected to be always equal to model\'s input count (${m.length}).`);for(let Se=0;Se<b;Se++){let Oe=t[Se];await u._OrtBindInput(ie,m[Oe],S[Se])!==0&&Ae(`Can\'t bind input[${Se}] for session=${e}.`)}for(let Se=0;Se<y;Se++){let Oe=a[Se];n[Se]?.[3]?u._OrtBindOutput(ie,g[Oe],A[Se],0)!==0&&Ae(`Can\'t bind pre-allocated output[${Se}] for session=${e}.`):u._OrtBindOutput(ie,g[Oe],0,j[Oe])!==0&&Ae(`Can\'t bind output[${Se}] to ${we[Se]} for session=${e}.`)}}let K;x?K=await u._OrtRunWithBinding(o,x.handle,y,P,$):K=await u._OrtRun(o,W,D,b,k,y,P,$),K!==0&&Ae("failed to call OrtRun().");let xe=[];for(let ie=0;ie<y;ie++){let we=u.HEAPU32[P/4+ie];if(we===A[ie]){xe.push(n[ie]);continue}let j=u.stackSave(),Se=u.stackAlloc(4*4),Oe=!1,Ie,Ce=0;try{u._OrtGetTensorData(we,Se,Se+4,Se+8,Se+12)!==0&&Ae(`Can\'t access output tensor data on index ${ie}.`);let Ue=Se/4,Fe=u.HEAPU32[Ue++];Ce=u.HEAPU32[Ue++];let G=u.HEAPU32[Ue++],de=u.HEAPU32[Ue++],pe=[];for(let Ee=0;Ee<de;Ee++)pe.push(u.HEAPU32[G/4+Ee]);u._OrtFree(G);let ze=pe.reduce((Ee,ke)=>Ee*ke,1);Ie=nr(Fe);let Ge=x?.outputPreferredLocations[a[ie]];if(Ie==="string"){if(Ge==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Ee=[],ke=Ce/4;for(let Ve=0;Ve<ze;Ve++){let Xe=u.HEAPU32[ke++],Le=Ve===ze-1?void 0:u.HEAPU32[ke]-Xe;Ee.push(u.UTF8ToString(Xe,Le))}xe.push([Ie,pe,Ee,"cpu"])}else if(Ge==="gpu-buffer"&&ze>0){let Ee=u.jsepGetBuffer(Ce),ke=or(Fe);if(ke===void 0||!_o(Ie))throw new Error(`Unsupported data type: ${Ie}`);Oe=!0,xe.push([Ie,pe,{gpuBuffer:Ee,download:u.jsepCreateDownloader(Ee,ze*ke,Ie),dispose:()=>{u._OrtReleaseTensor(we)}},"gpu-buffer"])}else{let Ee=Pr(Ie),ke=new Ee(ze);new Uint8Array(ke.buffer,ke.byteOffset,ke.byteLength).set(u.HEAPU8.subarray(Ce,Ce+ke.byteLength)),xe.push([Ie,pe,ke,"cpu"])}}finally{u.stackRestore(j),Ie==="string"&&Ce&&u._free(Ce),Oe||u._OrtReleaseTensor(we)}}return x&&u._OrtClearBoundOutputs(x.handle),xe}finally{u.stackRestore(z),S.forEach(H=>u._OrtReleaseTensor(H)),A.forEach(H=>u._OrtReleaseTensor(H)),_.forEach(H=>u._free(H)),$!==0&&u._OrtReleaseRunOptions($),w.forEach(H=>u._free(H))}},hu=e=>{let t=Re(),r=pr.get(e);if(!r)throw new Error("invalid session id");let a=r[0],n=t._OrtEndProfiling(a);n===0&&Ae("Can\'t get an profile file name."),t._OrtFree(n)},gu=e=>{let t=[];for(let r of e){let a=r[2];!Array.isArray(a)&&"buffer"in a&&t.push(a.buffer)}return t};self.onmessage=e=>{switch(e.data.type){case"init-wasm":try{To(e.data.in).then(()=>postMessage({type:"init-wasm"}),t=>postMessage({type:"init-wasm",err:t}))}catch(t){postMessage({type:"init-wasm",err:t})}break;case"init-ort":try{du(e.data.in).then(()=>postMessage({type:"init-ort"}),t=>postMessage({type:"init-ort",err:t}))}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{let{model:t}=e.data.in,r=jn(t);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{let{modeldata:t,options:r}=e.data.in,a=Kn(t,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{let{model:t,options:r}=e.data.in,a=pu(t,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{let t=e.data.in;fu(t),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{let{sessionId:t,inputIndices:r,inputs:a,outputIndices:n,options:s}=e.data.in;mu(t,r,a,n,s).then(u=>{postMessage({type:"run",out:u},gu(u))},u=>{postMessage({type:"run",err:u})})}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{let t=e.data.in;hu(t),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}break;case"is-ort-env-initialized":try{let t=cu();postMessage({type:"is-ort-env-initialized",out:t})}catch(t){postMessage({type:"is-ort-env-initialized",err:t})}break;default:}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'});var bt,Ke,In,_a,Oa,wa,va,$a,xa,Sa,Ca,Ia,Aa,Ea,Et,_p,Cn,ml,hl,gl,yl,Ta,bl,wl,vl,$l,Ra=F(()=>{"use strict";ot();pl();Kt();bt=()=>!!Ie.wasm.proxy&&typeof document<"u",In=!1,_a=!1,Oa=!1,$a=[],xa=[],Sa=[],Ca=[],Ia=[],Aa=[],Ea=[],Et=()=>{if(In||!_a||Oa||!Ke)throw new Error("worker not ready")},_p=e=>{switch(e.data.type){case"init-wasm":In=!1,e.data.err?(Oa=!0,wa[1](e.data.err)):(_a=!0,wa[0]());break;case"init-ort":e.data.err?va[1](e.data.err):va[0]();break;case"create_allocate":e.data.err?$a.shift()[1](e.data.err):$a.shift()[0](e.data.out);break;case"create_finalize":e.data.err?xa.shift()[1](e.data.err):xa.shift()[0](e.data.out);break;case"create":e.data.err?Sa.shift()[1](e.data.err):Sa.shift()[0](e.data.out);break;case"release":e.data.err?Ca.shift()[1](e.data.err):Ca.shift()[0]();break;case"run":e.data.err?Ia.shift()[1](e.data.err):Ia.shift()[0](e.data.out);break;case"end-profiling":e.data.err?Aa.shift()[1](e.data.err):Aa.shift()[0]();break;case"is-ort-env-initialized":e.data.err?Ea.shift()[1](e.data.err):Ea.shift()[0](e.data.out);break;default:}},Cn=typeof document<"u"?document?.currentScript?.src:void 0,ml=async()=>{if(bt()){if(_a)return;if(In)throw new Error("multiple calls to 'initWasm()' detected.");if(Oa)throw new Error("previous call to 'initWasm()' failed.");return In=!0,Ie.wasm.wasmPaths===void 0&&Cn&&Cn.indexOf("blob:")!==0&&(Ie.wasm.wasmPaths=Cn.substr(0,+Cn.lastIndexOf("/")+1)),new Promise((e,t)=>{Ke?.terminate();let r=URL.createObjectURL(new Blob([fl()],{type:"text/javascript"}));Ke=new Worker(r,{name:"ort-wasm-proxy-worker"}),Ke.onerror=n=>t(n),Ke.onmessage=_p,URL.revokeObjectURL(r),wa=[e,t];let a={type:"init-wasm",in:Ie.wasm};Ke.postMessage(a)})}else return Vo(Ie.wasm)},hl=async e=>{if(bt())return Et(),new Promise((t,r)=>{va=[t,r];let a={type:"init-ort",in:e};Ke.postMessage(a)});await ol(e)},gl=async e=>bt()?(Et(),new Promise((t,r)=>{$a.push([t,r]);let a={type:"create_allocate",in:{model:e}};Ke.postMessage(a,[e.buffer])})):ya(e),yl=async(e,t)=>bt()?(Et(),new Promise((r,a)=>{xa.push([r,a]);let n={type:"create_finalize",in:{modeldata:e,options:t}};Ke.postMessage(n)})):ba(e,t),Ta=async(e,t)=>{if(bt()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Et(),new Promise((r,a)=>{Sa.push([r,a]);let n={type:"create",in:{model:e,options:t}};Ke.postMessage(n,[e.buffer])})}else return sl(e,t)},bl=async e=>{if(bt())return Et(),new Promise((t,r)=>{Ca.push([t,r]);let a={type:"release",in:e};Ke.postMessage(a)});ul(e)},wl=async(e,t,r,a,n,s)=>{if(bt()){if(r.some(u=>u[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(n.some(u=>u))throw new Error("pre-allocated output tensor is not supported for proxy.");return Et(),new Promise((u,l)=>{Ia.push([u,l]);let o=r,p={type:"run",in:{sessionId:e,inputIndices:t,inputs:o,outputIndices:a,options:s}};Ke.postMessage(p,cl(o))})}else return ll(e,t,r,a,n,s)},vl=async e=>{if(bt())return Et(),new Promise((t,r)=>{Aa.push([t,r]);let a={type:"end-profiling",in:e};Ke.postMessage(a)});dl(e)},$l=async()=>bt()?(Et(),new Promise((e,t)=>{Ea.push([e,t]);let r={type:"is-ort-env-initialized"};Ke.postMessage(r)})):il()});var An,xl,Op,En,Sl=F(()=>{"use strict";ot();Ra();Me();xl=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},Op=e=>{switch(e[3]){case"cpu":return new Ve(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!tn(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:a,dispose:n}=e[2];return Ve.fromGpuBuffer(r,{dataType:t,dims:e[1],download:a,dispose:n})}default:throw new Error(`invalid data location: ${e[3]}`)}},En=class{async createSessionAllocate(t){let r=await fetch(t);if(r.status!==200)throw new Error(`failed to load model: ${t}`);let a=await r.arrayBuffer();return gl(new Uint8Array(a))}async loadModel(t,r){if(je(),await $l()||(An||(An=hl(Ie)),await An,An=void 0),typeof t=="string")if(typeof process<"u"&&process.versions&&process.versions.node){let a=await(void 0)(t);[this.sessionId,this.inputNames,this.outputNames]=await Ta(a,r)}else{let a=await this.createSessionAllocate(t);[this.sessionId,this.inputNames,this.outputNames]=await yl(a,r)}else[this.sessionId,this.inputNames,this.outputNames]=await Ta(t,r);qe()}async dispose(){return bl(this.sessionId)}async run(t,r,a){je();let n=[],s=[];Object.entries(t).forEach(g=>{let y=g[0],$=g[1],v=this.inputNames.indexOf(y);if(v===-1)throw new Error(`invalid input '${y}'`);n.push($),s.push(v)});let u=[],l=[];Object.entries(r).forEach(g=>{let y=g[0],$=g[1],v=this.outputNames.indexOf(y);if(v===-1)throw new Error(`invalid output '${y}'`);u.push($),l.push(v)});let o=n.map((g,y)=>xl(g,()=>`input "${this.inputNames[s[y]]}"`)),p=u.map((g,y)=>g?xl(g,()=>`output "${this.outputNames[l[y]]}"`):null),m=await wl(this.sessionId,s,o,l,p,a),w={};for(let g=0;g<m.length;g++)w[this.outputNames[l[g]]]=u[g]??Op(m[g]);return qe(),w}startProfiling(){}endProfiling(){vl(this.sessionId)}}});var Tp,_n,Cl=F(()=>{"use strict";ot();Ra();Sl();Tp=()=>{if((typeof Ie.wasm.initTimeout!="number"||Ie.wasm.initTimeout<0)&&(Ie.wasm.initTimeout=0),typeof Ie.wasm.simd!="boolean"&&(Ie.wasm.simd=!0),typeof Ie.wasm.proxy!="boolean"&&(Ie.wasm.proxy=!1),typeof Ie.wasm.numThreads!="number"||!Number.isInteger(Ie.wasm.numThreads)||Ie.wasm.numThreads<=0){let e=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;Ie.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},_n=class{async init(){Tp(),await ml()}async createInferenceSessionHandler(t,r){let a=new En;return await a.loadModel(t,r),Promise.resolve(a)}}});var Il={};Dt(Il,{wasmBackend:()=>Rp});var Rp,Al=F(()=>{"use strict";Cl();Rp=new _n});var Pp={};Dt(Pp,{InferenceSession:()=>$o,TRACE:()=>mr,TRACE_FUNC_BEGIN:()=>je,TRACE_FUNC_END:()=>qe,Tensor:()=>Ve,TrainingSession:()=>Io,configureTrace:()=>Yr,default:()=>kp,env:()=>Ie,registerBackend:()=>gt});ot();ot();ot();var Eo="1.17.0";var kp=Nn;{let e=(Al(),St(Il)).wasmBackend;typeof navigator<"u"&&navigator.gpu&&gt("webgpu",e,5),gt("cpu",e,10),gt("wasm",e,10),gt("xnnpack",e,9),gt("webnn",e,9)}Object.defineProperty(Ie.versions,"web",{value:Eo,enumerable:!0});return St(Pp);})();
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
//# sourceMappingURL=ort.webgpu.min.js.map
