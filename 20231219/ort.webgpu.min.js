/*!
 * ONNX Runtime Web v1.17.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";var ort=(()=>{var Mn=Object.defineProperty;var Ql=Object.getOwnPropertyDescriptor;var Xl=Object.getOwnPropertyNames;var Jl=Object.prototype.hasOwnProperty;var q=(e,t)=>()=>(e&&(t=e(e=0)),t);var Zt=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Vt=(e,t)=>{for(var r in t)Mn(e,r,{get:t[r],enumerable:!0})},ed=(e,t,r,a)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Xl(t))!Jl.call(e,n)&&n!==r&&Mn(e,n,{get:()=>t[n],enumerable:!(a=Ql(t,n))||a.enumerable});return e};var At=e=>ed(Mn({},"__esModule",{value:!0}),e);var Lr,Ut,St,Gr,Fr=q(()=>{"use strict";Lr=new Map,Ut=[],St=(e,t,r)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){let a=Lr.get(e);if(a===void 0)Lr.set(e,{backend:t,priority:r});else{if(a.priority>r)return;if(a.priority===r&&a.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${r}`)}if(r>=0){let n=Ut.indexOf(e);n!==-1&&Ut.splice(n,1);for(let o=0;o<Ut.length;o++)if(Lr.get(Ut[o]).priority<=r){Ut.splice(o,0,e);return}Ut.push(e)}return}throw new TypeError("not a valid backend")},Gr=async e=>{let t=e.length===0?Ut:e,r=[];for(let a of t){let n=Lr.get(a);if(n){if(n.initialized)return n.backend;if(n.aborted)continue;let o=!!n.initPromise;try{return o||(n.initPromise=n.backend.init()),await n.initPromise,n.initialized=!0,n.backend}catch(u){o||r.push({name:a,err:u}),n.aborted=!0}finally{delete n.initPromise}}}throw new Error(`no available backend found. ERR: ${r.map(a=>`[${a.name}] ${a.err}`).join(", ")}`)}});var ei=q(()=>{"use strict";Fr()});var ti,ri=q(()=>{"use strict";ti="1.17.0"});var ni,zn,ai=q(()=>{"use strict";ri();ni="warning",zn={wasm:{},webgl:{},webgpu:{},versions:{common:ti},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);ni=e}},get logLevel(){return ni}};Object.defineProperty(zn,"logLevel",{enumerable:!0})});var Ee,ii=q(()=>{"use strict";ai();Ee=zn});var oi,si,ui=q(()=>{"use strict";oi=(e,t)=>{let r=document.createElement("canvas");r.width=e.dims[3],r.height=e.dims[2];let a=r.getContext("2d");if(a!=null){let n,o;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(n=e.dims[2],o=e.dims[3]):(n=e.dims[3],o=e.dims[2]);let u=t?.format!==void 0?t.format:"RGB",l=t?.norm,i,c;l===void 0||l.mean===void 0?i=[255,255,255,255]:typeof l.mean=="number"?i=[l.mean,l.mean,l.mean,l.mean]:(i=[l.mean[0],l.mean[1],l.mean[2],0],l.mean[3]!==void 0&&(i[3]=l.mean[3])),l===void 0||l.bias===void 0?c=[0,0,0,0]:typeof l.bias=="number"?c=[l.bias,l.bias,l.bias,l.bias]:(c=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(c[3]=l.bias[3]));let f=o*n,g=0,m=f,w=f*2,b=-1;u==="RGBA"?(g=0,m=f,w=f*2,b=f*3):u==="RGB"?(g=0,m=f,w=f*2):u==="RBG"&&(g=0,w=f,m=f*2);for(let $=0;$<o;$++)for(let I=0;I<n;I++){let S=(e.data[g++]-c[0])*i[0],_=(e.data[m++]-c[1])*i[1],k=(e.data[w++]-c[2])*i[2],A=b===-1?255:(e.data[b++]-c[3])*i[3];a.fillStyle="rgba("+S+","+_+","+k+","+A+")",a.fillRect(I,$,1,1)}return r.toDataURL()}else throw new Error("Can not access image data")},si=(e,t)=>{let r=document.createElement("canvas").getContext("2d"),a;if(r!=null){let n,o,u;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(n=e.dims[2],o=e.dims[1],u=e.dims[3]):(n=e.dims[3],o=e.dims[2],u=e.dims[1]);let l=t!==void 0&&t.format!==void 0?t.format:"RGB",i=t?.norm,c,f;i===void 0||i.mean===void 0?c=[255,255,255,255]:typeof i.mean=="number"?c=[i.mean,i.mean,i.mean,i.mean]:(c=[i.mean[0],i.mean[1],i.mean[2],255],i.mean[3]!==void 0&&(c[3]=i.mean[3])),i===void 0||i.bias===void 0?f=[0,0,0,0]:typeof i.bias=="number"?f=[i.bias,i.bias,i.bias,i.bias]:(f=[i.bias[0],i.bias[1],i.bias[2],0],i.bias[3]!==void 0&&(f[3]=i.bias[3]));let g=o*n;if(t!==void 0&&(t.format!==void 0&&u===4&&t.format!=="RGBA"||u===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let m=4,w=0,b=1,$=2,I=3,S=0,_=g,k=g*2,A=-1;l==="RGBA"?(S=0,_=g,k=g*2,A=g*3):l==="RGB"?(S=0,_=g,k=g*2):l==="RBG"&&(S=0,k=g,_=g*2),a=r.createImageData(n,o);for(let z=0;z<o*n;w+=m,b+=m,$+=m,I+=m,z++)a.data[w]=(e.data[S++]-f[0])*c[0],a.data[b]=(e.data[_++]-f[1])*c[1],a.data[$]=(e.data[k++]-f[2])*c[2],a.data[I]=A===-1?255:(e.data[A++]-f[3])*c[3]}else throw new Error("Can not access image data");return a}});var Dn,li,di,ci,pi,fi=q(()=>{"use strict";qr();Dn=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:r,width:a}=t,n=t.norm??{mean:255,bias:0},o,u;typeof n.mean=="number"?o=[n.mean,n.mean,n.mean,n.mean]:o=[n.mean[0],n.mean[1],n.mean[2],n.mean[3]??255],typeof n.bias=="number"?u=[n.bias,n.bias,n.bias,n.bias]:u=[n.bias[0],n.bias[1],n.bias[2],n.bias[3]??0];let l=t.format!==void 0?t.format:"RGBA",i=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",c=r*a,f=i==="RGBA"?new Float32Array(c*4):new Float32Array(c*3),g=4,m=0,w=1,b=2,$=3,I=0,S=c,_=c*2,k=-1;l==="RGB"&&(g=3,m=0,w=1,b=2,$=-1),i==="RGBA"?k=c*3:i==="RBG"?(I=0,_=c,S=c*2):i==="BGR"&&(_=0,S=c,I=c*2);for(let z=0;z<c;z++,m+=g,b+=g,w+=g,$+=g)f[I++]=(e[m]+u[0])/o[0],f[S++]=(e[w]+u[1])/o[1],f[_++]=(e[b]+u[2])/o[2],k!==-1&&$!==-1&&(f[k++]=(e[$]+u[3])/o[3]);return i==="RGBA"?new Qe("float32",f,[1,4,r,a]):new Qe("float32",f,[1,3,r,a])},li=async(e,t)=>{let r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,a=typeof ImageData<"u"&&e instanceof ImageData,n=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,o=typeof e=="string",u,l=t??{};if(r){let i=document.createElement("canvas");i.width=e.width,i.height=e.height;let c=i.getContext("2d");if(c!=null){let f=e.height,g=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(f=t.resizedHeight,g=t.resizedWidth),t!==void 0){if(l=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");l.tensorFormat="RGBA",l.height=f,l.width=g}else l.tensorFormat="RGBA",l.height=f,l.width=g;c.drawImage(e,0,0),u=c.getImageData(0,0,g,f).data}else throw new Error("Can not access image data")}else if(a){let i,c;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(i=t.resizedHeight,c=t.resizedWidth):(i=e.height,c=e.width),t!==void 0&&(l=t),l.format="RGBA",l.height=i,l.width=c,t!==void 0){let f=document.createElement("canvas");f.width=c,f.height=i;let g=f.getContext("2d");if(g!=null)g.putImageData(e,0,0),u=g.getImageData(0,0,c,i).data;else throw new Error("Can not access image data")}else u=e.data}else if(n){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");let i=document.createElement("canvas");i.width=e.width,i.height=e.height;let c=i.getContext("2d");if(c!=null){let f=e.height,g=e.width;return c.drawImage(e,0,0,g,f),u=c.getImageData(0,0,g,f).data,l.height=f,l.width=g,Dn(u,l)}else throw new Error("Can not access image data")}else{if(o)return new Promise((i,c)=>{let f=document.createElement("canvas"),g=f.getContext("2d");if(!e||!g)return c();let m=new Image;m.crossOrigin="Anonymous",m.src=e,m.onload=()=>{f.width=m.width,f.height=m.height,g.drawImage(m,0,0,f.width,f.height);let w=g.getImageData(0,0,f.width,f.height);l.height=f.height,l.width=f.width,i(Dn(w.data,l))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(u!==void 0)return Dn(u,l);throw new Error("Input data provided is not supported - aborted tensor creation")},di=(e,t)=>{let{width:r,height:a,download:n,dispose:o}=t,u=[1,a,r,4];return new Qe({location:"texture",type:"float32",texture:e,dims:u,download:n,dispose:o})},ci=(e,t)=>{let{dataType:r,dims:a,download:n,dispose:o}=t;return new Qe({location:"gpu-buffer",type:r??"float32",gpuBuffer:e,dims:a,download:n,dispose:o})},pi=(e,t,r)=>new Qe({location:"cpu-pinned",type:e,data:t,dims:r??[t.length]})});var yr,jr,mi,hi,gi=q(()=>{"use strict";yr=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),jr=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),mi=!1,hi=()=>{if(!mi){mi=!0;let e=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",t=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";e&&(yr.set("int64",BigInt64Array),jr.set(BigInt64Array,"int64")),t&&(yr.set("uint64",BigUint64Array),jr.set(BigUint64Array,"uint64"))}}});var yi,bi,wi=q(()=>{"use strict";qr();yi=e=>{let t=1;for(let r=0;r<e.length;r++){let a=e[r];if(typeof a!="number"||!Number.isSafeInteger(a))throw new TypeError(`dims[${r}] must be an integer, got: ${a}`);if(a<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${a}`);t*=a}return t},bi=(e,t)=>{switch(e.location){case"cpu":return new Qe(e.type,e.data,t);case"cpu-pinned":return new Qe({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new Qe({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new Qe({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}});var Qe,qr=q(()=>{"use strict";ui();fi();gi();wi();Qe=class{constructor(t,r,a){hi();let n,o;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,n=t.type,o=t.dims,t.location){case"cpu-pinned":{let l=yr.get(n);if(!l)throw new TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(t.data instanceof l))throw new TypeError(`buffer should be of type ${l.name}`);this.cpuData=t.data;break}case"texture":{if(n!=="float32")throw new TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(n!=="float32"&&n!=="float16"&&n!=="int32"&&n!=="int64"&&n!=="uint32"&&n!=="bool")throw new TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let l,i;if(typeof t=="string")if(n=t,i=a,t==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");l=r}else{let c=yr.get(t);if(c===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(r)){if(t==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");t==="uint64"||t==="int64"?l=c.from(r,BigInt):l=c.from(r)}else if(r instanceof c)l=r;else throw new TypeError(`A ${n} tensor's data must be type of ${c}`)}else if(i=r,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let c=typeof t[0];if(c==="string")n="string",l=t;else if(c==="boolean")n="bool",l=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${c}.`)}else{let c=jr.get(t.constructor);if(c===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);n=c,l=t}if(i===void 0)i=[l.length];else if(!Array.isArray(i))throw new TypeError("A tensor's dims must be a number array");o=i,this.cpuData=l,this.dataLocation="cpu"}let u=yi(o);if(this.cpuData&&u!==this.cpuData.length)throw new Error(`Tensor's size(${u}) does not match data length(${this.cpuData.length}).`);this.type=n,this.dims=o,this.size=u}static async fromImage(t,r){return li(t,r)}static fromTexture(t,r){return di(t,r)}static fromGpuBuffer(t,r){return ci(t,r)}static fromPinnedBuffer(t,r,a){return pi(t,r,a)}toDataURL(t){return oi(this,t)}toImageData(t){return si(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,t&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return bi(this,t)}}});var Ke,Kr=q(()=>{"use strict";qr();Ke=Qe});var Yr,vi=q(()=>{"use strict";Fr();Kr();Yr=class e{constructor(t){this.handler=t}async run(t,r,a){let n={},o={};if(typeof t!="object"||t===null||t instanceof Ke||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let u=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof Ke)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");u=!1;for(let c of r){if(typeof c!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(c)===-1)throw new RangeError(`'fetches' contains invalid output name: ${c}.`);n[c]=null}if(typeof a=="object"&&a!==null)o=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let c=!1,f=Object.getOwnPropertyNames(r);for(let g of this.outputNames)if(f.indexOf(g)!==-1){let m=r[g];(m===null||m instanceof Ke)&&(c=!0,u=!1,n[g]=m)}if(c){if(typeof a=="object"&&a!==null)o=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else o=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let c of this.inputNames)if(typeof t[c]>"u")throw new Error(`input '${c}' is missing in 'feeds'.`);if(u)for(let c of this.outputNames)n[c]=null;let l=await this.handler.run(t,n,o),i={};for(let c in l)if(Object.hasOwnProperty.call(l,c)){let f=l[c];f instanceof Ke?i[c]=f:i[c]=new Ke(f.type,f.data,f.dims)}return i}async release(){return this.handler.dispose()}static async create(t,r,a,n){let o,u={};if(typeof t=="string"){if(o=t,typeof r=="object"&&r!==null)u=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(o=t,typeof r=="object"&&r!==null)u=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){let g=t,m=0,w=t.byteLength;if(typeof r=="object"&&r!==null)u=r;else if(typeof r=="number"){if(m=r,!Number.isSafeInteger(m))throw new RangeError("'byteOffset' must be an integer.");if(m<0||m>=g.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${g.byteLength}).`);if(w=t.byteLength-m,typeof a=="number"){if(w=a,!Number.isSafeInteger(w))throw new RangeError("'byteLength' must be an integer.");if(w<=0||m+w>g.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${g.byteLength-m}].`);if(typeof n=="object"&&n!==null)u=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(typeof a<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof r<"u")throw new TypeError("'options' must be an object.");o=new Uint8Array(g,m,w)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let i=(u.executionProviders||[]).map(g=>typeof g=="string"?g:g.name),f=await(await Gr(i)).createInferenceSessionHandler(o,u);return new e(f)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var $i,Si=q(()=>{"use strict";vi();$i=Yr});var xi=q(()=>{"use strict"});var td,Zr,_i=q(()=>{"use strict";Fr();Kr();td="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",Zr=class e{constructor(t,r,a){this.handler=t,this.hasOptimizerModel=r,this.hasEvalModel=a}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(t,r){let a=t.evalModel||"",n=t.optimizerModel||"",o=r||{},l=(o.executionProviders||[]).map(c=>typeof c=="string"?c:c.name),i=await Gr(l);if(i.createTrainingSessionHandler){let c=await i.createTrainingSessionHandler(t.checkpointState,t.trainModel,a,n,o);return new e(c,!!t.optimizerModel,!!t.evalModel)}else throw new Error(td)}typeNarrowingForRunStep(t,r,a,n,o){let u={},l={};if(typeof a!="object"||a===null||a instanceof Ke||Array.isArray(a))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof Ke)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(let c of n){if(typeof c!="string")throw new TypeError("'fetches' must be a string array or an object.");if(r.indexOf(c)===-1)throw new RangeError(`'fetches' contains invalid output name: ${c}.`);u[c]=null}if(typeof o=="object"&&o!==null)l=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else{let c=!1,f=Object.getOwnPropertyNames(n);for(let g of r)if(f.indexOf(g)!==-1){let m=n[g];(m===null||m instanceof Ke)&&(c=!0,i=!1,u[g]=m)}if(c){if(typeof o=="object"&&o!==null)l=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else l=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let c of t)if(typeof a[c]>"u")throw new Error(`input '${c}' is missing in 'feeds'.`);if(i)for(let c of r)u[c]=null;return[u,l]}convertHandlerReturnTypeToMapOfTensors(t){let r={};for(let a in t)if(Object.hasOwnProperty.call(t,a)){let n=t[a];n instanceof Ke?r[a]=n:r[a]=new Ke(n.type,n.data,n.dims)}return r}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(t,r,a){let[n,o]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,t,r,a),u=await this.handler.runTrainStep(t,n,o);return this.convertHandlerReturnTypeToMapOfTensors(u)}async runOptimizerStep(t){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(t||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(t,r,a){if(this.hasEvalModel){let[n,o]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,t,r,a),u=await this.handler.runEvalStep(t,n,o);return this.convertHandlerReturnTypeToMapOfTensors(u)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(t=!0){return this.handler.getParametersSize(t)}async loadParametersBuffer(t,r=!0){let a=await this.getParametersSize(r);if(t.length!==4*a)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(t,r)}async getContiguousParameters(t=!0){return this.handler.getContiguousParameters(t)}async release(){return this.handler.dispose()}}});var Ci,Ii=q(()=>{"use strict";_i();Ci=Zr});var Wn={};Vt(Wn,{InferenceSession:()=>$i,Tensor:()=>Ke,TrainingSession:()=>Ci,env:()=>Ee,registerBackend:()=>St});var ct=q(()=>{"use strict";ei();ii();Si();Kr();xi();Ii()});var Vn={};Vt(Vn,{readFile:()=>rd});var rd,Un=q(()=>{rd=void 0});var Nn={};Vt(Nn,{join:()=>nd});var nd,Hn=q(()=>{nd=void 0});var Oi=Zt((Ti,Ln)=>{"use strict";var Ei=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,a,n;r.ready=new Promise((d,h)=>{a=d,n=h}),r.jsepInit=(d,h,v,C,O,F,H,de)=>{r.Za=d,r.Oa=h,r.Qa=v,r.Ja=C,r.Pa=O,r.ra=F,r.Ra=H,r.Sa=de,h=(Q,ie,te)=>(...ge)=>{let Se=nt,R=ie?.();ge=Q(...ge);let se=ie?.();return R!==se&&(Q=se,te(R),ie=te=null),nt!=Se?Pr():ge},v=Q=>async(...ie)=>{try{if(r.Da)throw Error("Session already started");let te=r.Da={Ta:ie[0],errors:[]},ge=await Q(...ie);if(r.Da!==te)throw Error("Session mismatch");d.flush();let Se=te.errors;if(0<Se.length){let R=await Promise.all(Se);if(R=R.filter(se=>se),0<R.length)throw Error(R.join(`
`))}return ge}finally{r.Da=null}},r._OrtRun=v(h(r._OrtRun,()=>r._OrtRun,Q=>r._OrtRun=Q)),r._OrtRunWithBinding=v(h(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,Q=>r._OrtRunWithBinding=Q)),r._OrtBindInput=h(r._OrtBindInput,()=>r._OrtBindInput,Q=>r._OrtBindInput=Q),r.jsepRegisterBuffer=(Q,ie,te,ge)=>d.registerBuffer(Q,ie,te,ge),r.jsepUnregisterBuffers=Q=>{d.unregisterBuffers(Q)},r.jsepGetBuffer=Q=>d.getBuffer(Q),r.jsepCreateDownloader=(Q,ie,te)=>d.createDownloader(Q,ie,te)};var o=Object.assign({},r),u="./this.program",l=(d,h)=>{throw h},i=typeof window=="object",c=typeof importScripts=="function",f=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",g="",m,w,b;if(f){var $=(Un(),At(Vn)),I=(Hn(),At(Nn));g=c?I.dirname(g)+"/":__dirname+"/",m=(d,h)=>(d=d.startsWith("file://")?new URL(d):I.normalize(d),$.readFileSync(d,h?void 0:"utf8")),b=d=>(d=m(d,!0),d.buffer||(d=new Uint8Array(d)),d),w=(d,h,v,C=!0)=>{d=d.startsWith("file://")?new URL(d):I.normalize(d),$.readFile(d,C?void 0:"utf8",(O,F)=>{O?v(O):h(C?F.buffer:F)})},!r.thisProgram&&1<process.argv.length&&(u=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),l=(d,h)=>{throw process.exitCode=d,h},r.inspect=()=>"[Emscripten Module object]"}else(i||c)&&(c?g=self.location.href:typeof document<"u"&&document.currentScript&&(g=document.currentScript.src),e&&(g=e),g.indexOf("blob:")!==0?g=g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):g="",m=d=>{var h=new XMLHttpRequest;return h.open("GET",d,!1),h.send(null),h.responseText},c&&(b=d=>{var h=new XMLHttpRequest;return h.open("GET",d,!1),h.responseType="arraybuffer",h.send(null),new Uint8Array(h.response)}),w=(d,h,v)=>{var C=new XMLHttpRequest;C.open("GET",d,!0),C.responseType="arraybuffer",C.onload=()=>{C.status==200||C.status==0&&C.response?h(C.response):v()},C.onerror=v,C.send(null)});var S=r.print||console.log.bind(console),_=r.printErr||console.error.bind(console);Object.assign(r,o),o=null,r.thisProgram&&(u=r.thisProgram),r.quit&&(l=r.quit);var k;r.wasmBinary&&(k=r.wasmBinary);var A=r.noExitRuntime||!0;typeof WebAssembly!="object"&&Le("no native wasm support detected");var z,E,U=!1,W,L,X,B,j,pe,J;function we(){var d=z.buffer;r.HEAP8=L=new Int8Array(d),r.HEAP16=new Int16Array(d),r.HEAP32=B=new Int32Array(d),r.HEAPU8=X=new Uint8Array(d),r.HEAPU16=new Uint16Array(d),r.HEAPU32=j=new Uint32Array(d),r.HEAPF32=pe=new Float32Array(d),r.HEAPF64=J=new Float64Array(d)}var Z=[],ye=[],_e=[];function me(){var d=r.preRun.shift();Z.unshift(d)}var ce=0,He=null,Me=null;function Le(d){throw r.onAbort&&r.onAbort(d),d="Aborted("+d+")",_(d),U=!0,W=1,d=new WebAssembly.RuntimeError(d+". Build with -sASSERTIONS for more info."),n(d),d}function G(d){return d.startsWith("data:application/octet-stream;base64,")}var ne;if(ne="ort-wasm-simd.wasm",!G(ne)){var he=ne;ne=r.locateFile?r.locateFile(he,g):g+he}function qe(d){if(d==ne&&k)return new Uint8Array(k);if(b)return b(d);throw"both async and sync fetching of the wasm failed"}function Je(d){if(!k&&(i||c)){if(typeof fetch=="function"&&!d.startsWith("file://"))return fetch(d,{credentials:"same-origin"}).then(h=>{if(!h.ok)throw"failed to load wasm binary file at '"+d+"'";return h.arrayBuffer()}).catch(()=>qe(d));if(w)return new Promise((h,v)=>{w(d,C=>h(new Uint8Array(C)),v)})}return Promise.resolve().then(()=>qe(d))}function ze(d,h,v){return Je(d).then(C=>WebAssembly.instantiate(C,h)).then(C=>C).then(v,C=>{_("failed to asynchronously prepare wasm: "+C),Le(C)})}function Ge(d,h){var v=ne;return k||typeof WebAssembly.instantiateStreaming!="function"||G(v)||v.startsWith("file://")||f||typeof fetch!="function"?ze(v,d,h):fetch(v,{credentials:"same-origin"}).then(C=>WebAssembly.instantiateStreaming(C,d).then(h,function(O){return _("wasm streaming compile failed: "+O),_("falling back to ArrayBuffer instantiation"),ze(v,d,h)}))}var Ze,ut={1424824:d=>{r.ra("Abs",d,void 0)},1424875:d=>{r.ra("Neg",d,void 0)},1424926:d=>{r.ra("Floor",d,void 0)},1424979:d=>{r.ra("Ceil",d,void 0)},1425031:d=>{r.ra("Reciprocal",d,void 0)},1425089:d=>{r.ra("Sqrt",d,void 0)},1425141:d=>{r.ra("Exp",d,void 0)},1425192:d=>{r.ra("Erf",d,void 0)},1425243:d=>{r.ra("Sigmoid",d,void 0)},1425298:d=>{r.ra("Log",d,void 0)},1425349:d=>{r.ra("Sin",d,void 0)},1425400:d=>{r.ra("Cos",d,void 0)},1425451:d=>{r.ra("Tan",d,void 0)},1425502:d=>{r.ra("Asin",d,void 0)},1425554:d=>{r.ra("Acos",d,void 0)},1425606:d=>{r.ra("Atan",d,void 0)},1425658:d=>{r.ra("Sinh",d,void 0)},1425710:d=>{r.ra("Cosh",d,void 0)},1425762:d=>{r.ra("Asinh",d,void 0)},1425815:d=>{r.ra("Acosh",d,void 0)},1425868:d=>{r.ra("Atanh",d,void 0)},1425921:d=>{r.ra("Tanh",d,void 0)},1425973:d=>{r.ra("Not",d,void 0)},1426024:(d,h,v)=>{r.ra("Clip",d,{min:h,max:v})},1426093:d=>{r.ra("Clip",d,void 0)},1426145:(d,h)=>{r.ra("Elu",d,{alpha:h})},1426203:d=>{r.ra("Relu",d,void 0)},1426255:(d,h)=>{r.ra("LeakyRelu",d,{alpha:h})},1426319:(d,h)=>{r.ra("ThresholdedRelu",d,{alpha:h})},1426389:d=>{r.Ra(d)},1426423:(d,h)=>r.Sa(d,h,r.Da.Ta,r.Da.errors),1426535:(d,h)=>{r.ra("Cast",d,{to:h})},1426593:d=>{r.ra("Add",d,void 0)},1426644:d=>{r.ra("Sub",d,void 0)},1426695:d=>{r.ra("Mul",d,void 0)},1426746:d=>{r.ra("Div",d,void 0)},1426797:d=>{r.ra("Pow",d,void 0)},1426848:d=>{r.ra("Equal",d,void 0)},1426901:d=>{r.ra("Greater",d,void 0)},1426956:d=>{r.ra("GreaterOrEqual",d,void 0)},1427018:d=>{r.ra("Less",d,void 0)},1427070:d=>{r.ra("LessOrEqual",d,void 0)},1427129:(d,h,v,C,O)=>{r.ra("ReduceMean",d,{keepDims:!!h,noopWithEmptyAxes:!!v,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},1427293:(d,h,v,C,O)=>{r.ra("ReduceMax",d,{keepDims:!!h,noopWithEmptyAxes:!!v,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},1427456:(d,h,v,C,O)=>{r.ra("ReduceMin",d,{keepDims:!!h,noopWithEmptyAxes:!!v,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},1427619:(d,h,v,C,O)=>{r.ra("ReduceProd",d,{keepDims:!!h,noopWithEmptyAxes:!!v,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},1427783:(d,h,v,C,O)=>{r.ra("ReduceSum",d,{keepDims:!!h,noopWithEmptyAxes:!!v,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},1427946:(d,h,v,C,O)=>{r.ra("ReduceL1",d,{keepDims:!!h,noopWithEmptyAxes:!!v,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},1428108:(d,h,v,C,O)=>{r.ra("ReduceL2",d,{keepDims:!!h,noopWithEmptyAxes:!!v,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},1428270:(d,h,v,C,O)=>{r.ra("ReduceLogSum",d,{keepDims:!!h,noopWithEmptyAxes:!!v,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},1428436:(d,h,v,C,O)=>{r.ra("ReduceSumSquare",d,{keepDims:!!h,noopWithEmptyAxes:!!v,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},1428605:(d,h,v,C,O)=>{r.ra("ReduceLogSumExp",d,{keepDims:!!h,noopWithEmptyAxes:!!v,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},1428774:d=>{r.ra("Where",d,void 0)},1428827:(d,h,v)=>{r.ra("Transpose",d,{perm:h?Array.from(B.subarray(v>>>0,v+h>>>0)):[]})},1428940:(d,h,v,C,O,F,H,de,Q,ie,te,ge,Se)=>{r.ra("Conv",d,{format:Q?"NHWC":"NCHW",auto_pad:h,dilations:[v],group:C,kernel_shape:[O],pads:F?Array.from(B.subarray(H>>>0,H+F>>>0)):[],strides:[de],w_is_const:()=>!!L[ie>>>0],activation:Ue(te),activation_params:ge?Array.from(pe.subarray(Se>>>0,Se+ge>>>0)):[]})},1429321:(d,h,v,C,O,F,H,de,Q,ie,te,ge,Se,R,se,ve)=>{r.ra("Conv",d,{format:ge?"NHWC":"NCHW",auto_pad:h,dilations:[v,C],group:O,kernel_shape:[F,H],pads:de?Array.from(B.subarray(Q>>>0,Q+de>>>0)):[],strides:[ie,te],w_is_const:()=>!!L[Se>>>0],activation:Ue(R),activation_params:se?Array.from(pe.subarray(ve>>>0,ve+se>>>0)):[]})},1429723:(d,h,v,C,O,F,H,de,Q,ie,te,ge,Se,R,se)=>{r.ra("ConvTranspose",d,{format:Q?"NHWC":"NCHW",autoPad:h,dilations:[v],group:C,kernel_shape:[O],pads:[F,H],strides:[de],wIsConst:()=>!!L[ie>>>0],outputPadding:te?Array.from(B.subarray(ge>>>0,ge+te>>>0)):[],outputShape:Se?Array.from(B.subarray(R>>>0,R+Se>>>0)):[],activation:Ue(se)})},1430137:(d,h,v,C,O,F,H,de,Q,ie,te,ge,Se,R)=>{r.ra("ConvTranspose",d,{format:de?"NHWC":"NCHW",autoPad:h,dilations:Array.from(B.subarray(v>>>0,v+2>>>0)),group:C,kernelShape:Array.from(B.subarray(O>>>0,O+2>>>0)),pads:Array.from(B.subarray(F>>>0,F+4>>>0)),strides:Array.from(B.subarray(H>>>0,H+2>>>0)),wIsConst:()=>!!L[Q>>>0],outputPadding:0<ie?Array.from(B.subarray(te>>>0,te+ie>>>0)):[],outputShape:0<ge?Array.from(B.subarray(Se>>>0,Se+ge>>>0)):[],activation:Ue(R)})},1430694:(d,h,v,C,O,F,H,de,Q,ie,te,ge,Se,R,se)=>{r.ra("ConvTranspose",d,{format:Q?"NHWC":"NCHW",autoPad:h,dilations:[v],group:C,kernel_shape:[O],pads:[F,H],strides:[de],wIsConst:()=>!!L[ie>>>0],outputPadding:te?Array.from(B.subarray(ge>>>0,ge+te>>>0)):[],outputShape:Se?Array.from(B.subarray(R>>>0,R+Se>>>0)):[],activation:Ue(se)})},1431108:(d,h,v,C,O,F,H,de,Q,ie,te,ge,Se,R)=>{r.ra("ConvTranspose",d,{format:de?"NHWC":"NCHW",autoPad:h,dilations:Array.from(B.subarray(v>>>0,v+2>>>0)),group:C,kernelShape:Array.from(B.subarray(O>>>0,O+2>>>0)),pads:Array.from(B.subarray(F>>>0,F+4>>>0)),strides:Array.from(B.subarray(H>>>0,H+2>>>0)),wIsConst:()=>!!L[Q>>>0],outputPadding:0<ie?Array.from(B.subarray(te>>>0,te+ie>>>0)):[],outputShape:0<ge?Array.from(B.subarray(Se>>>0,Se+ge>>>0)):[],activation:Ue(R)})},1431665:(d,h)=>{r.ra("GlobalAveragePool",d,{format:h?"NHWC":"NCHW"})},1431756:(d,h,v,C,O,F,H,de,Q,ie,te,ge,Se,R,se,ve)=>{r.ra("AveragePool",d,{format:ve?"NHWC":"NCHW",auto_pad:h,ceil_mode:v,count_include_pad:C,storage_order:O,dilations:[F,H],kernel_shape:[de,Q],pads:[ie,te,ge,Se],strides:[R,se]})},1432040:(d,h)=>{r.ra("GlobalAveragePool",d,{format:h?"NHWC":"NCHW"})},1432131:(d,h,v,C,O,F,H,de,Q,ie,te,ge,Se,R,se,ve)=>{r.ra("AveragePool",d,{format:ve?"NHWC":"NCHW",auto_pad:h,ceil_mode:v,count_include_pad:C,storage_order:O,dilations:[F,H],kernel_shape:[de,Q],pads:[ie,te,ge,Se],strides:[R,se]})},1432415:(d,h)=>{r.ra("GlobalMaxPool",d,{format:h?"NHWC":"NCHW"})},1432502:(d,h,v,C,O,F,H,de,Q,ie,te,ge,Se,R,se,ve)=>{r.ra("MaxPool",d,{format:ve?"NHWC":"NCHW",auto_pad:h,ceil_mode:v,count_include_pad:C,storage_order:O,dilations:[F,H],kernel_shape:[de,Q],pads:[ie,te,ge,Se],strides:[R,se]})},1432782:(d,h)=>{r.ra("GlobalMaxPool",d,{format:h?"NHWC":"NCHW"})},1432869:(d,h,v,C,O,F,H,de,Q,ie,te,ge,Se,R,se,ve)=>{r.ra("MaxPool",d,{format:ve?"NHWC":"NCHW",auto_pad:h,ceil_mode:v,count_include_pad:C,storage_order:O,dilations:[F,H],kernel_shape:[de,Q],pads:[ie,te,ge,Se],strides:[R,se]})},1433149:(d,h,v,C,O)=>{r.ra("Gemm",d,{alpha:h,beta:v,transA:C,transB:O})},1433253:d=>{r.ra("MatMul",d,void 0)},1433307:(d,h,v,C)=>{r.ra("ArgMax",d,{keepDims:!!h,selectLastIndex:!!v,axis:C})},1433415:(d,h,v,C)=>{r.ra("ArgMin",d,{keepDims:!!h,selectLastIndex:!!v,axis:C})},1433523:(d,h)=>{r.ra("Softmax",d,{axis:h})},1433586:(d,h)=>{r.ra("Concat",d,{axis:h})},1433646:(d,h,v,C,O)=>{r.ra("Split",d,{axis:h,numOutputs:v,splitSizes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},1433791:d=>{r.ra("Expand",d,void 0)},1433845:(d,h)=>{r.ra("Gather",d,{axis:Number(h)})},1433916:(d,h)=>{r.ra("GatherElements",d,{axis:Number(h)})},1433995:(d,h,v,C,O,F,H,de,Q,ie,te)=>{r.ra("Resize",d,{antialias:h,axes:v?Array.from(B.subarray(C>>>0,C+v>>>0)):[],coordinateTransformMode:Ue(O),cubicCoeffA:F,excludeOutside:H,extrapolationValue:de,keepAspectRatioPolicy:Ue(Q),mode:Ue(ie),nearestMode:Ue(te)})},1434346:(d,h,v,C,O,F,H)=>{r.ra("Slice",d,{starts:h?Array.from(B.subarray(v>>>0,v+h>>>0)):[],ends:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[],axes:F?Array.from(B.subarray(H>>>0,H+F>>>0)):[]})},1434577:d=>{r.ra("Tile",d,void 0)},1434629:(d,h,v)=>{r.ra("LayerNormalization",d,{axis:Number(h),epsilon:Number(v)})},1434736:(d,h,v)=>{r.ra("InstanceNormalization",d,{epsilon:h,format:v?"NHWC":"NCHW"})},1434850:(d,h,v)=>{r.ra("InstanceNormalization",d,{epsilon:h,format:v?"NHWC":"NCHW"})},1434964:d=>{r.ra("Range",d,void 0)},1435017:(d,h)=>{r.ra("Einsum",d,{equation:Ue(h)})},1435098:(d,h,v,C,O)=>{r.ra("Pad",d,{mode:h,value:v,pads:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},1435230:(d,h,v,C,O,F)=>{r.ra("BatchNormalization",d,{epsilon:h,momentum:v,spatial:!!O,trainingMode:!!C,format:F?"NHWC":"NCHW"})},1435399:(d,h,v,C,O,F)=>{r.ra("BatchNormalization",d,{epsilon:h,momentum:v,spatial:!!O,trainingMode:!!C,format:F?"NHWC":"NCHW"})},1435568:(d,h,v)=>{r.ra("CumSum",d,{exclusive:Number(h),reverse:Number(v)})},1435665:(d,h,v,C,O,F,H,de,Q)=>{r.ra("Attention",d,{numHeads:h,isUnidirectional:v,maskFilterValue:C,scale:O,doRotary:F,qkvHiddenSizes:H?Array.from(B.subarray(Number(de)>>>0,Number(de)+H>>>0)):[],pastPresentShareBuffer:!!Q})},1435937:d=>{r.ra("Gelu",d,void 0)},1435989:(d,h,v,C,O,F)=>{r.ra("MultiHeadAttention",d,{numHeads:h,isUnidirectional:v,maskFilterValue:C,scale:O,doRotary:F})},1436148:d=>{r.ra("BiasAdd",d,void 0)},1436203:d=>{r.ra("BiasSplitGelu",d,void 0)},1436264:(d,h)=>{r.ra("SkipLayerNormalization",d,{epsilon:h})},1436345:d=>r.Oa(d),1436378:d=>r.Qa(d),1436410:(d,h,v)=>{r.Ja(d,h,v,!0)},1436449:(d,h,v)=>{r.Ja(d,h,v)}};function rt(d){this.name="ExitStatus",this.message=`Program terminated with exit(${d})`,this.status=d}var Rt=d=>{for(;0<d.length;)d.shift()(r)};function Pt(d){this.Ha=d-24,this.Ma=function(h){j[this.Ha+4>>2>>>0]=h},this.La=function(h){j[this.Ha+8>>2>>>0]=h},this.Ya=function(h,v){this.Ka(),this.Ma(h),this.La(v)},this.Ka=function(){j[this.Ha+16>>2>>>0]=0}}var er=0,Ir=0,it=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,tr=(d,h,v)=>{h>>>=0;var C=h+v;for(v=h;d[v]&&!(v>=C);)++v;if(16<v-h&&d.buffer&&it)return it.decode(d.subarray(h,v));for(C="";h<v;){var O=d[h++];if(O&128){var F=d[h++]&63;if((O&224)==192)C+=String.fromCharCode((O&31)<<6|F);else{var H=d[h++]&63;O=(O&240)==224?(O&15)<<12|F<<6|H:(O&7)<<18|F<<12|H<<6|d[h++]&63,65536>O?C+=String.fromCharCode(O):(O-=65536,C+=String.fromCharCode(55296|O>>10,56320|O&1023))}}else C+=String.fromCharCode(O)}return C},Ue=(d,h)=>(d>>>=0)?tr(X,d,h):"",Lt=d=>{for(var h=0,v=0;v<d.length;++v){var C=d.charCodeAt(v);127>=C?h++:2047>=C?h+=2:55296<=C&&57343>=C?(h+=4,++v):h+=3}return h},rr=(d,h,v,C)=>{if(v>>>=0,!(0<C))return 0;var O=v;C=v+C-1;for(var F=0;F<d.length;++F){var H=d.charCodeAt(F);if(55296<=H&&57343>=H){var de=d.charCodeAt(++F);H=65536+((H&1023)<<10)|de&1023}if(127>=H){if(v>=C)break;h[v++>>>0]=H}else{if(2047>=H){if(v+1>=C)break;h[v++>>>0]=192|H>>6}else{if(65535>=H){if(v+2>=C)break;h[v++>>>0]=224|H>>12}else{if(v+3>=C)break;h[v++>>>0]=240|H>>18,h[v++>>>0]=128|H>>12&63}h[v++>>>0]=128|H>>6&63}h[v++>>>0]=128|H&63}}return h[v>>>0]=0,v-O},bt=d=>d%4===0&&(d%100!==0||d%400===0),Ar=[0,31,60,91,121,152,182,213,244,274,305,335],wt=[0,31,59,90,120,151,181,212,243,273,304,334],Gt=d=>{var h=Lt(d)+1,v=Kt(h);return v&&rr(d,X,v,h),v},_t=[],Ft=(d,h)=>{_t.length=0;var v;for(h>>=2;v=X[d++>>>0];)h+=v!=105&h,_t.push(v==105?B[h>>>0]:J[h++>>>1]),++h;return _t},qt={},nr=()=>{if(!jt){var d={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:u||"./this.program"},h;for(h in qt)qt[h]===void 0?delete d[h]:d[h]=qt[h];var v=[];for(h in d)v.push(`${h}=${d[h]}`);jt=v}return jt},jt,Er=[null,[],[]],je=[31,29,31,30,31,30,31,31,30,31,30,31],ar=[31,28,31,30,31,30,31,31,30,31,30,31];function ir(d){var h=Array(Lt(d)+1);return rr(d,h,0,h.length),h}function le(d,h,v,C){function O(R,se,ve){for(R=typeof R=="number"?R.toString():R||"";R.length<se;)R=ve[0]+R;return R}function F(R,se){return O(R,se,"0")}function H(R,se){function ve(gr){return 0>gr?-1:0<gr?1:0}var $t;return($t=ve(R.getFullYear()-se.getFullYear()))===0&&($t=ve(R.getMonth()-se.getMonth()))===0&&($t=ve(R.getDate()-se.getDate())),$t}function de(R){switch(R.getDay()){case 0:return new Date(R.getFullYear()-1,11,29);case 1:return R;case 2:return new Date(R.getFullYear(),0,3);case 3:return new Date(R.getFullYear(),0,2);case 4:return new Date(R.getFullYear(),0,1);case 5:return new Date(R.getFullYear()-1,11,31);case 6:return new Date(R.getFullYear()-1,11,30)}}function Q(R){var se=R.Ba;for(R=new Date(new Date(R.Ca+1900,0,1).getTime());0<se;){var ve=R.getMonth(),$t=(bt(R.getFullYear())?je:ar)[ve];if(se>$t-R.getDate())se-=$t-R.getDate()+1,R.setDate(1),11>ve?R.setMonth(ve+1):(R.setMonth(0),R.setFullYear(R.getFullYear()+1));else{R.setDate(R.getDate()+se);break}}return ve=new Date(R.getFullYear()+1,0,4),se=de(new Date(R.getFullYear(),0,4)),ve=de(ve),0>=H(se,R)?0>=H(ve,R)?R.getFullYear()+1:R.getFullYear():R.getFullYear()-1}d>>>=0,h>>>=0,v>>>=0,C>>>=0;var ie=B[C+40>>2>>>0];C={Wa:B[C>>2>>>0],Va:B[C+4>>2>>>0],Ea:B[C+8>>2>>>0],Ia:B[C+12>>2>>>0],Fa:B[C+16>>2>>>0],Ca:B[C+20>>2>>>0],wa:B[C+24>>2>>>0],Ba:B[C+28>>2>>>0],$a:B[C+32>>2>>>0],Ua:B[C+36>>2>>>0],Xa:ie?Ue(ie):""},v=Ue(v),ie={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var te in ie)v=v.replace(new RegExp(te,"g"),ie[te]);var ge="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Se="January February March April May June July August September October November December".split(" ");ie={"%a":R=>ge[R.wa].substring(0,3),"%A":R=>ge[R.wa],"%b":R=>Se[R.Fa].substring(0,3),"%B":R=>Se[R.Fa],"%C":R=>F((R.Ca+1900)/100|0,2),"%d":R=>F(R.Ia,2),"%e":R=>O(R.Ia,2," "),"%g":R=>Q(R).toString().substring(2),"%G":R=>Q(R),"%H":R=>F(R.Ea,2),"%I":R=>(R=R.Ea,R==0?R=12:12<R&&(R-=12),F(R,2)),"%j":R=>{for(var se=0,ve=0;ve<=R.Fa-1;se+=(bt(R.Ca+1900)?je:ar)[ve++]);return F(R.Ia+se,3)},"%m":R=>F(R.Fa+1,2),"%M":R=>F(R.Va,2),"%n":()=>`
`,"%p":R=>0<=R.Ea&&12>R.Ea?"AM":"PM","%S":R=>F(R.Wa,2),"%t":()=>"	","%u":R=>R.wa||7,"%U":R=>F(Math.floor((R.Ba+7-R.wa)/7),2),"%V":R=>{var se=Math.floor((R.Ba+7-(R.wa+6)%7)/7);if(2>=(R.wa+371-R.Ba-2)%7&&se++,se)se==53&&(ve=(R.wa+371-R.Ba)%7,ve==4||ve==3&&bt(R.Ca)||(se=1));else{se=52;var ve=(R.wa+7-R.Ba-1)%7;(ve==4||ve==5&&bt(R.Ca%400-1))&&se++}return F(se,2)},"%w":R=>R.wa,"%W":R=>F(Math.floor((R.Ba+7-(R.wa+6)%7)/7),2),"%y":R=>(R.Ca+1900).toString().substring(2),"%Y":R=>R.Ca+1900,"%z":R=>{R=R.Ua;var se=0<=R;return R=Math.abs(R)/60,(se?"+":"-")+("0000"+(R/60*100+R%60)).slice(-4)},"%Z":R=>R.Xa,"%%":()=>"%"},v=v.replace(/%%/g,"\0\0");for(te in ie)v.includes(te)&&(v=v.replace(new RegExp(te,"g"),ie[te](C)));return v=v.replace(/\0\0/g,"%"),te=ir(v),te.length>h?0:(L.set(te,d>>>0),te.length-1)}function vt(d){try{d()}catch(h){Le(h)}}function Tr(d){var h={},v;for(v in d)(function(C){var O=d[C];h[C]=typeof O=="function"?function(){Bt.push(C);try{return O.apply(null,arguments)}finally{U||(Bt.pop()===C||Le(),nt&&lt===1&&Bt.length===0&&(lt=0,vt(mr),typeof Fibers<"u"&&Fibers.ab()))}}:O})(v);return h}var lt=0,nt=null,Or=0,Bt=[],or={},sr={},kr=0,Mt=null,Rr=[];function Pr(){return new Promise((d,h)=>{Mt={resolve:d,reject:h}})}function Br(){var d=Kt(65548),h=d+12;j[d>>2>>>0]=h,j[d+4>>2>>>0]=h+65536,h=Bt[0];var v=or[h];return v===void 0&&(v=kr++,or[h]=v,sr[v]=h),B[d+8>>2>>>0]=v,d}function Mr(d){if(!U){if(lt===0){var h=!1,v=!1;d((C=0)=>{if(!U&&(Or=C,h=!0,v)){lt=2,vt(()=>Yt(nt)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),C=!1;try{var O=(0,E[sr[B[nt+8>>2>>>0]]])()}catch(de){O=de,C=!0}var F=!1;if(!nt){var H=Mt;H&&(Mt=null,(C?H.reject:H.resolve)(O),F=!0)}if(C&&!F)throw O}}),v=!0,h||(lt=1,nt=Br(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),vt(()=>fr(nt)))}else lt===2?(lt=0,vt(zt),ur(nt),nt=null,Rr.forEach(C=>{if(!U)try{if(C(),!A)try{W=W=C=W,A||(r.onExit&&r.onExit(C),U=!0),l(C,new rt(C))}catch(O){O instanceof rt||O=="unwind"||l(1,O)}}catch(O){O instanceof rt||O=="unwind"||l(1,O)}})):Le(`invalid state: ${lt}`);return Or}}function zr(d){return Mr(h=>{d().then(h)})}var Dr={n:function(d,h,v){return zr(async()=>{await r.Pa(d,h,v)})},a:function(d,h,v){throw d>>>=0,new Pt(d).Ya(h>>>0,v>>>0),er=d,Ir++,er},d:function(){return 0},L:function(){},A:function(){},C:function(){},u:function(){return 0},J:function(){},E:function(){},I:function(){},l:function(){},B:function(){},y:function(){},K:function(){},z:function(){},m:()=>!0,q:function(d,h,v){d=h+2097152>>>0<4194305-!!d?(d>>>0)+4294967296*h:NaN,v>>>=0,d=new Date(1e3*d),B[v>>2>>>0]=d.getUTCSeconds(),B[v+4>>2>>>0]=d.getUTCMinutes(),B[v+8>>2>>>0]=d.getUTCHours(),B[v+12>>2>>>0]=d.getUTCDate(),B[v+16>>2>>>0]=d.getUTCMonth(),B[v+20>>2>>>0]=d.getUTCFullYear()-1900,B[v+24>>2>>>0]=d.getUTCDay(),B[v+28>>2>>>0]=(d.getTime()-Date.UTC(d.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(d,h,v){d=h+2097152>>>0<4194305-!!d?(d>>>0)+4294967296*h:NaN,v>>>=0,d=new Date(1e3*d),B[v>>2>>>0]=d.getSeconds(),B[v+4>>2>>>0]=d.getMinutes(),B[v+8>>2>>>0]=d.getHours(),B[v+12>>2>>>0]=d.getDate(),B[v+16>>2>>>0]=d.getMonth(),B[v+20>>2>>>0]=d.getFullYear()-1900,B[v+24>>2>>>0]=d.getDay(),B[v+28>>2>>>0]=(bt(d.getFullYear())?Ar:wt)[d.getMonth()]+d.getDate()-1|0,B[v+36>>2>>>0]=-(60*d.getTimezoneOffset()),h=new Date(d.getFullYear(),6,1).getTimezoneOffset();var C=new Date(d.getFullYear(),0,1).getTimezoneOffset();B[v+32>>2>>>0]=(h!=C&&d.getTimezoneOffset()==Math.min(C,h))|0},s:function(d){d>>>=0;var h=new Date(B[d+20>>2>>>0]+1900,B[d+16>>2>>>0],B[d+12>>2>>>0],B[d+8>>2>>>0],B[d+4>>2>>>0],B[d>>2>>>0],0),v=B[d+32>>2>>>0],C=h.getTimezoneOffset(),O=new Date(h.getFullYear(),6,1).getTimezoneOffset(),F=new Date(h.getFullYear(),0,1).getTimezoneOffset(),H=Math.min(F,O);return 0>v?B[d+32>>2>>>0]=+(O!=F&&H==C):0<v!=(H==C)&&(O=Math.max(F,O),h.setTime(h.getTime()+6e4*((0<v?H:O)-C))),B[d+24>>2>>>0]=h.getDay(),B[d+28>>2>>>0]=(bt(h.getFullYear())?Ar:wt)[h.getMonth()]+h.getDate()-1|0,B[d>>2>>>0]=h.getSeconds(),B[d+4>>2>>>0]=h.getMinutes(),B[d+8>>2>>>0]=h.getHours(),B[d+12>>2>>>0]=h.getDate(),B[d+16>>2>>>0]=h.getMonth(),B[d+20>>2>>>0]=h.getYear(),d=h.getTime()/1e3,lr((Ze=d,1<=+Math.abs(Ze)?0<Ze?+Math.floor(Ze/4294967296)>>>0:~~+Math.ceil((Ze-+(~~Ze>>>0))/4294967296)>>>0:0)),d>>>0},o:function(){return-52},p:function(){},w:function(d,h,v){function C(Q){return(Q=Q.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Q[1]:"GMT"}v>>>=0;var O=new Date().getFullYear(),F=new Date(O,0,1),H=new Date(O,6,1);O=F.getTimezoneOffset();var de=H.getTimezoneOffset();j[d>>>0>>2>>>0]=60*Math.max(O,de),B[h>>>0>>2>>>0]=+(O!=de),d=C(F),h=C(H),d=Gt(d),h=Gt(h),de<O?(j[v>>2>>>0]=d,j[v+4>>2>>>0]=h):(j[v>>2>>>0]=h,j[v+4>>2>>>0]=d)},e:()=>{Le("")},b:function(d,h,v){return d>>>=0,h=Ft(h>>>0,v>>>0),ut[d].apply(null,h)},j:function(d,h,v){return d>>>=0,h=Ft(h>>>0,v>>>0),ut[d].apply(null,h)},i:function(){return Date.now()},x:function(){return 4294901760},f:()=>performance.now(),H:function(d,h,v){return h>>>=0,X.copyWithin(d>>>0>>>0,h>>>0,h+(v>>>0)>>>0)},v:function(d){d>>>=0;var h=X.length;if(4294901760<d)return!1;for(var v=1;4>=v;v*=2){var C=h*(1+.2/v);C=Math.min(C,d+100663296);var O=Math;C=Math.max(d,C);e:{O=O.min.call(O,4294901760,C+(65536-C%65536)%65536)-z.buffer.byteLength+65535>>>16;try{z.grow(O),we();var F=1;break e}catch{}F=void 0}if(F)return!0}return!1},F:function(d,h){d>>>=0,h>>>=0;var v=0;return nr().forEach(function(C,O){var F=h+v;for(O=j[d+4*O>>2>>>0]=F,F=0;F<C.length;++F)L[O++>>0>>>0]=C.charCodeAt(F);L[O>>0>>>0]=0,v+=C.length+1}),0},G:function(d,h){d>>>=0,h>>>=0;var v=nr();j[d>>2>>>0]=v.length;var C=0;return v.forEach(function(O){C+=O.length+1}),j[h>>2>>>0]=C,0},g:()=>52,k:function(){return 52},t:function(){return 70},h:function(d,h,v,C){h>>>=0,v>>>=0,C>>>=0;for(var O=0,F=0;F<v;F++){var H=j[h>>2>>>0],de=j[h+4>>2>>>0];h+=8;for(var Q=0;Q<de;Q++){var ie=X[H+Q>>>0],te=Er[d];ie===0||ie===10?((d===1?S:_)(tr(te,0)),te.length=0):te.push(ie)}O+=de}return j[C>>2>>>0]=O,0},D:le,c:function(d,h,v,C){return le(d>>>0,h>>>0,v>>>0,C>>>0)}};(function(){function d(v){if(v=v.exports,v=Tr(v),E=v=Ct(v),z=E.M,we(),ye.unshift(E.N),ce--,r.monitorRunDependencies&&r.monitorRunDependencies(ce),ce==0&&(He!==null&&(clearInterval(He),He=null),Me)){var C=Me;Me=null,C()}return v}var h={a:Dr};if(ce++,r.monitorRunDependencies&&r.monitorRunDependencies(ce),r.instantiateWasm)try{return r.instantiateWasm(h,d)}catch(v){_("Module.instantiateWasm callback failed with error: "+v),n(v)}return Ge(h,function(v){d(v.instance)}).catch(n),{}})(),r._OrtInit=(d,h)=>(r._OrtInit=E.O)(d,h),r._OrtGetLastError=(d,h)=>(r._OrtGetLastError=E.P)(d,h),r._OrtCreateSessionOptions=(d,h,v,C,O,F,H,de,Q,ie)=>(r._OrtCreateSessionOptions=E.Q)(d,h,v,C,O,F,H,de,Q,ie),r._OrtAppendExecutionProvider=(d,h)=>(r._OrtAppendExecutionProvider=E.R)(d,h),r._OrtAddFreeDimensionOverride=(d,h,v)=>(r._OrtAddFreeDimensionOverride=E.S)(d,h,v),r._OrtAddSessionConfigEntry=(d,h,v)=>(r._OrtAddSessionConfigEntry=E.T)(d,h,v),r._OrtReleaseSessionOptions=d=>(r._OrtReleaseSessionOptions=E.U)(d),r._OrtCreateSession=(d,h,v)=>(r._OrtCreateSession=E.V)(d,h,v),r._OrtReleaseSession=d=>(r._OrtReleaseSession=E.W)(d),r._OrtGetInputOutputCount=(d,h,v)=>(r._OrtGetInputOutputCount=E.X)(d,h,v),r._OrtGetInputName=(d,h)=>(r._OrtGetInputName=E.Y)(d,h),r._OrtGetOutputName=(d,h)=>(r._OrtGetOutputName=E.Z)(d,h),r._OrtFree=d=>(r._OrtFree=E._)(d),r._OrtCreateTensor=(d,h,v,C,O,F)=>(r._OrtCreateTensor=E.$)(d,h,v,C,O,F),r._OrtGetTensorData=(d,h,v,C,O)=>(r._OrtGetTensorData=E.aa)(d,h,v,C,O),r._OrtReleaseTensor=d=>(r._OrtReleaseTensor=E.ba)(d),r._OrtCreateRunOptions=(d,h,v,C)=>(r._OrtCreateRunOptions=E.ca)(d,h,v,C),r._OrtAddRunConfigEntry=(d,h,v)=>(r._OrtAddRunConfigEntry=E.da)(d,h,v),r._OrtReleaseRunOptions=d=>(r._OrtReleaseRunOptions=E.ea)(d),r._OrtCreateBinding=d=>(r._OrtCreateBinding=E.fa)(d),r._OrtBindInput=(d,h,v)=>(r._OrtBindInput=E.ga)(d,h,v),r._OrtBindOutput=(d,h,v,C)=>(r._OrtBindOutput=E.ha)(d,h,v,C),r._OrtClearBoundOutputs=d=>(r._OrtClearBoundOutputs=E.ia)(d),r._OrtReleaseBinding=d=>(r._OrtReleaseBinding=E.ja)(d),r._OrtRunWithBinding=(d,h,v,C,O)=>(r._OrtRunWithBinding=E.ka)(d,h,v,C,O),r._OrtRun=(d,h,v,C,O,F,H,de)=>(r._OrtRun=E.la)(d,h,v,C,O,F,H,de),r._OrtEndProfiling=d=>(r._OrtEndProfiling=E.ma)(d),r._JsepOutput=(d,h,v)=>(r._JsepOutput=E.na)(d,h,v),r._JsepGetNodeName=d=>(r._JsepGetNodeName=E.oa)(d);var Kt=r._malloc=d=>(Kt=r._malloc=E.pa)(d),ur=r._free=d=>(ur=r._free=E.qa)(d),lr=d=>(lr=E.sa)(d),dr=()=>(dr=E.ta)(),cr=d=>(cr=E.ua)(d),pr=d=>(pr=E.va)(d),fr=d=>(fr=E.xa)(d),mr=()=>(mr=E.ya)(),Yt=d=>(Yt=E.za)(d),zt=()=>(zt=E.Aa)();r.___start_em_js=1436482,r.___stop_em_js=1436643;function Ct(d){d=Object.assign({},d);var h=C=>()=>C()>>>0,v=C=>O=>C(O)>>>0;return d.__errno_location=h(d.__errno_location),d.malloc=v(d.malloc),d.stackSave=h(d.stackSave),d.stackAlloc=v(d.stackAlloc),d}r.stackAlloc=pr,r.stackSave=dr,r.stackRestore=cr,r.UTF8ToString=Ue,r.stringToUTF8=(d,h,v)=>rr(d,X,h,v),r.lengthBytesUTF8=Lt;var Dt;Me=function d(){Dt||hr(),Dt||(Me=d)};function hr(){function d(){if(!Dt&&(Dt=!0,r.calledRun=!0,!U)){if(Rt(ye),a(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var h=r.postRun.shift();_e.unshift(h)}Rt(_e)}}if(!(0<ce)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)me();Rt(Z),0<ce||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),d()},1)):d())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return hr(),t.ready}})();typeof Ti=="object"&&typeof Ln=="object"?Ln.exports=Ei:typeof define=="function"&&define.amd&&define([],()=>Ei)});var ki=Zt(()=>{});var Ri=Zt(()=>{});var Pi={};Vt(Pi,{cpus:()=>ad});var ad,Bi=q(()=>{ad=void 0});var Di=Zt((zi,Gn)=>{"use strict";var Mi=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return we.buffer!=ce.buffer&&he(),ce}function a(){return we.buffer!=ce.buffer&&he(),He}function n(){return we.buffer!=ce.buffer&&he(),Me}function o(){return we.buffer!=ce.buffer&&he(),Le}function u(){return we.buffer!=ce.buffer&&he(),G}function l(){return we.buffer!=ce.buffer&&he(),ne}var i=t,c,f;i.ready=new Promise((s,p)=>{c=s,f=p}),i.jsepInit=(s,p,y,x,T,M,N,oe)=>{i.Qb=s,i.wb=p,i.yb=y,i.jb=x,i.xb=T,i.Ea=M,i.zb=N,i.Ab=oe,p=(re,ae,ue)=>(...xe)=>{let Ie=dt,P=ae?.();xe=re(...xe);let fe=ae?.();return P!==fe&&(re=fe,ue(P),ae=ue=null),dt!=Ie?Ll():xe},y=re=>async(...ae)=>{try{if(i.bb)throw Error("Session already started");let ue=i.bb={Fb:ae[0],errors:[]},xe=await re(...ae);if(i.bb!==ue)throw Error("Session mismatch");s.flush();let Ie=ue.errors;if(0<Ie.length){let P=await Promise.all(Ie);if(P=P.filter(fe=>fe),0<P.length)throw Error(P.join(`
`))}return xe}finally{i.bb=null}},i._OrtRun=y(p(i._OrtRun,()=>i._OrtRun,re=>i._OrtRun=re)),i._OrtRunWithBinding=y(p(i._OrtRunWithBinding,()=>i._OrtRunWithBinding,re=>i._OrtRunWithBinding=re)),i._OrtBindInput=p(i._OrtBindInput,()=>i._OrtBindInput,re=>i._OrtBindInput=re),i.jsepRegisterBuffer=(re,ae,ue,xe)=>s.registerBuffer(re,ae,ue,xe),i.jsepUnregisterBuffers=re=>{s.unregisterBuffers(re)},i.jsepGetBuffer=re=>s.getBuffer(re),i.jsepCreateDownloader=(re,ae,ue)=>s.createDownloader(re,ae,ue)};var g=Object.assign({},i),m="./this.program",w=(s,p)=>{throw p},b=typeof window=="object",$=typeof importScripts=="function",I=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",S=i.ENVIRONMENT_IS_PTHREAD||!1,_="";function k(s){return i.locateFile?i.locateFile(s,_):_+s}var A,z,E;if(I){var U=(Un(),At(Vn)),W=(Hn(),At(Nn));_=$?W.dirname(_)+"/":__dirname+"/",A=(p,y)=>(p=p.startsWith("file://")?new URL(p):W.normalize(p),U.readFileSync(p,y?void 0:"utf8")),E=p=>(p=A(p,!0),p.buffer||(p=new Uint8Array(p)),p),z=(p,y,x,T=!0)=>{p=p.startsWith("file://")?new URL(p):W.normalize(p),U.readFile(p,T?void 0:"utf8",(M,N)=>{M?x(M):y(T?N.buffer:N)})},!i.thisProgram&&1<process.argv.length&&(m=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),w=(p,y)=>{throw process.exitCode=p,y},i.inspect=()=>"[Emscripten Module object]";let s;try{s=ki()}catch(p){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),p}global.Worker=s.Worker}else(b||$)&&($?_=self.location.href:typeof document<"u"&&document.currentScript&&(_=document.currentScript.src),typeof e<"u"&&e&&(_=e),_.indexOf("blob:")!==0?_=_.substr(0,_.replace(/[?#].*/,"").lastIndexOf("/")+1):_="",I||(A=s=>{var p=new XMLHttpRequest;return p.open("GET",s,!1),p.send(null),p.responseText},$&&(E=s=>{var p=new XMLHttpRequest;return p.open("GET",s,!1),p.responseType="arraybuffer",p.send(null),new Uint8Array(p.response)}),z=(s,p,y)=>{var x=new XMLHttpRequest;x.open("GET",s,!0),x.responseType="arraybuffer",x.onload=()=>{x.status==200||x.status==0&&x.response?p(x.response):y()},x.onerror=y,x.send(null)}));I&&typeof performance>"u"&&(global.performance=Ri().performance);var L=console.log.bind(console),X=console.error.bind(console);I&&(L=(...s)=>U.writeSync(1,s.join(" ")+`
`),X=(...s)=>U.writeSync(2,s.join(" ")+`
`));var B=i.print||L,j=i.printErr||X;Object.assign(i,g),g=null,i.thisProgram&&(m=i.thisProgram),i.quit&&(w=i.quit);var pe;i.wasmBinary&&(pe=i.wasmBinary);var J=i.noExitRuntime||!0;typeof WebAssembly!="object"&&it("no native wasm support detected");var we,Z,ye,_e=!1,me,ce,He,Me,Le,G,ne;function he(){var s=we.buffer;i.HEAP8=ce=new Int8Array(s),i.HEAP16=new Int16Array(s),i.HEAP32=Me=new Int32Array(s),i.HEAPU8=He=new Uint8Array(s),i.HEAPU16=new Uint16Array(s),i.HEAPU32=Le=new Uint32Array(s),i.HEAPF32=G=new Float32Array(s),i.HEAPF64=ne=new Float64Array(s)}var qe=i.INITIAL_MEMORY||16777216;if(5242880<=qe||it("INITIAL_MEMORY should be larger than STACK_SIZE, was "+qe+"! (STACK_SIZE=5242880)"),S)we=i.wasmMemory;else if(i.wasmMemory)we=i.wasmMemory;else if(we=new WebAssembly.Memory({initial:qe/65536,maximum:65536,shared:!0}),!(we.buffer instanceof SharedArrayBuffer))throw j("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),I&&j("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");he(),qe=we.buffer.byteLength;var Je=[],ze=[],Ge=[],Ze=0;function ut(){return J||0<Ze}var rt=0,Rt=null,Pt=null;function er(){rt++,i.monitorRunDependencies&&i.monitorRunDependencies(rt)}function Ir(){if(rt--,i.monitorRunDependencies&&i.monitorRunDependencies(rt),rt==0&&(Rt!==null&&(clearInterval(Rt),Rt=null),Pt)){var s=Pt;Pt=null,s()}}function it(s){throw i.onAbort&&i.onAbort(s),s="Aborted("+s+")",j(s),_e=!0,me=1,s=new WebAssembly.RuntimeError(s+". Build with -sASSERTIONS for more info."),f(s),s}function tr(s){return s.startsWith("data:application/octet-stream;base64,")}var Ue;Ue="ort-wasm-simd-threaded.wasm",tr(Ue)||(Ue=k(Ue));function Lt(s){if(s==Ue&&pe)return new Uint8Array(pe);if(E)return E(s);throw"both async and sync fetching of the wasm failed"}function rr(s){if(!pe&&(b||$)){if(typeof fetch=="function"&&!s.startsWith("file://"))return fetch(s,{credentials:"same-origin"}).then(p=>{if(!p.ok)throw"failed to load wasm binary file at '"+s+"'";return p.arrayBuffer()}).catch(()=>Lt(s));if(z)return new Promise((p,y)=>{z(s,x=>p(new Uint8Array(x)),y)})}return Promise.resolve().then(()=>Lt(s))}function bt(s,p,y){return rr(s).then(x=>WebAssembly.instantiate(x,p)).then(x=>x).then(y,x=>{j("failed to asynchronously prepare wasm: "+x),it(x)})}function Ar(s,p){var y=Ue;return pe||typeof WebAssembly.instantiateStreaming!="function"||tr(y)||y.startsWith("file://")||I||typeof fetch!="function"?bt(y,s,p):fetch(y,{credentials:"same-origin"}).then(x=>WebAssembly.instantiateStreaming(x,s).then(p,function(T){return j("wasm streaming compile failed: "+T),j("falling back to ArrayBuffer instantiation"),bt(y,s,p)}))}var wt,Gt={913596:s=>{i.Ea("Abs",s,void 0)},913647:s=>{i.Ea("Neg",s,void 0)},913698:s=>{i.Ea("Floor",s,void 0)},913751:s=>{i.Ea("Ceil",s,void 0)},913803:s=>{i.Ea("Reciprocal",s,void 0)},913861:s=>{i.Ea("Sqrt",s,void 0)},913913:s=>{i.Ea("Exp",s,void 0)},913964:s=>{i.Ea("Erf",s,void 0)},914015:s=>{i.Ea("Sigmoid",s,void 0)},914070:s=>{i.Ea("Log",s,void 0)},914121:s=>{i.Ea("Sin",s,void 0)},914172:s=>{i.Ea("Cos",s,void 0)},914223:s=>{i.Ea("Tan",s,void 0)},914274:s=>{i.Ea("Asin",s,void 0)},914326:s=>{i.Ea("Acos",s,void 0)},914378:s=>{i.Ea("Atan",s,void 0)},914430:s=>{i.Ea("Sinh",s,void 0)},914482:s=>{i.Ea("Cosh",s,void 0)},914534:s=>{i.Ea("Asinh",s,void 0)},914587:s=>{i.Ea("Acosh",s,void 0)},914640:s=>{i.Ea("Atanh",s,void 0)},914693:s=>{i.Ea("Tanh",s,void 0)},914745:s=>{i.Ea("Not",s,void 0)},914796:(s,p,y)=>{i.Ea("Clip",s,{min:p,max:y})},914865:s=>{i.Ea("Clip",s,void 0)},914917:(s,p)=>{i.Ea("Elu",s,{alpha:p})},914975:s=>{i.Ea("Relu",s,void 0)},915027:(s,p)=>{i.Ea("LeakyRelu",s,{alpha:p})},915091:(s,p)=>{i.Ea("ThresholdedRelu",s,{alpha:p})},915161:(s,p)=>{i.Ea("Cast",s,{to:p})},915219:s=>{i.Ea("Add",s,void 0)},915270:s=>{i.Ea("Sub",s,void 0)},915321:s=>{i.Ea("Mul",s,void 0)},915372:s=>{i.Ea("Div",s,void 0)},915423:s=>{i.Ea("Pow",s,void 0)},915474:s=>{i.Ea("Equal",s,void 0)},915527:s=>{i.Ea("Greater",s,void 0)},915582:s=>{i.Ea("GreaterOrEqual",s,void 0)},915644:s=>{i.Ea("Less",s,void 0)},915696:s=>{i.Ea("LessOrEqual",s,void 0)},915755:(s,p,y,x,T)=>{i.Ea("ReduceMean",s,{keepDims:!!p,noopWithEmptyAxes:!!y,axes:x?Array.from(n().subarray(T>>>0,T+x>>>0)):[]})},915919:(s,p,y,x,T)=>{i.Ea("ReduceMax",s,{keepDims:!!p,noopWithEmptyAxes:!!y,axes:x?Array.from(n().subarray(T>>>0,T+x>>>0)):[]})},916082:(s,p,y,x,T)=>{i.Ea("ReduceMin",s,{keepDims:!!p,noopWithEmptyAxes:!!y,axes:x?Array.from(n().subarray(T>>>0,T+x>>>0)):[]})},916245:(s,p,y,x,T)=>{i.Ea("ReduceProd",s,{keepDims:!!p,noopWithEmptyAxes:!!y,axes:x?Array.from(n().subarray(T>>>0,T+x>>>0)):[]})},916409:(s,p,y,x,T)=>{i.Ea("ReduceSum",s,{keepDims:!!p,noopWithEmptyAxes:!!y,axes:x?Array.from(n().subarray(T>>>0,T+x>>>0)):[]})},916572:(s,p,y,x,T)=>{i.Ea("ReduceL1",s,{keepDims:!!p,noopWithEmptyAxes:!!y,axes:x?Array.from(n().subarray(T>>>0,T+x>>>0)):[]})},916734:(s,p,y,x,T)=>{i.Ea("ReduceL2",s,{keepDims:!!p,noopWithEmptyAxes:!!y,axes:x?Array.from(n().subarray(T>>>0,T+x>>>0)):[]})},916896:(s,p,y,x,T)=>{i.Ea("ReduceLogSum",s,{keepDims:!!p,noopWithEmptyAxes:!!y,axes:x?Array.from(n().subarray(T>>>0,T+x>>>0)):[]})},917062:(s,p,y,x,T)=>{i.Ea("ReduceSumSquare",s,{keepDims:!!p,noopWithEmptyAxes:!!y,axes:x?Array.from(n().subarray(T>>>0,T+x>>>0)):[]})},917231:(s,p,y,x,T)=>{i.Ea("ReduceLogSumExp",s,{keepDims:!!p,noopWithEmptyAxes:!!y,axes:x?Array.from(n().subarray(T>>>0,T+x>>>0)):[]})},917400:s=>{i.Ea("Where",s,void 0)},917453:(s,p,y)=>{i.Ea("Transpose",s,{perm:p?Array.from(n().subarray(y>>>0,y+p>>>0)):[]})},917566:(s,p,y,x,T,M,N,oe,re,ae,ue,xe,Ie,P,fe)=>{i.Ea("ConvTranspose",s,{format:re?"NHWC":"NCHW",autoPad:p,dilations:[y],group:x,kernel_shape:[T],pads:[M,N],strides:[oe],wIsConst:()=>!!r()[ae>>>0],outputPadding:ue?Array.from(n().subarray(xe>>>0,xe+ue>>>0)):[],outputShape:Ie?Array.from(n().subarray(P>>>0,P+Ie>>>0)):[],activation:je(fe)})},917980:(s,p,y,x,T,M,N,oe,re,ae,ue,xe,Ie,P)=>{i.Ea("ConvTranspose",s,{format:oe?"NHWC":"NCHW",autoPad:p,dilations:Array.from(n().subarray(y>>>0,y+2>>>0)),group:x,kernelShape:Array.from(n().subarray(T>>>0,T+2>>>0)),pads:Array.from(n().subarray(M>>>0,M+4>>>0)),strides:Array.from(n().subarray(N>>>0,N+2>>>0)),wIsConst:()=>!!r()[re>>>0],outputPadding:0<ae?Array.from(n().subarray(ue>>>0,ue+ae>>>0)):[],outputShape:0<xe?Array.from(n().subarray(Ie>>>0,Ie+xe>>>0)):[],activation:je(P)})},918537:(s,p,y,x,T,M,N,oe,re,ae,ue,xe,Ie,P,fe)=>{i.Ea("ConvTranspose",s,{format:re?"NHWC":"NCHW",autoPad:p,dilations:[y],group:x,kernel_shape:[T],pads:[M,N],strides:[oe],wIsConst:()=>!!r()[ae>>>0],outputPadding:ue?Array.from(n().subarray(xe>>>0,xe+ue>>>0)):[],outputShape:Ie?Array.from(n().subarray(P>>>0,P+Ie>>>0)):[],activation:je(fe)})},918951:(s,p,y,x,T,M,N,oe,re,ae,ue,xe,Ie,P)=>{i.Ea("ConvTranspose",s,{format:oe?"NHWC":"NCHW",autoPad:p,dilations:Array.from(n().subarray(y>>>0,y+2>>>0)),group:x,kernelShape:Array.from(n().subarray(T>>>0,T+2>>>0)),pads:Array.from(n().subarray(M>>>0,M+4>>>0)),strides:Array.from(n().subarray(N>>>0,N+2>>>0)),wIsConst:()=>!!r()[re>>>0],outputPadding:0<ae?Array.from(n().subarray(ue>>>0,ue+ae>>>0)):[],outputShape:0<xe?Array.from(n().subarray(Ie>>>0,Ie+xe>>>0)):[],activation:je(P)})},919508:(s,p)=>{i.Ea("GlobalAveragePool",s,{format:p?"NHWC":"NCHW"})},919599:(s,p,y,x,T,M,N,oe,re,ae,ue,xe,Ie,P,fe,Ce)=>{i.Ea("AveragePool",s,{format:Ce?"NHWC":"NCHW",auto_pad:p,ceil_mode:y,count_include_pad:x,storage_order:T,dilations:[M,N],kernel_shape:[oe,re],pads:[ae,ue,xe,Ie],strides:[P,fe]})},919883:(s,p)=>{i.Ea("GlobalAveragePool",s,{format:p?"NHWC":"NCHW"})},919974:(s,p,y,x,T,M,N,oe,re,ae,ue,xe,Ie,P,fe,Ce)=>{i.Ea("AveragePool",s,{format:Ce?"NHWC":"NCHW",auto_pad:p,ceil_mode:y,count_include_pad:x,storage_order:T,dilations:[M,N],kernel_shape:[oe,re],pads:[ae,ue,xe,Ie],strides:[P,fe]})},920258:(s,p)=>{i.Ea("GlobalMaxPool",s,{format:p?"NHWC":"NCHW"})},920345:(s,p,y,x,T,M,N,oe,re,ae,ue,xe,Ie,P,fe,Ce)=>{i.Ea("MaxPool",s,{format:Ce?"NHWC":"NCHW",auto_pad:p,ceil_mode:y,count_include_pad:x,storage_order:T,dilations:[M,N],kernel_shape:[oe,re],pads:[ae,ue,xe,Ie],strides:[P,fe]})},920625:(s,p)=>{i.Ea("GlobalMaxPool",s,{format:p?"NHWC":"NCHW"})},920712:(s,p,y,x,T,M,N,oe,re,ae,ue,xe,Ie,P,fe,Ce)=>{i.Ea("MaxPool",s,{format:Ce?"NHWC":"NCHW",auto_pad:p,ceil_mode:y,count_include_pad:x,storage_order:T,dilations:[M,N],kernel_shape:[oe,re],pads:[ae,ue,xe,Ie],strides:[P,fe]})},920992:(s,p,y,x,T)=>{i.Ea("Gemm",s,{alpha:p,beta:y,transA:x,transB:T})},921096:s=>{i.Ea("MatMul",s,void 0)},921150:(s,p,y,x)=>{i.Ea("ArgMax",s,{keepDims:!!p,selectLastIndex:!!y,axis:x})},921258:(s,p,y,x)=>{i.Ea("ArgMin",s,{keepDims:!!p,selectLastIndex:!!y,axis:x})},921366:(s,p)=>{i.Ea("Softmax",s,{axis:p})},921429:(s,p)=>{i.Ea("Concat",s,{axis:p})},921489:(s,p,y,x,T)=>{i.Ea("Split",s,{axis:p,numOutputs:y,splitSizes:x?Array.from(n().subarray(T>>>0,T+x>>>0)):[]})},921634:s=>{i.Ea("Expand",s,void 0)},921688:(s,p)=>{i.Ea("Gather",s,{axis:Number(p)})},921759:(s,p)=>{i.Ea("GatherElements",s,{axis:Number(p)})},921838:(s,p,y,x,T,M,N,oe,re,ae,ue)=>{i.Ea("Resize",s,{antialias:p,axes:y?Array.from(n().subarray(x>>>0,x+y>>>0)):[],coordinateTransformMode:je(T),cubicCoeffA:M,excludeOutside:N,extrapolationValue:oe,keepAspectRatioPolicy:je(re),mode:je(ae),nearestMode:je(ue)})},922189:(s,p,y,x,T,M,N)=>{i.Ea("Slice",s,{starts:p?Array.from(n().subarray(y>>>0,y+p>>>0)):[],ends:x?Array.from(n().subarray(T>>>0,T+x>>>0)):[],axes:M?Array.from(n().subarray(N>>>0,N+M>>>0)):[]})},922420:s=>{i.Ea("Tile",s,void 0)},922472:(s,p,y)=>{i.Ea("LayerNormalization",s,{axis:Number(p),epsilon:Number(y)})},922579:(s,p,y)=>{i.Ea("InstanceNormalization",s,{epsilon:p,format:y?"NHWC":"NCHW"})},922693:(s,p,y)=>{i.Ea("InstanceNormalization",s,{epsilon:p,format:y?"NHWC":"NCHW"})},922807:s=>{i.Ea("Range",s,void 0)},922860:(s,p)=>{i.Ea("Einsum",s,{equation:je(p)})},922941:(s,p,y,x,T)=>{i.Ea("Pad",s,{mode:p,value:y,pads:x?Array.from(n().subarray(T>>>0,T+x>>>0)):[]})},923073:(s,p,y,x,T,M)=>{i.Ea("BatchNormalization",s,{epsilon:p,momentum:y,spatial:!!T,trainingMode:!!x,format:M?"NHWC":"NCHW"})},923242:(s,p,y,x,T,M)=>{i.Ea("BatchNormalization",s,{epsilon:p,momentum:y,spatial:!!T,trainingMode:!!x,format:M?"NHWC":"NCHW"})},923411:(s,p,y)=>{i.Ea("CumSum",s,{exclusive:Number(p),reverse:Number(y)})},923508:(s,p,y,x,T,M,N,oe,re)=>{i.Ea("Attention",s,{numHeads:p,isUnidirectional:y,maskFilterValue:x,scale:T,doRotary:M,qkvHiddenSizes:N?Array.from(n().subarray(Number(oe)>>>0,Number(oe)+N>>>0)):[],pastPresentShareBuffer:!!re})},923780:s=>{i.Ea("Gelu",s,void 0)},923832:(s,p,y,x,T,M)=>{i.Ea("MultiHeadAttention",s,{numHeads:p,isUnidirectional:y,maskFilterValue:x,scale:T,doRotary:M})},923991:s=>{i.Ea("BiasAdd",s,void 0)},924046:s=>{i.Ea("BiasSplitGelu",s,void 0)},924107:(s,p)=>{i.Ea("SkipLayerNormalization",s,{epsilon:p})},924188:(s,p,y,x,T,M,N,oe,re,ae,ue,xe,Ie)=>{i.Ea("Conv",s,{format:re?"NHWC":"NCHW",auto_pad:p,dilations:[y],group:x,kernel_shape:[T],pads:M?Array.from(n().subarray(N>>>0,N+M>>>0)):[],strides:[oe],w_is_const:()=>!!r()[ae>>>0],activation:je(ue),activation_params:xe?Array.from(u().subarray(Ie>>>0,Ie+xe>>>0)):[]})},924569:(s,p,y,x,T,M,N,oe,re,ae,ue,xe,Ie,P,fe,Ce)=>{i.Ea("Conv",s,{format:xe?"NHWC":"NCHW",auto_pad:p,dilations:[y,x],group:T,kernel_shape:[M,N],pads:oe?Array.from(n().subarray(re>>>0,re+oe>>>0)):[],strides:[ae,ue],w_is_const:()=>!!r()[Ie>>>0],activation:je(P),activation_params:fe?Array.from(u().subarray(Ce>>>0,Ce+fe>>>0)):[]})},924971:s=>{i.zb(s)},925005:(s,p)=>i.Ab(s,p,i.bb.Fb,i.bb.errors),925117:s=>i.wb(s),925150:s=>i.yb(s),925182:(s,p,y)=>{i.jb(s,p,y,!0)},925221:(s,p,y)=>{i.jb(s,p,y)}};function _t(s){this.name="ExitStatus",this.message=`Program terminated with exit(${s})`,this.status=s}function Ft(s){s.terminate(),s.onmessage=()=>{}}function qt(s){(s=le.Qa[s])||it(),le.Eb(s)}function nr(s){var p=le.tb();if(!p)return 6;le.Ya.push(p),le.Qa[s.Xa]=p,p.Xa=s.Xa;var y={cmd:"run",start_routine:s.Gb,arg:s.rb,pthread_ptr:s.Xa};return I&&p.unref(),p.postMessage(y,s.Mb),0}var jt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Er=(s,p,y)=>{p>>>=0;var x=p+y;for(y=p;s[y]&&!(y>=x);)++y;if(16<y-p&&s.buffer&&jt)return jt.decode(s.buffer instanceof SharedArrayBuffer?s.slice(p,y):s.subarray(p,y));for(x="";p<y;){var T=s[p++];if(T&128){var M=s[p++]&63;if((T&224)==192)x+=String.fromCharCode((T&31)<<6|M);else{var N=s[p++]&63;T=(T&240)==224?(T&15)<<12|M<<6|N:(T&7)<<18|M<<12|N<<6|s[p++]&63,65536>T?x+=String.fromCharCode(T):(T-=65536,x+=String.fromCharCode(55296|T>>10,56320|T&1023))}}else x+=String.fromCharCode(T)}return x},je=(s,p)=>(s>>>=0)?Er(a(),s,p):"";function ar(s){if(S)return H(1,1,s);me=s,ut()||(le.Hb(),i.onExit&&i.onExit(s),_e=!0),w(s,new _t(s))}var ir=s=>{if(me=s,S)throw Tr(s),"unwind";ar(s)},le={ab:[],Ya:[],mb:[],Qa:{},gb:function(){S?le.vb():le.ub()},ub:function(){Je.unshift(()=>{er(),le.Bb(()=>Ir())})},vb:function(){le.receiveObjectTransfer=le.Db,le.threadInitTLS=le.lb,le.setExitStatus=le.kb,J=!1},kb:function(s){me=s},Sb:["$terminateWorker"],Hb:function(){for(var s of le.Ya)Ft(s);for(s of le.ab)Ft(s);le.ab=[],le.Ya=[],le.Qa=[]},Eb:function(s){var p=s.Xa;delete le.Qa[p],le.ab.push(s),le.Ya.splice(le.Ya.indexOf(s),1),s.Xa=0,kn(p)},Db:function(){},lb:function(){le.mb.forEach(s=>s())},Cb:s=>new Promise(p=>{s.onmessage=M=>{M=M.data;var N=M.cmd;if(M.targetThread&&M.targetThread!=Ur()){var oe=le.Qa[M.Rb];oe?oe.postMessage(M,M.transferList):j('Internal error! Worker sent a message "'+N+'" to target pthread '+M.targetThread+", but that thread no longer exists!")}else N==="checkMailbox"?zt():N==="spawnThread"?nr(M):N==="cleanupThread"?qt(M.thread):N==="killThread"?(M=M.thread,N=le.Qa[M],delete le.Qa[M],Ft(N),kn(M),le.Ya.splice(le.Ya.indexOf(N),1),N.Xa=0):N==="cancelThread"?le.Qa[M.thread].postMessage({cmd:"cancel"}):N==="loaded"?(s.loaded=!0,p(s)):N==="alert"?alert("Thread "+M.threadId+": "+M.text):M.target==="setimmediate"?s.postMessage(M):N==="callHandler"?i[M.handler](...M.args):N&&j("worker sent an unknown command "+N)},s.onerror=M=>{throw j("worker sent an error! "+M.filename+":"+M.lineno+": "+M.message),M},I&&(s.on("message",function(M){s.onmessage({data:M})}),s.on("error",function(M){s.onerror(M)}));var y=[],x=["onExit","onAbort","print","printErr"],T;for(T of x)i.hasOwnProperty(T)&&y.push(T);s.postMessage({cmd:"load",handlers:y,urlOrBlob:i.mainScriptUrlOrBlob||e,wasmMemory:we,wasmModule:ye})}),Bb:function(s){s()},qb:function(){var s=k("ort-wasm-simd-threaded.worker.js");s=new Worker(s),le.ab.push(s)},tb:function(){return le.ab.length==0&&(le.qb(),le.Cb(le.ab[0])),le.ab.pop()}};i.PThread=le;var vt=s=>{for(;0<s.length;)s.shift()(i)};i.establishStackSpace=function(){var s=Ur(),p=n()[s+52>>2>>>0];s=n()[s+56>>2>>>0],qa(p,p-s),Nr(p)};function Tr(s){if(S)return H(2,0,s);ir(s)}i.invokeEntryPoint=function(s,p){s=ja.apply(null,[s,p]),ut()?le.kb(s):Rn(s)};function lt(s){this.fb=s-24,this.pb=function(p){o()[this.fb+4>>2>>>0]=p},this.ob=function(p){o()[this.fb+8>>2>>>0]=p},this.gb=function(p,y){this.nb(),this.pb(p),this.ob(y)},this.nb=function(){o()[this.fb+16>>2>>>0]=0}}var nt=0,Or=0;function Bt(s,p,y,x){return S?H(3,1,s,p,y,x):or(s,p,y,x)}function or(s,p,y,x){if(s>>>=0,p>>>=0,y>>>=0,x>>>=0,typeof SharedArrayBuffer>"u")return j("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var T=[];return S&&T.length===0?Bt(s,p,y,x):(s={Gb:y,Xa:s,rb:x,Mb:T},S?(s.Ob="spawnThread",postMessage(s,T),0):nr(s))}function sr(s,p,y){return S?H(4,1,s,p,y):0}function kr(s,p){if(S)return H(5,1,s,p)}var Mt=s=>{for(var p=0,y=0;y<s.length;++y){var x=s.charCodeAt(y);127>=x?p++:2047>=x?p+=2:55296<=x&&57343>=x?(p+=4,++y):p+=3}return p},Rr=(s,p,y,x)=>{if(y>>>=0,!(0<x))return 0;var T=y;x=y+x-1;for(var M=0;M<s.length;++M){var N=s.charCodeAt(M);if(55296<=N&&57343>=N){var oe=s.charCodeAt(++M);N=65536+((N&1023)<<10)|oe&1023}if(127>=N){if(y>=x)break;p[y++>>>0]=N}else{if(2047>=N){if(y+1>=x)break;p[y++>>>0]=192|N>>6}else{if(65535>=N){if(y+2>=x)break;p[y++>>>0]=224|N>>12}else{if(y+3>=x)break;p[y++>>>0]=240|N>>18,p[y++>>>0]=128|N>>12&63}p[y++>>>0]=128|N>>6&63}p[y++>>>0]=128|N&63}}return p[y>>>0]=0,y-T},Pr=(s,p,y)=>Rr(s,a(),p,y);function Br(s,p){if(S)return H(6,1,s,p)}function Mr(s,p,y){if(S)return H(7,1,s,p,y)}function zr(s,p,y){return S?H(8,1,s,p,y):0}function Dr(s,p){if(S)return H(9,1,s,p)}function Kt(s,p,y){if(S)return H(10,1,s,p,y)}function ur(s,p,y,x){if(S)return H(11,1,s,p,y,x)}function lr(s,p,y,x){if(S)return H(12,1,s,p,y,x)}function dr(s,p,y,x){if(S)return H(13,1,s,p,y,x)}function cr(s){if(S)return H(14,1,s)}function pr(s,p){if(S)return H(15,1,s,p)}function fr(s,p,y){if(S)return H(16,1,s,p,y)}var mr=s=>{if(!_e)try{if(s(),!ut())try{S?Rn(me):ir(me)}catch(p){p instanceof _t||p=="unwind"||w(1,p)}}catch(p){p instanceof _t||p=="unwind"||w(1,p)}};function Yt(s){s>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(n(),s>>2,s).value.then(zt),s+=128,Atomics.store(n(),s>>2,1))}i.__emscripten_thread_mailbox_await=Yt;function zt(){var s=Ur();s&&(Yt(s),mr(()=>Ga()))}i.checkMailbox=zt;var Ct=s=>s%4===0&&(s%100!==0||s%400===0),Dt=[0,31,60,91,121,152,182,213,244,274,305,335],hr=[0,31,59,90,120,151,181,212,243,273,304,334];function d(s,p,y,x,T,M,N,oe){return S?H(17,1,s,p,y,x,T,M,N,oe):-52}function h(s,p,y,x,T,M,N){if(S)return H(18,1,s,p,y,x,T,M,N)}var v=s=>{var p=Mt(s)+1,y=On(p);return y&&Pr(s,y,p),y},C=[],O=(s,p)=>{C.length=0;var y;for(p>>=2;y=a()[s++>>>0];)p+=y!=105&p,C.push(y==105?n()[p>>>0]:l()[p++>>>1]),++p;return C},F=s=>{var p=Pn();return s=s(),Nr(p),s};function H(s,p){var y=arguments.length-2,x=arguments;return F(()=>{for(var T=Bn(8*y),M=T>>3,N=0;N<y;N++){var oe=x[2+N];l()[M+N>>>0]=oe}return La(s,y,T,p)})}var de=[],Q={},ie=()=>{if(!te){var s={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"},p;for(p in Q)Q[p]===void 0?delete s[p]:s[p]=Q[p];var y=[];for(p in s)y.push(`${p}=${s[p]}`);te=y}return te},te;function ge(s,p){if(S)return H(19,1,s,p);s>>>=0,p>>>=0;var y=0;return ie().forEach(function(x,T){var M=p+y;for(T=o()[s+4*T>>2>>>0]=M,M=0;M<x.length;++M)r()[T++>>0>>>0]=x.charCodeAt(M);r()[T>>0>>>0]=0,y+=x.length+1}),0}function Se(s,p){if(S)return H(20,1,s,p);s>>>=0,p>>>=0;var y=ie();o()[s>>2>>>0]=y.length;var x=0;return y.forEach(function(T){x+=T.length+1}),o()[p>>2>>>0]=x,0}function R(s){return S?H(21,1,s):52}function se(s,p,y,x){return S?H(22,1,s,p,y,x):52}function ve(s,p,y,x,T){return S?H(23,1,s,p,y,x,T):70}var $t=[null,[],[]];function gr(s,p,y,x){if(S)return H(24,1,s,p,y,x);p>>>=0,y>>>=0,x>>>=0;for(var T=0,M=0;M<y;M++){var N=o()[p>>2>>>0],oe=o()[p+4>>2>>>0];p+=8;for(var re=0;re<oe;re++){var ae=a()[N+re>>>0],ue=$t[s];ae===0||ae===10?((s===1?B:j)(Er(ue,0)),ue.length=0):ue.push(ae)}T+=oe}return o()[x>>2>>>0]=T,0}var Ma=[31,29,31,30,31,30,31,31,30,31,30,31],za=[31,28,31,30,31,30,31,31,30,31,30,31];function Wl(s){var p=Array(Mt(s)+1);return Rr(s,p,0,p.length),p}var Vl=(s,p)=>{r().set(s,p>>>0)};function Da(s,p,y,x){function T(P,fe,Ce){for(P=typeof P=="number"?P.toString():P||"";P.length<fe;)P=Ce[0]+P;return P}function M(P,fe){return T(P,fe,"0")}function N(P,fe){function Ce(Ja){return 0>Ja?-1:0<Ja?1:0}var Wt;return(Wt=Ce(P.getFullYear()-fe.getFullYear()))===0&&(Wt=Ce(P.getMonth()-fe.getMonth()))===0&&(Wt=Ce(P.getDate()-fe.getDate())),Wt}function oe(P){switch(P.getDay()){case 0:return new Date(P.getFullYear()-1,11,29);case 1:return P;case 2:return new Date(P.getFullYear(),0,3);case 3:return new Date(P.getFullYear(),0,2);case 4:return new Date(P.getFullYear(),0,1);case 5:return new Date(P.getFullYear()-1,11,31);case 6:return new Date(P.getFullYear()-1,11,30)}}function re(P){var fe=P.Za;for(P=new Date(new Date(P.$a+1900,0,1).getTime());0<fe;){var Ce=P.getMonth(),Wt=(Ct(P.getFullYear())?Ma:za)[Ce];if(fe>Wt-P.getDate())fe-=Wt-P.getDate()+1,P.setDate(1),11>Ce?P.setMonth(Ce+1):(P.setMonth(0),P.setFullYear(P.getFullYear()+1));else{P.setDate(P.getDate()+fe);break}}return Ce=new Date(P.getFullYear()+1,0,4),fe=oe(new Date(P.getFullYear(),0,4)),Ce=oe(Ce),0>=N(fe,P)?0>=N(Ce,P)?P.getFullYear()+1:P.getFullYear():P.getFullYear()-1}s>>>=0,p>>>=0,y>>>=0,x>>>=0;var ae=n()[x+40>>2>>>0];x={Kb:n()[x>>2>>>0],Jb:n()[x+4>>2>>>0],cb:n()[x+8>>2>>>0],ib:n()[x+12>>2>>>0],eb:n()[x+16>>2>>>0],$a:n()[x+20>>2>>>0],Wa:n()[x+24>>2>>>0],Za:n()[x+28>>2>>>0],Tb:n()[x+32>>2>>>0],Ib:n()[x+36>>2>>>0],Lb:ae?je(ae):""},y=je(y),ae={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ue in ae)y=y.replace(new RegExp(ue,"g"),ae[ue]);var xe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ie="January February March April May June July August September October November December".split(" ");ae={"%a":P=>xe[P.Wa].substring(0,3),"%A":P=>xe[P.Wa],"%b":P=>Ie[P.eb].substring(0,3),"%B":P=>Ie[P.eb],"%C":P=>M((P.$a+1900)/100|0,2),"%d":P=>M(P.ib,2),"%e":P=>T(P.ib,2," "),"%g":P=>re(P).toString().substring(2),"%G":P=>re(P),"%H":P=>M(P.cb,2),"%I":P=>(P=P.cb,P==0?P=12:12<P&&(P-=12),M(P,2)),"%j":P=>{for(var fe=0,Ce=0;Ce<=P.eb-1;fe+=(Ct(P.$a+1900)?Ma:za)[Ce++]);return M(P.ib+fe,3)},"%m":P=>M(P.eb+1,2),"%M":P=>M(P.Jb,2),"%n":()=>`
`,"%p":P=>0<=P.cb&&12>P.cb?"AM":"PM","%S":P=>M(P.Kb,2),"%t":()=>"	","%u":P=>P.Wa||7,"%U":P=>M(Math.floor((P.Za+7-P.Wa)/7),2),"%V":P=>{var fe=Math.floor((P.Za+7-(P.Wa+6)%7)/7);if(2>=(P.Wa+371-P.Za-2)%7&&fe++,fe)fe==53&&(Ce=(P.Wa+371-P.Za)%7,Ce==4||Ce==3&&Ct(P.$a)||(fe=1));else{fe=52;var Ce=(P.Wa+7-P.Za-1)%7;(Ce==4||Ce==5&&Ct(P.$a%400-1))&&fe++}return M(fe,2)},"%w":P=>P.Wa,"%W":P=>M(Math.floor((P.Za+7-(P.Wa+6)%7)/7),2),"%y":P=>(P.$a+1900).toString().substring(2),"%Y":P=>P.$a+1900,"%z":P=>{P=P.Ib;var fe=0<=P;return P=Math.abs(P)/60,(fe?"+":"-")+("0000"+(P/60*100+P%60)).slice(-4)},"%Z":P=>P.Lb,"%%":()=>"%"},y=y.replace(/%%/g,"\0\0");for(ue in ae)y.includes(ue)&&(y=y.replace(new RegExp(ue,"g"),ae[ue](x)));return y=y.replace(/\0\0/g,"%"),ue=Wl(y),ue.length>p?0:(Vl(ue,s),ue.length-1)}function Wr(s){try{s()}catch(p){it(p)}}function Ul(s){var p={},y;for(y in s)(function(x){var T=s[x];p[x]=typeof T=="function"?function(){Vr.push(x);try{return T.apply(null,arguments)}finally{_e||(Vr.pop()===x||it(),dt&&It===1&&Vr.length===0&&(It=0,Ze+=1,Wr(Ya),typeof Fibers<"u"&&Fibers.Ub()))}}:T})(y);return p}var It=0,dt=null,Wa=0,Vr=[],Va={},Ua={},Nl=0,Tn=null,Hl=[];function Ll(){return new Promise((s,p)=>{Tn={resolve:s,reject:p}})}function Gl(){var s=On(65548),p=s+12;o()[s>>2>>>0]=p,o()[s+4>>2>>>0]=p+65536,p=Vr[0];var y=Va[p];return y===void 0&&(y=Nl++,Va[p]=y,Ua[y]=p),p=y,n()[s+8>>2>>>0]=p,s}function Fl(){var s=n()[dt+8>>2>>>0];return s=Z[Ua[s]],--Ze,s()}function ql(s){if(!_e){if(It===0){var p=!1,y=!1;s((x=0)=>{if(!_e&&(Wa=x,p=!0,y)){It=2,Wr(()=>Za(dt)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),x=!1;try{var T=Fl()}catch(oe){T=oe,x=!0}var M=!1;if(!dt){var N=Tn;N&&(Tn=null,(x?N.reject:N.resolve)(T),M=!0)}if(x&&!M)throw T}}),y=!0,p||(It=1,dt=Gl(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),Wr(()=>Ka(dt)))}else It===2?(It=0,Wr(Qa),Na(dt),dt=null,Hl.forEach(x=>mr(x))):it(`invalid state: ${It}`);return Wa}}function jl(s){return ql(p=>{s().then(p)})}le.gb();var Kl=[null,ar,Tr,Bt,sr,kr,Br,Mr,zr,Dr,Kt,ur,lr,dr,cr,pr,fr,d,h,ge,Se,R,se,ve,gr],Yl={r:function(s,p,y){return jl(async()=>{await i.xb(s,p,y)})},b:function(s,p,y){throw s>>>=0,new lt(s).gb(p>>>0,y>>>0),nt=s,Or++,nt},O:function(s){Ha(s>>>0,!$,1,!b,131072,!1),le.lb()},l:function(s){s>>>=0,S?postMessage({cmd:"cleanupThread",thread:s}):qt(s)},I:or,i:sr,U:kr,E:Br,G:Mr,V:zr,S:Dr,K:Kt,R:ur,p:lr,F:dr,C:cr,T:pr,D:fr,q:()=>!0,A:function(s,p){s>>>=0,s==p>>>0?setTimeout(()=>zt()):S?postMessage({targetThread:s,cmd:"checkMailbox"}):(s=le.Qa[s])&&s.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:Yt,X:function(s){I&&le.Qa[s>>>0].ref()},u:function(s,p,y){s=p+2097152>>>0<4194305-!!s?(s>>>0)+4294967296*p:NaN,y>>>=0,s=new Date(1e3*s),n()[y>>2>>>0]=s.getUTCSeconds(),n()[y+4>>2>>>0]=s.getUTCMinutes(),n()[y+8>>2>>>0]=s.getUTCHours(),n()[y+12>>2>>>0]=s.getUTCDate(),n()[y+16>>2>>>0]=s.getUTCMonth(),n()[y+20>>2>>>0]=s.getUTCFullYear()-1900,n()[y+24>>2>>>0]=s.getUTCDay(),s=(s.getTime()-Date.UTC(s.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,n()[y+28>>2>>>0]=s},v:function(s,p,y){s=p+2097152>>>0<4194305-!!s?(s>>>0)+4294967296*p:NaN,y>>>=0,s=new Date(1e3*s),n()[y>>2>>>0]=s.getSeconds(),n()[y+4>>2>>>0]=s.getMinutes(),n()[y+8>>2>>>0]=s.getHours(),n()[y+12>>2>>>0]=s.getDate(),n()[y+16>>2>>>0]=s.getMonth(),n()[y+20>>2>>>0]=s.getFullYear()-1900,n()[y+24>>2>>>0]=s.getDay(),p=(Ct(s.getFullYear())?Dt:hr)[s.getMonth()]+s.getDate()-1|0,n()[y+28>>2>>>0]=p,n()[y+36>>2>>>0]=-(60*s.getTimezoneOffset()),p=new Date(s.getFullYear(),6,1).getTimezoneOffset();var x=new Date(s.getFullYear(),0,1).getTimezoneOffset();s=(p!=x&&s.getTimezoneOffset()==Math.min(x,p))|0,n()[y+32>>2>>>0]=s},w:function(s){s>>>=0;var p=new Date(n()[s+20>>2>>>0]+1900,n()[s+16>>2>>>0],n()[s+12>>2>>>0],n()[s+8>>2>>>0],n()[s+4>>2>>>0],n()[s>>2>>>0],0),y=n()[s+32>>2>>>0],x=p.getTimezoneOffset(),T=new Date(p.getFullYear(),6,1).getTimezoneOffset(),M=new Date(p.getFullYear(),0,1).getTimezoneOffset(),N=Math.min(M,T);return 0>y?n()[s+32>>2>>>0]=+(T!=M&&N==x):0<y!=(N==x)&&(T=Math.max(M,T),p.setTime(p.getTime()+6e4*((0<y?N:T)-x))),n()[s+24>>2>>>0]=p.getDay(),y=(Ct(p.getFullYear())?Dt:hr)[p.getMonth()]+p.getDate()-1|0,n()[s+28>>2>>>0]=y,n()[s>>2>>>0]=p.getSeconds(),n()[s+4>>2>>>0]=p.getMinutes(),n()[s+8>>2>>>0]=p.getHours(),n()[s+12>>2>>>0]=p.getDate(),n()[s+16>>2>>>0]=p.getMonth(),n()[s+20>>2>>>0]=p.getYear(),s=p.getTime()/1e3,Fa((wt=s,1<=+Math.abs(wt)?0<wt?+Math.floor(wt/4294967296)>>>0:~~+Math.ceil((wt-+(~~wt>>>0))/4294967296)>>>0:0)),s>>>0},s:d,t:h,z:function(s,p,y){function x(ae){return(ae=ae.toTimeString().match(/\(([A-Za-z ]+)\)$/))?ae[1]:"GMT"}s>>>=0,p>>>=0,y>>>=0;var T=new Date().getFullYear(),M=new Date(T,0,1),N=new Date(T,6,1);T=M.getTimezoneOffset();var oe=N.getTimezoneOffset(),re=Math.max(T,oe);o()[s>>2>>>0]=60*re,n()[p>>2>>>0]=+(T!=oe),s=x(M),p=x(N),s=v(s),p=v(p),oe<T?(o()[y>>2>>>0]=s,o()[y+4>>2>>>0]=p):(o()[y>>2>>>0]=p,o()[y+4>>2>>>0]=s)},d:()=>{it("")},c:function(s,p,y){return s>>>=0,p=O(p>>>0,y>>>0),Gt[s].apply(null,p)},k:function(s,p,y){return s>>>=0,p=O(p>>>0,y>>>0),Gt[s].apply(null,p)},m:function(){},j:function(){return Date.now()},W:()=>{throw Ze+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return I?(Bi(),At(Pi)).cpus().length:navigator.hardwareConcurrency},L:function(s,p,y,x){for(le.Pb=p>>>0,de.length=y,p=x>>>0>>3,x=0;x<y;x++)de[x]=l()[p+x>>>0];return(0>s?Gt[-s-1]:Kl[s]).apply(null,de)},y:function(s){s>>>=0;var p=a().length;if(s<=p||4294901760<s)return!1;for(var y=1;4>=y;y*=2){var x=p*(1+.2/y);x=Math.min(x,s+100663296);var T=Math;x=Math.max(s,x);e:{T=T.min.call(T,4294901760,x+(65536-x%65536)%65536)-we.buffer.byteLength+65535>>>16;try{we.grow(T),he();var M=1;break e}catch{}M=void 0}if(M)return!0}return!1},P:ge,Q:Se,H:ir,h:R,o:se,x:ve,n:gr,a:we||i.wasmMemory,J:Da,e:function(s,p,y,x){return Da(s>>>0,p>>>0,y>>>0,x>>>0)}};(function(){function s(y,x){return y=y.exports,y=Ul(y),Z=y=Zl(y),le.mb.push(Z.Da),ze.unshift(Z.Y),ye=x,Ir(),y}var p={a:Yl};if(er(),i.instantiateWasm)try{return i.instantiateWasm(p,s)}catch(y){j("Module.instantiateWasm callback failed with error: "+y),f(y)}return Ar(p,function(y){s(y.instance,y.module)}).catch(f),{}})(),i._OrtInit=(s,p)=>(i._OrtInit=Z.Z)(s,p),i._OrtGetLastError=(s,p)=>(i._OrtGetLastError=Z._)(s,p),i._OrtCreateSessionOptions=(s,p,y,x,T,M,N,oe,re,ae)=>(i._OrtCreateSessionOptions=Z.$)(s,p,y,x,T,M,N,oe,re,ae),i._OrtAppendExecutionProvider=(s,p)=>(i._OrtAppendExecutionProvider=Z.aa)(s,p),i._OrtAddFreeDimensionOverride=(s,p,y)=>(i._OrtAddFreeDimensionOverride=Z.ba)(s,p,y),i._OrtAddSessionConfigEntry=(s,p,y)=>(i._OrtAddSessionConfigEntry=Z.ca)(s,p,y),i._OrtReleaseSessionOptions=s=>(i._OrtReleaseSessionOptions=Z.da)(s),i._OrtCreateSession=(s,p,y)=>(i._OrtCreateSession=Z.ea)(s,p,y),i._OrtReleaseSession=s=>(i._OrtReleaseSession=Z.fa)(s),i._OrtGetInputOutputCount=(s,p,y)=>(i._OrtGetInputOutputCount=Z.ga)(s,p,y),i._OrtGetInputName=(s,p)=>(i._OrtGetInputName=Z.ha)(s,p),i._OrtGetOutputName=(s,p)=>(i._OrtGetOutputName=Z.ia)(s,p),i._OrtFree=s=>(i._OrtFree=Z.ja)(s),i._OrtCreateTensor=(s,p,y,x,T,M)=>(i._OrtCreateTensor=Z.ka)(s,p,y,x,T,M),i._OrtGetTensorData=(s,p,y,x,T)=>(i._OrtGetTensorData=Z.la)(s,p,y,x,T),i._OrtReleaseTensor=s=>(i._OrtReleaseTensor=Z.ma)(s),i._OrtCreateRunOptions=(s,p,y,x)=>(i._OrtCreateRunOptions=Z.na)(s,p,y,x),i._OrtAddRunConfigEntry=(s,p,y)=>(i._OrtAddRunConfigEntry=Z.oa)(s,p,y),i._OrtReleaseRunOptions=s=>(i._OrtReleaseRunOptions=Z.pa)(s),i._OrtCreateBinding=s=>(i._OrtCreateBinding=Z.qa)(s),i._OrtBindInput=(s,p,y)=>(i._OrtBindInput=Z.ra)(s,p,y),i._OrtBindOutput=(s,p,y,x)=>(i._OrtBindOutput=Z.sa)(s,p,y,x),i._OrtClearBoundOutputs=s=>(i._OrtClearBoundOutputs=Z.ta)(s),i._OrtReleaseBinding=s=>(i._OrtReleaseBinding=Z.ua)(s),i._OrtRunWithBinding=(s,p,y,x,T)=>(i._OrtRunWithBinding=Z.va)(s,p,y,x,T),i._OrtRun=(s,p,y,x,T,M,N,oe)=>(i._OrtRun=Z.wa)(s,p,y,x,T,M,N,oe),i._OrtEndProfiling=s=>(i._OrtEndProfiling=Z.xa)(s),i._JsepOutput=(s,p,y)=>(i._JsepOutput=Z.ya)(s,p,y),i._JsepGetNodeName=s=>(i._JsepGetNodeName=Z.za)(s);var Ur=i._pthread_self=()=>(Ur=i._pthread_self=Z.Aa)(),On=i._malloc=s=>(On=i._malloc=Z.Ba)(s),Na=i._free=s=>(Na=i._free=Z.Ca)(s);i.__emscripten_tls_init=()=>(i.__emscripten_tls_init=Z.Da)();var Ha=i.__emscripten_thread_init=(s,p,y,x,T,M)=>(Ha=i.__emscripten_thread_init=Z.Fa)(s,p,y,x,T,M);i.__emscripten_thread_crashed=()=>(i.__emscripten_thread_crashed=Z.Ga)();var La=(s,p,y,x)=>(La=Z.Ha)(s,p,y,x),kn=s=>(kn=Z.Ia)(s),Rn=i.__emscripten_thread_exit=s=>(Rn=i.__emscripten_thread_exit=Z.Ja)(s),Ga=i.__emscripten_check_mailbox=()=>(Ga=i.__emscripten_check_mailbox=Z.Ka)(),Fa=s=>(Fa=Z.La)(s),qa=(s,p)=>(qa=Z.Ma)(s,p),Pn=()=>(Pn=Z.Na)(),Nr=s=>(Nr=Z.Oa)(s),Bn=s=>(Bn=Z.Pa)(s),ja=i.dynCall_ii=(s,p)=>(ja=i.dynCall_ii=Z.Ra)(s,p),Ka=s=>(Ka=Z.Sa)(s),Ya=()=>(Ya=Z.Ta)(),Za=s=>(Za=Z.Ua)(s),Qa=()=>(Qa=Z.Va)();i.___start_em_js=925254,i.___stop_em_js=925415;function Zl(s){s=Object.assign({},s);var p=x=>()=>x()>>>0,y=x=>T=>x(T)>>>0;return s.__errno_location=p(s.__errno_location),s.pthread_self=p(s.pthread_self),s.malloc=y(s.malloc),s.stackSave=p(s.stackSave),s.stackAlloc=y(s.stackAlloc),s}i.keepRuntimeAlive=ut,i.wasmMemory=we,i.stackAlloc=Bn,i.stackSave=Pn,i.stackRestore=Nr,i.UTF8ToString=je,i.stringToUTF8=Pr,i.lengthBytesUTF8=Mt,i.ExitStatus=_t,i.PThread=le;var Hr;Pt=function s(){Hr||Xa(),Hr||(Pt=s)};function Xa(){function s(){if(!Hr&&(Hr=!0,i.calledRun=!0,!_e)&&(S||vt(ze),c(i),i.onRuntimeInitialized&&i.onRuntimeInitialized(),!S)){if(i.postRun)for(typeof i.postRun=="function"&&(i.postRun=[i.postRun]);i.postRun.length;){var p=i.postRun.shift();Ge.unshift(p)}vt(Ge)}}if(!(0<rt))if(S)c(i),S||vt(ze),startWorker(i);else{if(i.preRun)for(typeof i.preRun=="function"&&(i.preRun=[i.preRun]);i.preRun.length;)Je.unshift(i.preRun.shift());vt(Je),0<rt||(i.setStatus?(i.setStatus("Running..."),setTimeout(function(){setTimeout(function(){i.setStatus("")},1),s()},1)):s())}}if(i.preInit)for(typeof i.preInit=="function"&&(i.preInit=[i.preInit]);0<i.preInit.length;)i.preInit.pop()();return Xa(),t.ready}})();typeof zi=="object"&&typeof Gn=="object"?Gn.exports=Mi:typeof define=="function"&&define.amd&&define([],()=>Mi)});var Wi=Zt((Ff,id)=>{id.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\n'});var Ui,od,Fn,qn,Qr,Vi,sd,ud,ld,Ni,De,Qt=q(()=>{"use strict";Ui=Oi();od=Di(),qn=!1,Qr=!1,Vi=!1,sd=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},ud=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},ld=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Ni=async e=>{if(qn)return Promise.resolve();if(Qr)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Vi)throw new Error("previous call to 'initializeWebAssembly()' failed.");Qr=!0;let t=e.initTimeout,r=e.numThreads,a=e.simd,n=r>1&&sd(),o=a&&ud(),u=e.wasmPaths,l=typeof u=="string"?u:void 0,i=ld(o,n),c=typeof u=="object"?u[i]:void 0,f=!1,g=[];if(t>0&&g.push(new Promise(m=>{setTimeout(()=>{f=!0,m()},t)})),g.push(new Promise((m,w)=>{let b=n?od:Ui,$={locateFile:(I,S)=>{if(n&&I.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Wi()],{type:"text/javascript"}));if(I.endsWith(".wasm")){if(c)return c;let _=l??S;return i==="ort-wasm-simd.wasm"?_+"ort-wasm-simd.jsep.wasm":i==="ort-wasm-simd-threaded.wasm"?_+"ort-wasm-simd-threaded.jsep.wasm":_+i}return S+I}};if(n)if(typeof Blob>"u")$.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let I=`var ortWasmThreaded=${b.toString()};`;$.mainScriptUrlOrBlob=new Blob([I],{type:"text/javascript"})}b($).then(I=>{Qr=!1,qn=!0,Fn=I,m()},I=>{Qr=!1,Vi=!0,w(I)})})),await Promise.race(g),f)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},De=()=>{if(qn&&Fn)return Fn;throw new Error("WebAssembly is not initialized yet.")}});var Ne,br,Oe,Xr=q(()=>{"use strict";Qt();Ne=(e,t)=>{let r=De(),a=r.lengthBytesUTF8(e)+1,n=r._malloc(a);return r.stringToUTF8(e,n,a),t.push(n),n},br=(e,t,r,a)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([n,o])=>{let u=t?t+n:n;if(typeof o=="object")br(o,u+".",r,a);else if(typeof o=="string"||typeof o=="number")a(u,o.toString());else if(typeof o=="boolean")a(u,o?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof o}`)})},Oe=e=>{let t=De(),r=t.stackSave();try{let a=t.stackAlloc(8);t._OrtGetLastError(a,a+4);let n=t.HEAP32[a/4],o=t.HEAPU32[a/4+1],u=o?t.UTF8ToString(o):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${u}`)}finally{t.stackRestore(r)}}});var Hi,Li=q(()=>{"use strict";Qt();Xr();Hi=e=>{let t=De(),r=0,a=[],n=e||{};try{if(e?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(n.terminate=!1);let o=0;return e?.tag!==void 0&&(o=Ne(e.tag,a)),r=t._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,o),r===0&&Oe("Can't create run options."),e?.extra!==void 0&&br(e.extra,"",new WeakSet,(u,l)=>{let i=Ne(u,a),c=Ne(l,a);t._OrtAddRunConfigEntry(r,i,c)!==0&&Oe(`Can't set a run config entry: ${u} - ${l}.`)}),[r,a]}catch(o){throw r!==0&&t._OrtReleaseRunOptions(r),a.forEach(u=>t._free(u)),o}}});var dd,cd,pd,fd,Gi,Fi=q(()=>{"use strict";Qt();Xr();dd=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},cd=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},pd=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},fd=(e,t,r)=>{for(let a of t){let n=typeof a=="string"?a:a.name;switch(n){case"xnnpack":n="XNNPACK";break;case"webnn":if(n="WEBNN",typeof a!="string"){let u=a;if(u?.deviceType){let l=Ne("deviceType",r),i=Ne(u.deviceType,r);De()._OrtAddSessionConfigEntry(e,l,i)!==0&&Oe(`Can't set a session config entry: 'deviceType' - ${u.deviceType}.`)}if(u?.numThreads){let l=u.numThreads;(typeof l!="number"||!Number.isInteger(l)||l<0)&&(l=0);let i=Ne("numThreads",r),c=Ne(l.toString(),r);De()._OrtAddSessionConfigEntry(e,i,c)!==0&&Oe(`Can't set a session config entry: 'numThreads' - ${u.numThreads}.`)}if(u?.powerPreference){let l=Ne("powerPreference",r),i=Ne(u.powerPreference,r);De()._OrtAddSessionConfigEntry(e,l,i)!==0&&Oe(`Can't set a session config entry: 'powerPreference' - ${u.powerPreference}.`)}}break;case"webgpu":if(n="JS",typeof a!="string"){let u=a;if(u?.preferredLayout){if(u.preferredLayout!=="NCHW"&&u.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${u.preferredLayout}`);let l=Ne("preferredLayout",r),i=Ne(u.preferredLayout,r);De()._OrtAddSessionConfigEntry(e,l,i)!==0&&Oe(`Can't set a session config entry: 'preferredLayout' - ${u.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let o=Ne(n,r);De()._OrtAppendExecutionProvider(e,o)!==0&&Oe(`Can't append execution provider: ${n}.`)}},Gi=e=>{let t=De(),r=0,a=[],n=e||{};pd(n);try{let o=dd(n.graphOptimizationLevel??"all"),u=cd(n.executionMode??"sequential"),l=typeof n.logId=="string"?Ne(n.logId,a):0,i=n.logSeverityLevel??2;if(!Number.isInteger(i)||i<0||i>4)throw new Error(`log serverity level is not valid: ${i}`);let c=n.logVerbosityLevel??0;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log verbosity level is not valid: ${c}`);let f=typeof n.optimizedModelFilePath=="string"?Ne(n.optimizedModelFilePath,a):0;if(r=t._OrtCreateSessionOptions(o,!!n.enableCpuMemArena,!!n.enableMemPattern,u,!!n.enableProfiling,0,l,i,c,f),r===0&&Oe("Can't create session options."),n.executionProviders&&fd(r,n.executionProviders,a),n.freeDimensionOverrides)for(let[g,m]of Object.entries(n.freeDimensionOverrides)){if(typeof g!="string")throw new Error(`free dimension override name must be a string: ${g}`);if(typeof m!="number"||!Number.isInteger(m)||m<0)throw new Error(`free dimension override value must be a non-negative integer: ${m}`);let w=Ne(g,a);t._OrtAddFreeDimensionOverride(r,w,m)!==0&&Oe(`Can't set a free dimension override: ${g} - ${m}.`)}return n.extra!==void 0&&br(n.extra,"",new WeakSet,(g,m)=>{let w=Ne(g,a),b=Ne(m,a);t._OrtAddSessionConfigEntry(r,w,b)!==0&&Oe(`Can't set a session config entry: ${g} - ${m}.`)}),[r,a]}catch(o){throw r!==0&&t._OrtReleaseSessionOptions(r),a.forEach(u=>t._free(u)),o}}});var jn,Nt,wr,Jr,vr,en,Kn,We=q(()=>{"use strict";jn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Nt=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},wr=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Jr=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},vr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},en=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",Kn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var md,hd,qi,ji,Ki,gd,Be,Et=q(()=>{"use strict";We();md=["V","I","W","E","F"],hd=(e,t)=>{console.log(`[${md[e]},${new Date().toISOString()}]${t}`)},Ki=(e,t)=>{qi=e,ji=t},gd=(e,t)=>{let r=vr(e),a=vr(qi);r>=a&&hd(r,typeof t=="function"?t():t)},Be=(...e)=>{ji&&gd(...e)}});var Yi,Zi=q(()=>{"use strict";We();Yi=(e,t)=>new(Jr(t))(e)});var tn=q(()=>{"use strict"});var rn,yd,Qi,Zn,Yn,Ji,eo=q(()=>{"use strict";Et();tn();rn=e=>Math.ceil(e/16)*16,yd=1,Qi=()=>yd++,Zn=async(e,t,r,a)=>{let n=rn(r),o=e.device.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=e.getCommandEncoder();e.endComputePass(),u.copyBufferToBuffer(t,0,o,0,n),e.flush(),await o.mapAsync(GPUMapMode.READ);let l=o.getMappedRange();if(a){let i=a();return i.set(new Uint8Array(l,0,r)),i}else return new Uint8Array(l.slice(0,r))}finally{o.destroy()}},Yn=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let a=r.buffer,n=r.byteOffset,o=r.byteLength,u=rn(o),l=this.storageCache.get(t);if(!l)throw new Error("gpu data for uploading does not exist");if(l.originalSize!==o)throw new Error(`inconsistent data size. gpu data size=${l.originalSize}, data size=${o}`);let i=this.backend.device.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),c=i.getMappedRange();new Uint8Array(c).set(new Uint8Array(a,n,o)),i.unmap();let f=this.backend.getCommandEncoder();this.backend.endComputePass(),f.copyBufferToBuffer(i,0,l.gpuData.buffer,0,u),Be("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(i)}memcpy(t,r){let a=this.storageCache.get(t);if(!a)throw new Error("source gpu data for memcpy does not exist");let n=this.storageCache.get(r);if(!n)throw new Error("destination gpu data for memcpy does not exist");if(a.originalSize!==n.originalSize)throw new Error("inconsistent source and destination gpu data size");let o=rn(a.originalSize),u=this.backend.getCommandEncoder();this.backend.endComputePass(),u.copyBufferToBuffer(a.gpuData.buffer,0,n.gpuData.buffer,0,o)}registerExternalBuffer(t,r,a){let n;if(a){if(n=this.externalBuffers.get(a),n===void 0)throw new Error("previous buffer is not registered");if(t===a)return Be("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, buffer is the same, skip.`),n;this.externalBuffers.delete(a)}else n=Qi();return this.storageCache.set(n,{gpuData:{id:n,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,n),Be("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, registered.`),n}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Be("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let a=rn(t),n,o=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,u=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(o||u){let i=o?this.freeBuffers:this.freeUniformBuffers,c=i.get(a);c||(c=[],i.set(a,c)),c.length>0?n=c.pop():n=this.backend.device.createBuffer({size:a,usage:r})}else n=this.backend.device.createBuffer({size:a,usage:r});let l={id:Qi(),type:0,buffer:n};return this.storageCache.set(l.id,{gpuData:l,originalSize:t}),Be("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${l.id}`),l}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Be("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let a=this.storageCache.get(t);if(!a)throw new Error("data does not exist");await Zn(this.backend,a.gpuData.buffer,a.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},Ji=(...e)=>new Yn(...e)});var Qn,ee,Re=q(()=>{"use strict";Qn=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},ee=e=>new Qn(e)});var Xn,pt,D,Ht,nn,an,on,$e=q(()=>{"use strict";Xn=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},pt=class{static calcShape(t,r,a=!1){let n=t.length,o=r.length;if(n===0)return r;if(o===0)return t;let u=Math.max(t.length,r.length),l=new Array(u);if(a){if(n<2||o<2)return;let i=Xn.calcMatMulShape([t[n-2],t[n-1]],[r[o-2],r[o-1]]);if(i===void 0)return;[l[u-2],l[u-1]]=i}for(let i=a?3:1;i<=u;i++){let c=n-i<0?1:t[n-i],f=o-i<0?1:r[o-i];if(c!==f&&c>1&&f>1)return;l[u-i]=Math.max(c,f)}return l}static isValidBroadcast(t,r){let a=t.length,n=r.length;if(a>n)return!1;for(let o=1;o<=a;o++)if(t[a-o]!==1&&t[a-o]!==r[n-o])return!1;return!0}},D=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,a){let n=1;for(let o=r;o<a;o++){if(t[o]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");n*=t[o]}return n}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let a=new Array(r);a[r-1]=1,a[r-2]=t[r-1];for(let n=r-3;n>=0;--n)a[n]=a[n+1]*t[n+1];return a}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(a=>this.normalizeAxis(a,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(a=>t[a]):t.slice().reverse()}static padShape(t,r){let a=t.length;return t.map((n,o)=>n+r[o]+r[o+a])}static areEqual(t,r){return t.length!==r.length?!1:t.every((a,n)=>a===r[n])}},Ht=class e{static adjustPoolAttributes(t,r,a,n,o,u){if(!t&&a.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let l=0;l<r.length-2;l++)l>=a.length?a.push(r[l+2]):a[l]=r[l+2];for(let l=0;l<a.length;l++)if(l<n.length){if(n[l]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let l=0;l<a.length;l++)if(l<o.length){if(o[l]<0)throw new Error("dilations should be greater than or equal to 1")}else o.push(1);for(let l=0;l<a.length*2;l++)if(l<u.length){if(u[l]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let l=0;l<a.length;l++){if(a[l]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[l]>=a[l]||u[l+a.length]>=a[l])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,a,n,o,u,l){if(l){if(o.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let i=0;i<t.length-2;i++)e.adjustPadAndReturnShape(t[i+(u?1:2)],r[i],a[i],n[i],o,i,i+t.length-2,l)}}static computePoolOutputShape(t,r,a,n,o,u,l){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let i=[r[0],r[1]];return e.computeShapeHelper(t,r,i,a,n,o,u,l),i}static computeConvOutputShape(t,r,a,n,o,u,l){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let i=[t[0],r[0]];return e.computeShapeHelper(!1,t,i,a,n,o,u,l),i}static computeShapeHelper(t,r,a,n,o,u,l,i){if(t)for(let c=0;c<r.length-2;c++)a.push(1);else for(let c=0;c<r.length-2;c++)a.push(e.adjustPadAndReturnShape(r[c+2],n[c],o[c],u[c],l,c,c+r.length-2,i))}static adjustPadAndReturnShape(t,r,a,n,o,u,l,i){let c=a*(n-1)+1;if(i&&i!=="NOTSET")switch(i){case"VALID":return o[u]=0,o[l]=0,Math.floor((t-c)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(a!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let g=((t+r-1)/r-1)*r+n-t;return o[u]=Math.floor(i==="SAME_LOWER"?(g+1)/2:g/2),o[l]=g-o[u],Math.floor((t+g-n)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+o[u]+o[l]-c)/r+1)}},nn=class{static getShapeOfGemmResult(t,r,a,n,o){if(t.length!==2||a.length!==2)throw new Error("shape need to be of size 2");let u,l,i;r?(u=t[1],l=t[0]):(u=t[0],l=t[1]);let c=-1;if(n?(i=a[0],c=1):(i=a[1],c=0),a[c]!==l)throw new Error("dimension mismatch");if(u<=0||i<=0||l<=0)throw new Error("invalid shape specified");if(o&&!pt.isValidBroadcast(o,[u,i]))throw new Error("gemm: invalid bias shape for broadcast");return[u,i,l]}},an=-34028234663852886e22,on=34028234663852886e22});var bd,ea,ke,Tt,K,Ve,Ye,ot,et,Ae,ta,V,Y,sn,Jn,to,Xt,Pe,be=q(()=>{"use strict";We();$e();bd=64,ea=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},ke=(e,t=1)=>{let r=ea(e,t);return typeof r=="string"?r:r[0]},Tt=(e,t=1)=>{let r=ea(e,t);return typeof r=="string"?r:r[1]},K=e=>e.length===0?[]:[{type:"uint32",data:e},{type:"uint32",data:D.computeStrides(e)}],Ve=e=>e%4===0?4:e%2===0?2:1,Ye=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,ot=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,et=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,Ae=(e,t,r)=>e.startsWith("uniforms.")&&r>4?typeof t=="string"?`${e}[(${t}) / 4][(${t}) % 4]`:`${e}[${Math.floor(t/4)}][${t%4}]`:r>1?`${e}[${t}]`:e,ta=(e,t,r,a,n)=>{let o=typeof r=="number",u=o?r:r.length,l=[...new Array(u).keys()],i=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,c=ea(t,n),f=typeof c=="string"?c:c[1],g=typeof c=="string"?c:c[0],m={indices:i,value:f,storage:g,tensor:t},w=G=>typeof G=="string"?G:`${G}u`,b={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},$=o?"uniforms.":"",I=`${$}${e}_shape`,S=`${$}${e}_strides`,_="";for(let G=0;G<u-1;G++)_+=`
    let dim${G} = current / ${Ae(S,G,u)};
    let rest${G} = current % ${Ae(S,G,u)};
    indices[${G}] = dim${G};
    current = rest${G};
    `;_+=`indices[${u-1}] = current;`;let k=u<2?"":`
  fn o2i_${e}(offset: u32) -> ${m.indices} {
    var indices: ${m.indices};
    var current = offset;
    ${_}
    return indices;
  }`,A=G=>(b.offsetToIndices=!0,u<2?G:`o2i_${e}(${G})`),z=[];if(u>=2)for(let G=u-1;G>=0;G--)z.push(`${Ae(S,G,u)} * (indices[${G}])`);let E=u<2?"":`
  fn i2o_${e}(indices: ${m.indices}) -> u32 {
    return ${z.join("+")};
  }`,U=G=>(b.indicesToOffset=!0,u<2?G:`i2o_${e}(${G})`),W=(...G)=>u===0?"0u":`${m.indices}(${G.map(w).join(",")})`,L=(G,ne)=>u<2?`${G}`:`${Ae(G,ne,u)}`,X=(G,ne,he)=>u<2?`${G}=${he};`:`${Ae(G,ne,u)}=${he};`,B={},j=(G,ne)=>{b.broadcastedIndicesToOffset=!0;let he=`${ne.name}broadcastedIndicesTo${e}Offset`;if(he in B)return`${he}(${G})`;let qe=[];for(let Je=u-1;Je>=0;Je--){let ze=ne.indicesGet("outputIndices",Je+ne.rank-u);qe.push(`${L(S,Je)} * (${ze} % ${L(I,Je)})`)}return B[he]=`fn ${he}(outputIndices: ${ne.type.indices}) -> u32 {
             return ${qe.length>0?qe.join("+"):"0u"};
           }`,`${he}(${G})`},pe=(G,ne)=>(()=>{if(m.storage===m.value)return`${e}[${G}]=${ne};`;if(m.storage==="vec2<u32>"&&m.value==="i32")return`${e}[${G}]=vec2<u32>(u32(${ne}), select(0u, 0xFFFFFFFFu, ${ne} < 0));`;if(m.storage==="vec2<u32>"&&m.value==="u32")return`${e}[${G}]=vec2<u32>(u32(${ne}), 0u);`;if(m.storage==="u32"&&m.value==="vec4<bool>")return`${e}[${G}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${ne}));`;throw new Error(`not supported combination of storage type ${m.storage} and value type ${m.value} yet`)})(),J=G=>(()=>{if(m.storage===m.value)return`${e}[${G}]`;if(m.storage==="vec2<u32>"&&m.value==="i32")return`i32(${e}[${G}].x)`;if(m.storage==="vec2<u32>"&&m.value==="u32")return`u32(${e}[${G}].x)`;if(m.storage==="u32"&&m.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${G}] & 0xFFu), bool(${e}[${G}] & 0xFF00u), bool(${e}[${G}] & 0xFF0000u), bool(${e}[${G}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${m.storage} and value type ${m.value} yet`)})(),we=u<2?"":`
  fn get_${e}ByIndices(indices: ${m.indices}) -> ${f} {
    return ${J(`i2o_${e}(indices)`)};
  }`,Z=u<2?"":(()=>{let G=l.map(he=>`d${he}: u32`).join(", "),ne=l.map(he=>`d${he}`).join(", ");return`
  fn get_${e}(${G}) -> ${f} {
    return get_${e}ByIndices(${W(ne)});
  }`})(),ye=(...G)=>{if(G.length!==u)throw new Error(`indices length must be ${u}`);let ne=G.map(w).join(",");return u===0?J("0u"):u===1?J(ne[0]):(b.get=!0,b.getByIndices=!0,b.indicesToOffset=!0,`get_${e}(${ne})`)},_e=G=>u<2?J(G):(b.getByIndices=!0,b.indicesToOffset=!0,`get_${e}ByIndices(${G})`),me=u<2?"":`
  fn set_${e}ByIndices(indices: ${m.indices}, value: ${f}) {
    ${pe(`i2o_${e}(indices)`,"value")}
  }`,ce=u<2?"":(()=>{let G=l.map(he=>`d${he}: u32`).join(", "),ne=l.map(he=>`d${he}`).join(", ");return`
  fn set_${e}(${G}, value: ${f}) {
    set_${e}ByIndices(${W(ne)}, value);
  }`})();return{impl:()=>{let G=[];return o||(G.push(`const ${I} = ${m.indices}(${r.join(",")});`),G.push(`const ${S} = ${m.indices}(${D.computeStrides(r).join(",")});`)),b.offsetToIndices&&G.push(k),b.indicesToOffset&&G.push(E),b.broadcastedIndicesToOffset&&Object.values(B).forEach(ne=>G.push(ne)),b.set&&G.push(ce),b.setByIndices&&G.push(me),b.get&&G.push(Z),b.getByIndices&&G.push(we),G.join(`
`)},type:m,offsetToIndices:A,indicesToOffset:U,broadcastedIndicesToOffset:j,indices:W,indicesGet:L,indicesSet:X,set:(...G)=>{if(G.length!==u+1)throw new Error(`indices length must be ${u}`);let ne=G[u];if(typeof ne!="string")throw new Error("value must be string");let he=G.slice(0,u).map(w).join(",");return u===0?pe("0u",ne):u===1?pe(he[0],ne):(b.set=!0,b.setByIndices=!0,b.indicesToOffset=!0,`set_${e}(${he}, ${ne})`)},setByOffset:pe,setByIndices:(G,ne)=>u<2?pe(G,ne):(b.setByIndices=!0,b.indicesToOffset=!0,`set_${e}ByIndices(${G}, ${ne});`),get:ye,getByOffset:J,getByIndices:_e,usage:a,name:e,strides:S,shape:I,rank:u}},V=(e,t,r,a=1)=>ta(e,t,r,"input",a),Y=(e,t,r,a=1)=>ta(e,t,r,"output",a),sn=(e,t,r,a=1)=>ta(e,t,r,"internal",a),Jn=class{constructor(t){this.normalizedDispatchGroup=t;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=bd){let r=typeof t=="number"?t:t[0],a=typeof t=="number"?1:t[1],n=typeof t=="number"?1:t[2],o=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,u=o?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,l=o?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${r*a*n}u + local_index;`;return`@compute @workgroup_size(${r}, ${a}, ${n})
  fn main(${u}) {
    ${l}
  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:"u32",length:t.rank}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:"u32",length:t.rank}))}declareVariable(t,r){if(t.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(t),this.appendVariableUniforms(t);let a=t.usage==="input"?"read":"read_write",n=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${a}> ${t.name}: array<${n}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`
`)}registerInternalVariable(t){if(t.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(r=>this.registerInternalVariable(r)),this}registerUniform(t,r,a=1){return this.uniforms.push({name:t,type:r,length:a}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:a,length:n}of this.uniforms)if(n&&n>4)t.push(`${r}:array<vec4<${a}>, ${Math.ceil(n/4)}>`);else{let o=n==null||n===1?a:`vec${n}<${a}>`;t.push(`${r}:${o}`)}return`
      struct Uniforms { ${t.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`
`)+this.internalVariables.map(t=>t.impl()).join(`
`)}},to=e=>new Jn(e),Xt=(e,t)=>{let r=e.length,a=[];for(let n=0;n<r;n++){let o=r-1-n,u=e[o]||1;(t[t.length-1-n]||1)>1&&u===1&&a.unshift(o)}return a},Pe=e=>!0});var wd,ro,vd,$d,at,no,ao,Jt=q(()=>{"use strict";$e();Re();be();wd=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},ro=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,vd=(e,t)=>D.sortBasedOnPerm(e,ro(e.length,t)),$d=(e,t,r,a)=>{let n=[];n.push(`fn perm(i: ${a.type.indices}) -> ${r.type.indices} {
    var a: ${r.type.indices};`);for(let o=0;o<t;++o)n.push(r.indicesSet("a",e[o],`i[${o}]`));return n.push("return a;}"),n.join(`
`)},at=(e,t)=>{let r=e.dataType,a=e.dims.length,n=ro(a,t),o=Pe(a),u=vd(e.dims,n),l=o?u.length:u,i=o?a:e.dims,c=Y("output",r,l),f=V("a",r,i),g=m=>`
  ${m.registerUniform("output_size","u32").declareVariables(f,c)}

  ${$d(n,a,f,c)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${c.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${c.setByOffset("global_idx",f.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:o?["rank"]:["dims"]},getRunData:m=>{let w=D.size(u);return{outputs:[{dims:u,dataType:m[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:o?[{type:"uint32",data:w},...K(m[0].dims),...K(u)]:[{type:"uint32",data:w}]}},getShaderSource:g}},no=(e,t)=>{wd(e.inputs),e.compute(at(e.inputs[0],t.perm))},ao=e=>ee({perm:e.perm})});var Sd,xd,_d,Cd,Id,Ad,Ed,Td,Od,kd,ft,io,oo,so,uo,lo,co,po,fo,mo,ho,go=q(()=>{"use strict";$e();be();un();Jt();Sd={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},xd={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},_d={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Cd={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Id=(e,t)=>{let r=[];for(let a=t-e;a<t;++a)r.push(a);return r},Ad=(e,t)=>{let r=[],a=e.length;for(let o=0;o<a;o++)t.indexOf(o)===-1&&r.push(e[o]);let n=t.map(o=>e[o]);return[r,n]},Ed=(e,t)=>{let r=e.length+t.length,a=[],n=0;for(let o=0;o<r;o++)t.indexOf(o)===-1?a.push(e[n++]):a.push(1);return a},Td=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},Od=(e,t)=>{let r=[];if(!Td(e,t)){for(let a=0;a<t;++a)e.indexOf(a)===-1&&r.push(a);e.forEach(a=>r.push(a))}return r},kd=(e,t,r,a,n,o,u)=>{let l=r[0].dims,i=D.size(o),c=D.size(u),f=V("_A",r[0].dataType,l),g=Y("output",n,o),m=32,w=`
          var<workgroup> aBestValues : array<${g.type.storage}, ${m}>;
       `;return{name:e,shaderCache:t,getShaderSource:$=>`
        ${$.registerUniform("reduceSize","u32").declareVariables(f,g)}
        ${w}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${$.mainStart(m)}
          let local_idx = local_id.x;

          let outputIndex = global_idx / ${m};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = ${g.type.storage}(${_d[a]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${m}) {
           let candidate = ${g.type.storage}(${f.getByOffset("offset + k")});
           bestValue = ${Sd[a]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${m}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${xd[a]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${g.setByOffset("outputIndex",`${a==="mean"?`bestValue / ${g.type.storage}(uniforms.reduceSize)`:`${Cd[a]}`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:o,dataType:n}],dispatchGroup:{x:i},programUniforms:[{type:"uint32",data:c}]})}},ft=(e,t,r,a)=>{let n=e.inputs.length===1?r:ra(e.inputs,r),o=n.axes;o.length===0&&!n.noopWithEmptyAxes&&(o=e.inputs[0].dims.map((w,b)=>b));let u=D.normalizeAxes(o,e.inputs[0].dims.length),l=u,i=e.inputs[0],c=Od(l,e.inputs[0].dims.length);c.length>0&&(i=e.compute(at(e.inputs[0],c),{inputs:[0],outputs:[-1]})[0],l=Id(l.length,i.dims.length));let[f,g]=Ad(i.dims,l),m=f;n.keepDims&&(m=Ed(f,u)),e.compute(kd(t,{hint:n.cacheKey,inputDependencies:["type"]},[i],a,e.inputs[0].dataType,m,g),{inputs:[i]})},io=(e,t)=>{ft(e,"ReduceMeanShared",t,"mean")},oo=(e,t)=>{ft(e,"ReduceL1Shared",t,"l1")},so=(e,t)=>{ft(e,"ReduceL2Shared",t,"l2")},uo=(e,t)=>{ft(e,"ReduceLogSumExpShared",t,"logSumExp")},lo=(e,t)=>{ft(e,"ReduceMaxShared",t,"max")},co=(e,t)=>{ft(e,"ReduceMinShared",t,"min")},po=(e,t)=>{ft(e,"ReduceProdShared",t,"prod")},fo=(e,t)=>{ft(e,"ReduceSumShared",t,"sum")},mo=(e,t)=>{ft(e,"ReduceSumSquareShared",t,"sumSquare")},ho=(e,t)=>{ft(e,"ReduceLogSumShared",t,"logSum")}});var mt,Rd,ln,ra,ht,Pd,Bd,Md,zd,Dd,Wd,Vd,Ud,Nd,Hd,gt,yo,bo,wo,vo,$o,So,xo,_o,Co,Io,un=q(()=>{"use strict";$e();Re();be();go();mt=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Rd=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],ln=(e,t,r,a,n,o,u=!1,l=!1)=>{let i=[],c=r[0].dims,f=c.length,g=D.normalizeAxes(n,f),m=!l&&g.length===0;c.forEach((I,S)=>{m||g.indexOf(S)>=0?u&&i.push(1):i.push(I)});let w=i.length,b=D.size(i);return{name:e,shaderCache:t,getShaderSource:I=>{let S=[],_=V("_A",r[0].dataType,f),k=Y("output",o,w),A=a(_,k,g),z=A[2];for(let E=0,U=0;E<f;E++)m||g.indexOf(E)>=0?(u&&U++,z=`for(var j${E}: u32 = 0; j${E} < ${c[E]}; j${E}++) {
                  ${A[2].includes("last_index")?`let last_index = j${E};`:""}
                  ${_.indicesSet("input_indices",E,`j${E}`)}
                  ${z}
                }`):(S.push(`${_.indicesSet("input_indices",E,k.indicesGet("output_indices",U))};`),U++);return`

        ${I.registerUniform("output_size","u32").declareVariables(_,k)}

        ${I.mainStart()}
          ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${_.type.indices};
          let output_indices = ${k.offsetToIndices("global_idx")};

          ${S.join(`
`)}
          ${A[0]}       // init ops for reduce max/min
          ${A[1]}
          ${z}
          ${A[3]}
          ${A.length===4?k.setByOffset("global_idx","value"):A.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:i,dataType:o}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:[{type:"uint32",data:b},...K(c),...K(i)]})}},ra=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(a=>r.push(Number(a))),ee({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},ht=(e,t,r,a)=>{let n=e.inputs,o=n.length===1?r:ra(n,r);e.compute(ln(t,{hint:o.cacheKey,inputDependencies:["rank"]},[n[0]],o.noopWithEmptyAxes&&o.axes.length===0?Rd:a,o.axes,n[0].dataType,o.keepDims,o.noopWithEmptyAxes),{inputs:[0]})},Pd=(e,t)=>{mt(e.inputs),ht(e,"ReduceLogSum",t,(a,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${a.getByIndices("input_indices")};`,"value = log(value);"])},Bd=(e,t)=>{mt(e.inputs),ht(e,"ReduceL1",t,(a,n)=>[`var value = ${n.type.storage}(0);`,"",`value += abs(${a.getByIndices("input_indices")});`,""])},Md=(e,t)=>{mt(e.inputs),ht(e,"ReduceL2",t,(a,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${a.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},zd=(e,t)=>{mt(e.inputs),ht(e,"ReduceLogSumExp",t,(a,n)=>[`var value = ${n.type.storage}(0);`,"",`value += exp(${a.getByIndices("input_indices")});`,"value = log(value);"])},Dd=(e,t)=>{mt(e.inputs),ht(e,"ReduceMax",t,(a,n,o)=>{let u=[];for(let l=0;l<a.rank;l++)(o.indexOf(l)>=0||o.length===0)&&u.push(a.indicesSet("input_indices",l,0));return[`${u.join(`
`)}`,`var value = ${a.getByIndices("input_indices")};`,`value = max(value, ${a.getByIndices("input_indices")});`,""]})},Wd=(e,t)=>{mt(e.inputs),ht(e,"ReduceMean",t,(a,n,o)=>{let u=1;for(let l=0;l<a.rank;l++)(o.indexOf(l)>=0||o.length===0)&&(u*=e.inputs[0].dims[l]);return["var sum = f32(0);","",`sum += f32(${a.getByIndices("input_indices")});`,`let value = ${n.type.value}(sum / ${u});`]})},Vd=(e,t)=>{mt(e.inputs),ht(e,"ReduceMin",t,(a,n,o)=>{let u=[];for(let l=0;l<a.rank;l++)(o.indexOf(l)>=0||o.length===0)&&u.push(`input_indices[${l}] = 0;`);return[`${u.join(`
`)}`,`var value = ${a.getByIndices("input_indices")};`,`value = min(value, ${a.getByIndices("input_indices")});`,""]})},Ud=(e,t)=>{mt(e.inputs),ht(e,"ReduceProd",t,(a,n)=>[`var value = ${n.type.storage}(1);`,"",`value *= ${a.getByIndices("input_indices")};`,""])},Nd=(e,t)=>{mt(e.inputs),ht(e,"ReduceSum",t,(a,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${a.getByIndices("input_indices")};`,""])},Hd=(e,t)=>{mt(e.inputs),ht(e,"ReduceSumSquare",t,(a,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${a.getByIndices("input_indices")}; value += t * t;`,""])},gt=(e,t,r)=>{if(t.length===0)return r;let a=1,n=1;for(let o=0;o<t.length;o++)t.indexOf(o)===-1?a*=e[o]:n*=e[o];return n<32&&a>1024},yo=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Wd(e,t):io(e,t)},bo=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Bd(e,t):oo(e,t)},wo=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Md(e,t):so(e,t)},vo=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?zd(e,t):uo(e,t)},$o=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Dd(e,t):lo(e,t)},So=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Vd(e,t):co(e,t)},xo=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ud(e,t):po(e,t)},_o=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Nd(e,t):fo(e,t)},Co=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Hd(e,t):mo(e,t)},Io=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Pd(e,t):ho(e,t)}});var Ao,Eo,To,na,Oo=q(()=>{"use strict";We();Re();un();Ao=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},Eo=(e,t)=>{Ao(e.inputs);let r=(a,n,o)=>{let u=[];for(let l=0;l<a.rank;l++)(o.indexOf(l)>=0||o.length===0)&&u.push(`input_indices[${l}] = 0;`);return[`${u.join(`
`)}`,`var value = ${a.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${a.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {
         value = ${a.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",n.setByOffset("global_idx","best_index")]};e.compute(ln("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},To=(e,t)=>{Ao(e.inputs);let r=(a,n,o)=>{let u=[];for(let l=0;l<a.rank;l++)(o.indexOf(l)>=0||o.length===0)&&u.push(`input_indices[${l}] = 0;`);return[`${u.join(`
`)}`,`var value = ${a.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${a.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {
         value = ${a.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",n.setByOffset("global_idx","best_index")]};e.compute(ln("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},na=e=>ee(e)});var Ld,ko,Gd,Fd,qd,dn,jd,Ro,aa=q(()=>{"use strict";Re();tn();be();Ld=(e,t)=>{let r=e[0],a=e[1],n=e[2],o=e[3],u=e[4],l=e[5];if(u&&l)throw new Error("Attention cannot have both past and relative_position_bias");if(r.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let i=r.dims[0],c=r.dims[1],f=r.dims[2];if(n.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(a.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(a.dims[0]!==f)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(n.dims[0]!==a.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let g=n.dims[0]/3,m=g,w=m;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let k of t.qkvHiddenSizes)if(k%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");g=t.qkvHiddenSizes[0],m=t.qkvHiddenSizes[1],w=t.qkvHiddenSizes[2]}let b=c;if(g!==m)throw new Error("qkv_hidden_sizes first element should be same as the second");if(n.dims[0]!==g+m+w)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let $=0;if(u){if(m!==w)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(u.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(u.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(u.dims[1]!==i)throw new Error('Input "past" second dimension must be batch_size');if(u.dims[2]!==t.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(u.dims[4]!==m/t.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||($=u.dims[3])}let I=b+$,S=-1,_=0;if(o)throw new Error("Mask not supported");if(u)throw new Error("past is not supported");if(l)throw new Error("relativePositionBias is not supported");return{batchSize:i,sequenceLength:c,pastSequenceLength:$,kvSequenceLength:b,totalSequenceLength:I,maxSequenceLength:S,inputHiddenSize:f,hiddenSize:g,vHiddenSize:w,headSize:Math.floor(g/t.numHeads),vHeadSize:Math.floor(w/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:_,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},ko=e=>ee({...e}),Gd=(e,t,r,a)=>{let n=Ve(a),o=Y("x",t.dataType,t.dims,n),u="threadMaxVector";n===2?u="max(threadMaxVector.x, threadMaxVector.y)":n===4&&(u="max(max(threadMaxVector.x, threadMaxVector.y), max(threadMaxVector.z, threadMaxVector.w))");let l=ke(t.dataType),i=64,c=a/n;c<i?i=1:c/8<64&&(i=Math.ceil(c/8));let f=Math.ceil(a/n/i),g=m=>`
  const dInv: ${l} = 1 / ${a};
  const dComp = ${a/n};
  var<workgroup> wgMax: array<f32, ${i}>;
  var<workgroup> wgSum: array<f32, ${i}>;

  ${m.declareVariables(o)}
  @compute @workgroup_size(${i}, 1, 1)
  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_index : u32) {
    let localOffset = local_index * ${f};
    let offset: u32 = workgroup_id.x * dComp + localOffset;

    var threadMaxVector = ${Ye("f32",n,"-3.402823e+38f")};
    for (var i: u32 = 0; i < ${f} && i + localOffset < dComp; i++) {
      threadMaxVector = max(${ot(l,n,"x[offset + i]")}, threadMaxVector);
    }
    wgMax[local_index] = ${u};
    workgroupBarrier();

    var maxValue = -3.402823e+38f;
    for (var i = 0u; i < ${i}; i++) {
      maxValue = max(wgMax[i], maxValue);
    }

    var sumVector = ${Ye("f32",n,"0")};
    for (var i: u32 = 0; i < ${f} && i + localOffset < dComp; i++) {
      sumVector += exp(${ot(l,n,"x[offset + i]")} - maxValue);
    }
    wgSum[local_index] = ${et("sumVector",n)};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${i}; i++) {
      sum += wgSum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < ${f} && i + localOffset < dComp; i++) {
        x[offset + i] = ${Ye(l,n,"dInv")};
      }
    } else {
      for (var i: u32 = 0; i < ${f} && i + localOffset < dComp; i++) {
        let f32input = ${ot(l,n,"x[offset + i]")};
        x[offset + i] = ${o.type.value}(exp(f32input - maxValue) / sum);
      }
    }
  }`;e.compute({name:"AttentionProbsSoftmax",shaderCache:{hint:`${a}`},getShaderSource:g,getRunData:()=>({outputs:[],dispatchGroup:{x:r}})},{inputs:[t],outputs:[]})},Fd=(e,t,r,a,n,o)=>{let u=[n.batchSize,n.numHeads,n.sequenceLength,n.kvSequenceLength+n.pastSequenceLength],l=o.scale===0?1/Math.sqrt(n.headSize):o.scale,i=ke(t.dataType),c=Ve(n.headSize),f=V("q",t.dataType,t.dims,c),g=V("key",r.dataType,r.dims,c),m=Y("output",t.dataType,u),w=n.headSize/c,b=n.sequenceLength,$=n.totalSequenceLength,I=w,S=12,_={x:Math.ceil(n.totalSequenceLength/S),y:Math.ceil(n.sequenceLength/S),z:n.batchSize*n.numHeads},k=[t,r],A=E=>`
  const M: u32 = ${b}u;
  const N: u32 = ${$}u;
  const K: u32 = ${I}u;
  const alpha: ${i} = ${l};
  const beta: ${i} = 1.0;
  const TILE_SIZE = ${S}u;

  var<workgroup> tileQ: array<${f.type.storage}, ${S*S}>;
  var<workgroup> tileK: array<${f.type.storage}, ${S*S}>;

  ${E.declareVariables(f,g,m)}

  @compute @workgroup_size(${S}, ${S}, 1)
  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,
   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {
   let global_idx = (workgroup_id.z * ${_.x*_.y}u +
          workgroup_id.y * ${_.x}u + workgroup_id.x) * ${S*S}u + local_index;

    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let lm = m + local_id.y;
    let ln = n + local_id.x;

    let qOffset = ${n.sequenceLength*w} * headIdx + m * K;
    let kOffset = ${n.kvSequenceLength*w} * headIdx + n * K;

    var value = ${Ye(i,c)};
    for (var w: u32 = 0u; w < K; w += TILE_SIZE) {
      if (m + local_id.y < M && w + local_id.x < K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * K + w + local_id.x];
      }
      if (n + local_id.y < N && w + local_id.x < K) {
        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * K + w + local_id.x];
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {
        value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k];
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * M * N;
    if (lm < M && ln < N) {
      let outputIdx = headOffset + lm * N + ln;
      output[outputIdx] = ${et("value",c)} * alpha;
    }
  }`,z=e.compute({name:"AttentionProbs",shaderCache:{hint:JSON.stringify(n)},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType,gpuDataType:0}],dispatchGroup:_}),getShaderSource:A},{inputs:k,outputs:[-1]})[0];return Gd(e,z,n.batchSize*n.numHeads*n.sequenceLength,n.totalSequenceLength),z},qd=(e,t,r,a)=>{let n=[a.batchSize,a.sequenceLength,a.vHiddenSize],o=V("probs",t.dataType,t.dims),u=V("v",r.dataType,r.dims),l=Y("output",t.dataType,n),i=ke(t.dataType),c=12,f={x:Math.ceil(a.vHeadSize/c),y:Math.ceil(a.sequenceLength/c),z:a.batchSize*a.numHeads},g=m=>`
  const M: u32 = ${a.sequenceLength}u;
  const N: u32 = ${a.vHeadSize}u;
  const K: u32 = ${a.totalSequenceLength}u;
  const numHeads: u32 = ${a.numHeads}u;
  const TILE_SIZE = ${c}u;

  var<workgroup> tileQ: array<${o.type.storage}, ${c*c}>;
  var<workgroup> tileK: array<${o.type.storage}, ${c*c}>;

  ${m.declareVariables(o,u,l)}

  @compute @workgroup_size(${c}, ${c}, 1)
  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,
   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {
   let global_idx = (workgroup_id.z * ${f.x*f.y}u +
          workgroup_id.y * ${f.x}u + workgroup_id.x) * ${c*c}u + local_index;

   let headIdx = workgroup_id.z;
   let m = workgroup_id.y * TILE_SIZE + local_id.y;
   let n = workgroup_id.x * TILE_SIZE + local_id.x;

   let offsetA = headIdx * (M * K) + m * K;
   let offsetB = headIdx * (N * K) + n;

   var value = ${i}(0);
   for (var w: u32 = 0u; w < K; w += TILE_SIZE) {
     if (m < M && w + local_id.x < K) {
       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
     }
     if (n < N && w + local_id.y < K) {
       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * N];
     }
     workgroupBarrier();
     for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / ${a.numHeads};
   let currentBatchHeadNumber = workgroup_id.z % ${a.numHeads};
   let headOffset = (batchIdx * M * ${a.numHeads} + currentBatchHeadNumber) * ${a.vHeadSize};
   if (m < M && n < N) {
     let outputIdx = batchIdx * ${a.sequenceLength*a.vHiddenSize} + m * ${a.vHiddenSize}
       + currentBatchHeadNumber * ${a.vHeadSize} + n;
     output[outputIdx] = value;
   }
  }`;return e.compute({name:"AttentionScore",shaderCache:{hint:JSON.stringify(a)},getRunData:()=>({outputs:[{dims:n,dataType:t.dataType,gpuDataType:0}],dispatchGroup:f}),getShaderSource:g},{inputs:[t,r],outputs:[0]})[0]},dn=(e,t,r,a,n,o,u,l,i,c,f)=>{let g=Fd(e,t,r,i,c,f);qd(e,g,a,c)},jd=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],a=ke(e.inputs[0].dataType),n=t.sequenceLength,o=t.inputHiddenSize,u=t.headSize,l=12,i={x:Math.ceil(t.headSize/l),y:Math.ceil(t.sequenceLength/l),z:t.batchSize*t.numHeads},c=()=>`
  const M: u32 = ${n}u;
  const K: u32 = ${o}u;
  const N: u32 = ${u}u;
  const numHeads: u32 = ${t.numHeads};
  const ldb = ${t.hiddenSize+t.hiddenSize+t.vHiddenSize}u;
  const TILE_SIZE = ${l}u;

  var<workgroup> tileInput: array<${a}, ${l*l}>;
  var<workgroup> tileWeightQ: array<${a}, ${l*l}>;
  var<workgroup> tileWeightK: array<${a}, ${l*l}>;
  var<workgroup> tileWeightV: array<${a}, ${l*l}>;

  @group(0) @binding(0) var<storage, read> input: array<${a}>;
  @group(0) @binding(1) var<storage, read> weight: array<${a}>;
  @group(0) @binding(2) var<storage, read> bias: array<${a}>;
  @group(0) @binding(3) var<storage, read_write> outputQ: array<${a}>;
  @group(0) @binding(4) var<storage, read_write> outputK: array<${a}>;
  @group(0) @binding(5) var<storage, read_write> outputV: array<${a}>;

  @compute @workgroup_size(${l}, ${l}, 1)
  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,
   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {
   let global_idx = (workgroup_id.z * ${i.x*i.y}u +
          workgroup_id.y * ${i.x}u + workgroup_id.x) * ${l*l}u + local_index;

    let batchIndex = workgroup_id.z / ${t.numHeads};
    let headNumber = workgroup_id.z % ${t.numHeads};
    let m = workgroup_id.y * TILE_SIZE + local_id.y;
    let n = workgroup_id.x * TILE_SIZE + local_id.x;

    let inputOffset = batchIndex * (M * K) + m * K;
    let biasOffsetQ = headNumber * ${t.headSize};
    let biasOffsetK = ${t.hiddenSize} + biasOffsetQ;
    let biasOffsetV = ${t.hiddenSize} + biasOffsetK;

    var valueQ = ${a}(0);
    var valueK = ${a}(0);
    var valueV = ${a}(0);
    for (var w: u32 = 0u; w < K; w += TILE_SIZE) {
      if (m < M && w + local_id.x < K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < N && w + local_id.y < K) {
        let offset = n + (w + local_id.y) * ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * N + n) % ${t.headSize};
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * M * N;
    if (m < M && n < N) {
      let outputIdx = offset + m * N + n;
      outputQ[outputIdx] = valueQ;
      outputK[outputIdx] = valueK;
      outputV[outputIdx] = valueV;
    }
  }`,f=[e.inputs[0],e.inputs[1],e.inputs[2]];return e.compute({name:"AttentionPrepare",shaderCache:{hint:JSON.stringify(t)},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:i}),getShaderSource:c},{inputs:f,outputs:[-1,-1,-1]})},Ro=(e,t)=>{let r=Ld(e.inputs,t),[a,n,o]=jd(e,r);return dn(e,a,n,o,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t)}});var Kd,Yd,Zd,Po,Bo=q(()=>{"use strict";ct();$e();Re();be();Kd=(e,t)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let r=(a,n,o)=>{let u=n.length;if(u!==a.length)throw new Error(`${o}: num dimensions != ${u}`);n.forEach((l,i)=>{if(l!==a[i])throw new Error(`${o}: dim[${i}] do not match`)})};if(e[0].dims.length>1){let a=t.format==="NHWC"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);r(e[1].dims,a,"Invalid input scale"),r(e[2].dims,a,"Invalid input B"),r(e[3].dims,a,"Invalid input mean"),r(e[4].dims,a,"Invalid input var")}else r(e[1].dims,[1],"Invalid input scale"),r(e[2].dims,[1],"Invalid input B"),r(e[3].dims,[1],"Invalid input mean"),r(e[4].dims,[1],"Invalid input var")},Yd=(e,t)=>{let{epsilon:r,spatial:a,format:n}=t,o=e[0].dims,u=a?Ve(o[o.length-1]):1,l=n==="NHWC"&&o.length>1?u:1,i=D.size(o)/u,c=Pe(o.length)&&a,f=c?o.length:o,g=V("x",e[0].dataType,e[0].dims,u),m=V("scale",e[1].dataType,e[1].dims,l),w=V("bias",e[2].dataType,e[2].dims,l),b=V("inputMean",e[3].dataType,e[3].dims,l),$=V("inputVar",e[4].dataType,e[4].dims,l),I=Y("y",e[0].dataType,f,u),S=()=>{let k="";if(a)k=`let cOffset = ${o.length===1?"0u":n==="NHWC"?`outputIndices[${o.length-1}] / ${u}`:"outputIndices[1]"};`;else if(n==="NCHW")k=`
            ${I.indicesSet("outputIndices","0","0")}
            let cOffset = ${I.indicesToOffset("outputIndices")};`;else{k=`var cIndices = ${m.type.indices}(0);
                       cIndices[0] = outputIndices[${o.length-1}];`;for(let A=1;A<m.rank;A++)k+=`cIndices[${A}] = outputIndices[${A}];`;k+=`let cOffset = ${m.indicesToOffset("cIndices")};`}return k},_=k=>`
  const epsilon = ${r};
  ${k.registerUniform("outputSize","u32").declareVariables(g,m,w,b,$,I)}
  ${k.mainStart()}
  ${k.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${I.offsetToIndices(`global_idx * ${u}`)};
    ${S()}
    let scale = ${m.getByOffset("cOffset")};
    let bias = ${w.getByOffset("cOffset")};
    let inputMean = ${b.getByOffset("cOffset")};
    let inputVar = ${$.getByOffset("cOffset")};
    let x = ${g.getByOffset("global_idx")};
    let value = (x - inputMean) / sqrt(inputVar + epsilon) * scale + bias;
    ${I.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${a}_${u}`,inputDependencies:c?["rank","type","type","type","type"]:void 0},getShaderSource:_,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:c?[{type:"uint32",data:i},...K(o)]:[{type:"uint32",data:i}]})}},Zd=e=>ee(e),Po=(e,t)=>{let{inputs:r,outputCount:a}=e,n=Zd({...t,outputCount:a});if(Ee.webgpu.validateInputContent&&Kd(r,n),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(Yd(r,n))}});var Qd,Xd,Mo,zo=q(()=>{"use strict";$e();be();Qd=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Xd=e=>{let t=e[0].dims,r=e[0].dims[2],a=D.size(t)/4,n=e[0].dataType,o=V("input",n,t,4),u=V("bias",n,[r],4),l=V("residual",n,t,4),i=Y("output",n,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:f=>`
  const channels = ${r}u / 4;
  ${f.declareVariables(o,u,l,i)}

  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes(a)}
    let value = ${o.getByOffset("global_idx")}
      + ${u.getByOffset("global_idx % channels")} + ${l.getByOffset("global_idx")};
    ${i.setByOffset("global_idx","value")}
  }`}},Mo=e=>{Qd(e.inputs),e.compute(Xd(e.inputs))}});var Jd,Te,Do,Wo,Vo,Uo,No,Ho,Lo,Go,Fo,ec,qo,jo,Ko,Yo,cn,Zo,pn,Qo,Xo,Jo,es,ts,rs,ns,as,is,os,ss,us,ls,ds,cs,ps,fs,ia=q(()=>{"use strict";We();$e();Re();be();Jd=(e,t,r,a,n,o)=>{let u=Math.ceil(t/4),l="";typeof n=="string"?l=`${n}(a)`:l=n("a");let i=V("inputData",r,[u],4),c=Y("outputData",a,[u],4);return`
      ${e.registerUniform("vec_size","u32").declareVariables(i,c)}

  ${o??""}

  ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${i.getByOffset("global_idx")};
    ${c.setByOffset("global_idx",l)}
  }`},Te=(e,t,r,a,n,o=e.dataType)=>({name:t,shaderCache:{hint:n,inputDependencies:["type"]},getShaderSource:u=>Jd(u,D.size(e.dims),e.dataType,o,r,a),getRunData:u=>({outputs:[{dims:e.dims,dataType:o}],dispatchGroup:{x:Math.ceil(D.size(u[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(D.size(e.dims)/4)}]})}),Do=e=>{e.compute(Te(e.inputs[0],"Abs","abs"))},Wo=e=>{e.compute(Te(e.inputs[0],"Acos","acos"))},Vo=e=>{e.compute(Te(e.inputs[0],"Acosh","acosh"))},Uo=e=>{e.compute(Te(e.inputs[0],"Asin","asin"))},No=e=>{e.compute(Te(e.inputs[0],"Asinh","asinh"))},Ho=e=>{e.compute(Te(e.inputs[0],"Atan","atan"))},Lo=e=>{e.compute(Te(e.inputs[0],"Atanh","atanh"))},Go=e=>ee(e),Fo=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(Te(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},ec=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:an,r=e.length>=3?e[2].getFloat32Array()[0]:on;return ee({min:t,max:r})},qo=(e,t)=>{let r=e.inputs.length===1?t:ec(e.inputs),a=Tt(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Clip",n=>`clamp(${n}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${a}> = vec4(${a}(${r.min}));
    const clip_max_: vec4<${a}> = vec4(${a}(${r.max}));
`,r.cacheKey),{inputs:[0]})},jo=e=>{e.compute(Te(e.inputs[0],"Ceil","ceil"))},Ko=e=>{e.compute(Te(e.inputs[0],"Cos","cos"))},Yo=e=>{e.compute(Te(e.inputs[0],"Cosh","cosh"))},cn=e=>ee(e),Zo=(e,t)=>{let r=Tt(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Elu",a=>`elu_vf32(${a})`,`
  const elu_alpha_ = ${r}(${t.alpha});

  fn elu_f32(a: ${r}) -> ${r} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,t.cacheKey))},pn=(e,t="f32")=>`
const r0: ${t} = 0.3275911;
const r1: ${t} = 0.254829592;
const r2: ${t} = -0.284496736;
const r3: ${t} = 1.421413741;
const r4: ${t} = -1.453152027;
const r5: ${t} = 1.061405429;

fn erf_vf32(v: ${e}) -> ${e} {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,Qo=e=>{let t=Tt(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,pn(`vec4<${t}>`,t)))},Xo=e=>{e.compute(Te(e.inputs[0],"Exp","exp"))},Jo=e=>{e.compute(Te(e.inputs[0],"Floor","floor"))},es=e=>{let t=Tt(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,pn(`vec4<${t}>`,t)))},ts=(e,t)=>{let r=Tt(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"LeakyRelu",a=>`select(leaky_relu_alpha_ * ${a}, ${a}, ${a} >= vec4<${r}>(0.0))`,`const leaky_relu_alpha_ = ${r}(${t.alpha});`,t.cacheKey))},rs=e=>{e.compute(Te(e.inputs[0],"Not",t=>`!${t}`))},ns=e=>{e.compute(Te(e.inputs[0],"Neg",t=>`-${t}`))},as=e=>{e.compute(Te(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},is=e=>{let t=Tt(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Relu",r=>`select(vec4<${t}>(0.0), ${r}, ${r} > vec4<${t}>(0.0))`))},os=e=>{e.compute(Te(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},ss=e=>{e.compute(Te(e.inputs[0],"Sin","sin"))},us=e=>{e.compute(Te(e.inputs[0],"Sinh","sinh"))},ls=e=>{e.compute(Te(e.inputs[0],"Sqrt","sqrt"))},ds=e=>{e.compute(Te(e.inputs[0],"Tan","tan"))},cs=e=>{e.compute(Te(e.inputs[0],"Tanh","tanh"))},ps=(e,t)=>{let r=Tt(e.inputs[0].dataType);return e.compute(Te(e.inputs[0],"ThresholdedRelu",a=>`select(vec4<${r}>(0.0), ${a}, ${a} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`,t.cacheKey)),0},fs=e=>{e.compute(Te(e.inputs[0],"Log","log"))}});var rc,nc,ms,hs=q(()=>{"use strict";$e();be();ia();rc=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},nc=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=V("input",e[0].dataType,e[0].dims,4),a=V("bias",e[0].dataType,[e[0].dims[2]],4),n=Y("output",e[0].dataType,t,4),o=D.size(t)/4,u=ke(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:i=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${e[0].dims[2]/4/2}u;

  ${i.declareVariables(r,a,n)}

  ${pn(`vec4<${u}>`,u)}

  ${i.mainStart()}
    ${i.guardAgainstOutOfBoundsWorkgroupSizes(o)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${n.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},ms=e=>{rc(e.inputs),e.compute(nc(e.inputs))}});var ac,ic,yt,gs,ys,bs,ws,vs,$s,Ss,xs,_s,Cs,Is=q(()=>{"use strict";We();$e();be();ac=(e,t,r,a,n,o,u,l,i,c,f,g,m)=>{let w,b;typeof l=="string"?w=b=(E,U)=>`${l}((${E}),(${U}))`:typeof l=="function"?w=b=l:(w=l.scalar,b=l.vector);let $=g?t.length:t,I=g?r.length:r,S=g?a.length:a,_=Y("outputData",f,S,4),k=V("aData",i,$,4),A=V("bData",c,I,4),z;if(n)if(o){let E=D.size(t)===1,U=D.size(r)===1,W=t.length>0&&t[t.length-1]%4===0,L=r.length>0&&r[r.length-1]%4===0;E||U?z=_.setByOffset("global_idx",b(E?`${k.type.value}(${k.getByOffset("0")}.x)`:k.getByOffset("global_idx"),U?`${A.type.value}(${A.getByOffset("0")}.x)`:A.getByOffset("global_idx"))):z=`
            let outputIndices = ${_.offsetToIndices("global_idx * 4u")};
            let offsetA = ${k.broadcastedIndicesToOffset("outputIndices",_)};
            let offsetB = ${A.broadcastedIndicesToOffset("outputIndices",_)};
            ${_.setByOffset("global_idx",b(u||W?k.getByOffset("offsetA / 4u"):`${k.type.value}(${k.getByOffset("offsetA / 4u")}[offsetA % 4u])`,u||L?A.getByOffset("offsetB / 4u"):`${A.type.value}(${A.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else z=_.setByOffset("global_idx",b(k.getByOffset("global_idx"),A.getByOffset("global_idx")));else{if(!o)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let E=(U,W,L="")=>{let X=`aData[indexA${W}][componentA${W}]`,B=`bData[indexB${W}][componentB${W}]`;return`
            let outputIndices${W} = ${_.offsetToIndices(`global_idx * 4u + ${W}u`)};
            let offsetA${W} = ${k.broadcastedIndicesToOffset(`outputIndices${W}`,_)};
            let offsetB${W} = ${A.broadcastedIndicesToOffset(`outputIndices${W}`,_)};
            let indexA${W} = offsetA${W} / 4u;
            let indexB${W} = offsetB${W} / 4u;
            let componentA${W} = offsetA${W} % 4u;
            let componentB${W} = offsetB${W} % 4u;
            ${U}[${W}] = ${L}(${w(X,B)});
          `};f===9?z=`
            var data = vec4<u32>(0);
            ${E("data",0,"u32")}
            ${E("data",1,"u32")}
            ${E("data",2,"u32")}
            ${E("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:z=`
            ${E("outputData[global_idx]",0)}
            ${E("outputData[global_idx]",1)}
            ${E("outputData[global_idx]",2)}
            ${E("outputData[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(k,A,_)}

        ${m??""}

        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${z}
      }`},ic=(e,t,r,a,n,o,u=r.dataType)=>{let l=!D.areEqual(r.dims,a.dims),i=r.dims,c=D.size(r.dims),f=!1,g=!1,m=[l];if(l){let b=pt.calcShape(r.dims,a.dims,!1);if(!b)throw new Error("Can't perform binary op on the given tensors");i=b,c=D.size(i);let $=D.size(r.dims)===1,I=D.size(a.dims)===1,S=r.dims.length>0&&r.dims[r.dims.length-1]%4===0,_=a.dims.length>0&&a.dims[a.dims.length-1]%4===0;m.push($),m.push(I),m.push(S),m.push(_);let k=1;for(let A=1;A<i.length;A++){let z=r.dims[r.dims.length-A]??1,E=a.dims[a.dims.length-A]??1;if(z===E)k*=z;else break}k%4===0?(g=!0,f=!0):($||I||S||_)&&(f=!0)}else f=!0;m.push(f);let w=Pe(r.dims.length)&&Pe(a.dims.length)&&Pe(i.length);return{name:e,shaderCache:{hint:t+m.map(b=>b.toString()).join("_"),inputDependencies:w?["rank","rank"]:["dims","dims"]},getShaderSource:b=>ac(b,r.dims,a.dims,i,f,l,g,n,r.dataType,a.dataType,u,w,o),getRunData:()=>({outputs:[{dims:i,dataType:u}],dispatchGroup:{x:Math.ceil(c/64/4)},programUniforms:w?[{type:"uint32",data:Math.ceil(D.size(i)/4)},...K(r.dims),...K(a.dims),...K(i)]:[{type:"uint32",data:Math.ceil(D.size(i)/4)}]})}},yt=(e,t,r,a,n,o)=>{e.compute(ic(t,n??"",e.inputs[0],e.inputs[1],r,a,o))},gs=e=>{yt(e,"Add",(t,r)=>`${t}+${r}`)},ys=e=>{yt(e,"Div",(t,r)=>`${t}/${r}`)},bs=e=>{yt(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},ws=e=>{yt(e,"Mul",(t,r)=>`${t}*${r}`)},vs=e=>{let t=V("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;yt(e,"Pow",{scalar:(a,n)=>`pow_custom(${a},${n})`,vector:(a,n)=>`pow_vector_custom(${a},${n})`},`
    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {
      if (b == ${t}(0.0)) {
        return ${t}(1.0);
      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {
        return ${t}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {
      // TODO: implement vectorized pow
      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},$s=e=>{yt(e,"Sub",(t,r)=>`${t}-${r}`)},Ss=e=>{yt(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},xs=e=>{yt(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},_s=e=>{yt(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Cs=e=>{yt(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var sc,uc,lc,dc,As,Es,Ts=q(()=>{"use strict";$e();Re();be();sc=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let a of e){if(a.dataType!==t)throw new Error("input tensors should be one type");if(a.dims.length!==r)throw new Error("input tensors should have the same shape")}},uc=(e,t)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${e}u>(${t});
    for (var i: u32 = 0u; i < ${e}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${e}u;
  }`,lc=(e,t)=>{let r=e.length,a=[];for(let n=0;n<r;++n){let o=t.setByOffset("global_idx",e[n].getByIndices("indices"));r===1?a.push(o):n===0?a.push(`if (inputIndex == ${n}u) { ${o} }`):n===r-1?a.push(`else { ${o} }`):a.push(`else if (inputIndex == ${n}) { ${o} }`)}return a.join(`
`)},dc=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn't match input dimensionality");let a=t<0?r.length+t:t,n=r.slice(0);for(let A=1;A<e.length;A++){let z=e[A].dims.slice();for(let E=0;E<r.length;E++)if(E===a)n[a]+=z[E];else if(r[E]!==z[E])throw new Error("non concat dimensions must match")}let o=D.size(n),u=new Array(e.length),l=new Array(e.length),i=e[0].dataType,c=0,f=[],g=[],m=[],w=[{type:"uint32",data:o}];for(let A=0;A<e.length;++A)c+=e[A].dims[a],u[A]=c,m.push(Pe(e[A].dims.length)),g.push(m[A]?e[A].dims.length:e[A].dims),l[A]=V(`input${A}`,i,g[A]),f.push(m[A]?"rank":"dims"),w.push({type:"uint32",data:u[A]});for(let A=0;A<e.length;++A)m[A]&&w.push(...K(e[A].dims));let b=Pe(n.length);b&&w.push(...K(n));let $=b?n.length:n,I=Y("output",i,$),S=I.indicesGet("indices",a),_=Array.from(Array(u.length).keys()).map(A=>`uniforms.sizeInConcatAxis${A}`).join(","),k=A=>`

  ${(()=>{A.registerUniform("outputSize","u32");for(let z=0;z<e.length;z++)A.registerUniform(`sizeInConcatAxis${z}`,"u32");return A.declareVariables(...l,I)})()}

  ${uc(u.length,_)}

  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${I.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${S});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${u.length}u>(${_});
      ${S} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${lc(l,I)}
  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:w}),getShaderSource:k}},As=(e,t)=>{sc(e.inputs),e.compute(dc(e.inputs,t.axis))},Es=e=>ee({axis:e.axis})});var st,fn,Ot=q(()=>{"use strict";$e();st=(e,t)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:`value = max(value, ${t}(0.0));`};case"Sigmoid":return{activationFunction:"",applyActivation:`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`};case"Clip":return{activationFunction:`const clip_min_=${t}(${e.clipMin});const clip_max_=${t}(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},fn=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,a]=e?.activation_params||[an,on];return{activation:t,clipMax:a,clipMin:r,activationCacheKey:`${t}:${r},${a}`}}return{activation:t,activationCacheKey:t}}});var Fe,mn,hn=q(()=>{"use strict";Fe=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},mn=e=>`
      ${e?"value = value + getBiasByOutputCoords(coords);":""}
      `});var gn,oa=q(()=>{"use strict";gn=e=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));
}
`});var cc,pc,$r,Os,fc,Sr,mc,yn,xr=q(()=>{"use strict";$e();be();Ot();hn();cc=(e,t)=>e?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${t?", batchIndices":""});
        `,pc=(e,t)=>e?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,$r=(e,t,r="f32",a,n=!1,o=32,u=!1,l=32)=>{let i=t[1]*e[1],c=t[0]*e[0],f=n?i:o,g=n?o:i,m=f/t[0],w=o/t[1];if(!((n&&m===4&&e[1]===4||!n&&(m===3||m===4))&&f%t[0]===0&&o%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${n} is true, innerElementSize ${m} and workPerThread[1] ${e[1]} must be 4.
      Otherwise, innerElementSize ${m} must be 3 or 4.
  tileAWidth ${f} must be divisible by workgroupSize[0]${t[0]}. tileInner ${o} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${m}<${r}>, ${f/m}>, ${g}>;
var<workgroup> mm_Bsub: array<array<vec4<${r}>, ${c/e[0]}>, ${o}>;

const rowPerThread = ${e[1]};
const colPerThread = ${e[0]};
const innerElementSize = ${m};
const tileInner = ${o};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${u?"0":"i32(globalId.z)"};
  ${a?`let batchIndices = ${a.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${i};

  let numTiles = ${u?`${Math.ceil(l/o)}`:"(uniforms.dimInner - 1) / tileInner + 1"};
  var kStart = ${u?`i32(globalId.z) * ${l}`:"0"};

  var acc: array<vec4<${r}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${w};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${cc(n,a)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${a?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${m===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${pc(n,m)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Os=(e,t)=>e?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${t?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${t?", batchIndices":""});
            `,fc=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Sr=(e,t,r="f32",a,n=!1,o=32,u=!1,l=32,i=!1)=>{let c=e[1]*t[1],f=e[0]*t[0],g=n?c:o,m=n?o:c;if(!(m%t[1]===0&&g%t[0]===0&&o%t[1]===0))throw new Error(`tileAHight ${m} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${g} must be divisible by workgroupSize[0]${t[0]}, tileInner ${o} must be divisible by workgroupSize[1]${t[1]}`);let w=m/t[1],b=g/t[0],$=o/t[1],I=i?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${c};
    let globalColStart = i32(workgroupId.x) * ${f};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${m}; inputRow = inputRow + ${t[1]}) {
        for (var inputCol = localCol; inputCol < ${g}; inputCol = inputCol + ${t[0]}) {
          ${Os(n,a)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${o}; inputRow = inputRow + ${t[1]}) {
            for (var inputCol = localCol; inputCol < ${f}; inputCol = inputCol + ${t[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${a?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${r}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${t[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${t[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${c};

let tileRowA = i32(localId.y) * ${w};
let tileColA = i32(localId.x) * ${b};
let tileRowB = i32(localId.y) * ${$};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${b}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Os(n,a)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${$}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${a?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${r}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${fc(n)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${r}, ${g}>, ${m}>;
  var<workgroup> mm_Bsub : array<array<${r}, ${f}>, ${o}>;
  const rowPerThread = ${e[1]};
  const colPerThread = ${e[0]};
  const tileInner = ${o};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${u?"0":"i32(globalId.z)"};
    ${a?`let batchIndices = ${a.offsetToIndices("u32(batch)")};`:""}
    let numTiles = ${u?`${Math.ceil(l/o)}`:"(uniforms.dimInner - 1) / tileInner + 1"};
    var kStart = ${u?`i32(globalId.z) * ${l}`:"0"};

    var acc : array<array<${r}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${I}
  }
`},mc=(e,t,r,a,n,o=!1)=>{let[u,l,i]=n,[c,f,g,m]=a,w=Xt(u,i),b=Xt(l,i),$=ke(a[0].type.tensor),I=()=>{let k=f.rank,A=c.rank,z=`var aIndices: ${f.type.indices};`;for(let E=k-2-1,U=A-1;E>=0;E--,U--)z+=`
aIndices[${E}] = ${A>1?`batchIndices[${U}]`:"batchIndices"};`;return w.forEach(E=>{z+=`
aIndices[${E}] = 0;`}),z+=`
aIndices[${k-2}] = u32(row);
                   aIndices[${k-1}] = u32(colIn);`,z},S=()=>{let k=g.rank,A=c.rank,z=`var bIndices: ${g.type.indices};`;for(let E=k-2-1,U=A-1;E>=0;E--,U--)z+=`
bIndices[${E}] = ${A>1?`batchIndices[${U}]`:"batchIndices"};`;return b.forEach(E=>{z+=`
bIndices[${E}] = 0;`}),z+=`
bIndices[${k-2}] = u32(row);
                   bIndices[${k-1}] = u32(colIn);`,z};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${c.type.indices}) -> ${Fe(e,$)} {
      var value = ${Fe(e,$)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dimAOuter && col < uniforms.dimInner)
      {
        ${I()}
        value = ${f.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${c.type.indices}) -> ${Fe(e,$)} {
      var value = ${Fe(e,$)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dimInner && col < uniforms.dimBOuter)
      {
        ${S()}
        value = ${g.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Fe(e,$)}) {
      let col = colIn * ${e};
      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${t?`value = value + ${o?"bias[colIn]":`${Fe(e,$)}(bias[row])`};`:""}
        ${r}
        ${m.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},yn=(e,t,r,a,n=!1)=>{let o=e[0].dims,u=e[1].dims,l=o.slice(0,-2),i=u.slice(0,-2),c=a?a.slice(0,-2):r.slice(0,-2),f=Pe(c.length),g=f?c.length:c,m=sn("batchDims",e[0].dataType,g,1),w=D.size(c),b=o[o.length-2],$=o[o.length-1],I=u[u.length-1],S=$%4===0&&I%4===0,_=b<=8?[4,1,1]:[4,4,1],k=[8,8,1],A=[Math.ceil(I/k[0]/_[0]),Math.ceil(b/k[1]/_[1]),Math.ceil(w/k[2]/_[2])],z=ke(e[0].dataType),E=S?4:1,U=[...l,b,$/E],W=Pe(U.length),L=W?U.length:U,X=[...i,$,I/E],B=Pe(X.length),j=B?X.length:X,pe=[w,b,I/E],J=V("a",e[0].dataType,L,E),we=V("b",e[1].dataType,j,E),Z=Y("result",e[0].dataType,pe.length,E),ye=[J,we],_e=[{type:"int32",data:b},{type:"int32",data:I},{type:"int32",data:$}];f&&_e.push(...K(c)),W&&_e.push(...K(U)),B&&_e.push(...K(X));let me=[];me.push(W?"rank":"dims"),me.push(B?"rank":"dims");let ce=e.length>2,{activationFunction:He,applyActivation:Me}=st(t,Z.type.value),Le=mc(E,ce,Me,[m,J,we,Z],[l,i,c],n);if(ce){let ne=n?E:1;ye.push(V("bias",e[2].dataType,e[2].dims.length,ne)),_e.push(...K(e[2].dims)),me.push("rank")}_e.push(...K(pe));let G=ne=>`
  ${ne.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").registerInternalVariables(m).declareVariables(...ye,Z)}
  ${He}
  ${Le}
  ${S?$r(_,k,z,m):Sr(_,k,z,m)}
                   `;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey+`${_}${S}${n}`,inputDependencies:me},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:A[0],y:A[1],z:A[2]},programUniforms:_e}),getShaderSource:G}}});var hc,ks,Rs=q(()=>{"use strict";Et();be();Ot();hn();oa();xr();hc=(e,t,r,a,n=!1,o,u=4,l=4,i=4,c="f32")=>{let f=B=>{switch(B){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${c}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${B} is not supported.`)}},g=B=>{switch(B){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${B} is not supported.`)}},m=e?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,w=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,b=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",$=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",I=e?"row":"col",S=e?"col":"row",_=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${I} / outWidth;
    let outCol = ${I} % outWidth;

    let WRow = ${S} / (filterDims[1] * inChannels);
    let WCol = ${S} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${S} % inChannels;
    var resData = ${Fe(u,c)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${b} && xCol >= 0 && xCol < ${$}) {
      ${m}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${f(u)}
    }
    return resData;`,k=e?t&&a?`
    let col = colIn * ${u};
    ${_}`:`
    let col = colIn * ${u};
    if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
      ${_}
    }
    return ${Fe(u,c)}(0.0);`:a&&r?`
    let col = colIn * ${u};
    ${_}`:`
    let col = colIn * ${u};
    if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
      ${_}
    }
    return ${Fe(u,c)}(0.0);`,A=`${g(l)}`,z=Fe(i,c),E=e?Fe(u,c):Fe(l,c),U=e?Fe(l,c):Fe(u,c),{activationFunction:W,applyActivation:L}=st(o,z);return`
    ${W}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${E} {
      ${e?k:A}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${U} {
      ${e?A:k}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${z}) {
      let col = colIn * ${i};
      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${w}
      ${mn(n)}
      ${L}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},ks=(e,t,r,a,n,o,u,l)=>{let i=t.format==="NHWC",c=i?e[0].dims[3]:e[0].dims[1],f=r[0],g=i?r[2]:r[3],m=i?r[1]:r[2],w=i?r[3]:r[1],b=i&&(c%4===0||c%3===0)&&w%4===0,$=i?w:g*m,I=i?g*m:w,S=[8,8,1],_=a<=8?[4,1,1]:[4,4,1],k=[Math.ceil($/S[0]/_[0]),Math.ceil(I/S[1]/_[1]),Math.ceil(f/S[2]/_[2])];Be("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${k}`);let A=b?i&&c%4!==0?3:4:1,z=S[1]*_[1],E=S[0]*_[0],U=Math.max(S[0]*A,S[1]),W=a%z===0,L=n%E===0,X=o%U===0,B=b?[A,4,4]:[1,1,1],j=ke(e[0].dataType),pe=b?4:1,J=[{type:"int32",data:a},{type:"int32",data:n},{type:"int32",data:o}],we=V("x",e[0].dataType,e[0].dims.length,A===3?1:A),Z=V("w",e[1].dataType,e[1].dims.length,pe),ye=[we,Z];J.push(...K(e[0].dims)),J.push(...K(e[1].dims));let _e=`
      fn setOutputAtIndex(flatIndex : i32, value : ${b?`vec4<${j}>`:j}) {
        result[flatIndex] = ${b?`vec4<${j}>`:j}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${b?`vec4<${j}>`:j}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${b?"/ 4":""}, value);
      }`;if(u){let ce=V("bias",e[2].dataType,e[2].dims.length,pe);ye.push(ce),J.push(...K(e[2].dims)),_e+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${b?`vec4<${j}>`:j} {
          return bias[coords.${i?"w":"y"}${b?"/ 4":""}];
        }`}let me=Y("result",e[0].dataType,r.length,pe);return J.push(...K(r)),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:k[0],y:k[1],z:k[2]},programUniforms:J}),getShaderSource:ce=>`
        ${gn("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${ce.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...ye,me)}
        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});
        ${_e}
        ${hc(i,W,L,X,u,t,B[0],B[1],B[2],j)}
            ${b?$r(_,S,j,void 0,!i,U):Sr(_,S,j,void 0,!i,U,!1,void 0,l)}`}}});var sa,Ps,Bs=q(()=>{"use strict";$e();be();ua();Ot();sa=(e,t,r)=>{let a=e.length>2,n=a?"value += b[output_channel];":"",o=e[0].dims,u=e[1].dims,l=u[0]/t.group,i=t.format==="NHWC",c=bn(o,u,t.dilations,t.pads,t.strides,i),f=D.size(c),g=Y("output",e[0].dataType,c),{activationFunction:m,applyActivation:w}=st(t,g.type.value),b=V("x",e[0].dataType,o),$=V("w",e[1].dataType,u),I=[b,$];a&&I.push(V("b",e[2].dataType,e[2].dims));let S=_=>`
  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);
  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);

  ${_.declareVariables(...I,g)}

  ${m}

  ${_.mainStart()}
    ${_.guardAgainstOutOfBoundsWorkgroupSizes(f)}

    let outputIndices = ${g.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${i?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${i?1:2}], outputIndices[${i?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${l}u;

    var value: ${g.type.value} = ${g.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${u[1]}u; wInChannel++) {
      let input_channel = group_id * ${u[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${u[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${o[i?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${u[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${o[i?2:3]}u) {
            continue;
          }

          let xVal = ${i?b.get("batch","xHeight","xWidth","input_channel"):b.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${$.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${n}
    ${w}
    ${g.setByOffset("global_idx","value")}
  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(c):c,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)}}),getShaderSource:S}},Ps=(e,t,r)=>{let a=e.length>2,n=Ve(r[3]),o=Ve(r[2]),u=D.size(r)/n/o,l=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/n],i=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/n],c=f=>{let g=Y("output",e[0].dataType,[r[0],r[1],r[2],r[3]/n],n),{activationFunction:m,applyActivation:w}=st(t,g.type.value),b=V("x",e[0].dataType,l,n),$=V("w",e[1].dataType,i,n),I=[b,$];a&&I.push(V("b",e[2].dataType,e[2].dims,n));let S=a?"value += b[output_channel];":"",_=(o-1)*t.strides[1]+i[1];return`
  const strides: vec2<i32> = vec2(${t.strides[0]}, ${t.strides[1]});
  const pads: vec2<i32> = vec2(${t.pads[0]}, ${t.pads[1]});
  ${f.declareVariables(...I,g)}
  ${m}
  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes(u)}
    let width0 = ${r[3]}u / ${n}u;
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = ${r[2]}u / ${o}u;
    let col = (index1 % width1) * ${o}u;
    index1 = index1 / width1;
    let row = index1 % ${r[1]}u;
    let batch = index1 / ${r[1]}u;

    let xRCCorner = vec2<i32>(i32(row), i32(col)) * strides - pads;

    var xVals: array<${b.type.value}, ${_}>;
    var values: array<${g.type.value}, ${o}>;
    let input_channel = output_channel;
      for (var wHeight: u32 = 0u; wHeight < ${i[0]}u; wHeight++) {
        let xHeight = xRCCorner.x + i32(wHeight);
        if (xHeight >= 0 || xHeight < ${l[1]}) {
          for (var i = 0; i < ${_}; i++) {
            let xWidth = xRCCorner.y + i;
            if (xWidth >= 0 && xWidth < ${l[2]}) {
              xVals[i] = ${b.get("batch","u32(xHeight)","u32(xWidth)","input_channel")};
            } else {
              xVals[i] = ${b.type.value}(0);
            }
          }
          for (var wWidth: u32 = 0u; wWidth < ${i[1]}u; wWidth++) {
            let wVal = ${$.get("wHeight","wWidth","0","output_channel")};
            for (var i = 0u; i < ${o}u; i++) {
              values[i] = fma(xVals[i * ${t.strides[1]}u + wWidth], wVal, values[i]);
            }
          }
        }
      }

    for (var i = 0u; i < ${o}u; i++) {
        var value = values[i];
        ${S}
        ${w}
        ${g.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:c}}});var la,gc,Ms,da=q(()=>{"use strict";$e();xr();be();Ot();la=(e,t,r,a,n=!1)=>{let o=e[0].dims,u=e[1].dims,l=o[o.length-2],i=u[u.length-1],c=o[o.length-1],f=Ve(i),g=Ve(c),m=Ve(l),w=D.size(r)/f/m,b=e.length>2,$=a?a.slice(0,-2):r.slice(0,-2),S=[D.size($),l,i],_=[{type:"uint32",data:w},{type:"uint32",data:l},{type:"uint32",data:i},{type:"uint32",data:c},...K($),...K(o),...K(u)];b&&_.push(...K(e[2].dims)),_.push(...K(S));let k=A=>{let z=sn("batch_dims",e[0].dataType,$.length),E=V("a",e[0].dataType,o.length,g),U=V("b",e[1].dataType,u.length,f),W=Y("output",e[0].dataType,S.length,f),{activationFunction:L,applyActivation:X}=st(t,W.type.value),B=[E,U],j="";if(b){let me=n?f:1;B.push(V("bias",e[2].dataType,e[2].dims.length,me)),j=`${n?`value += bias[col / ${me}];`:`value += ${W.type.value}(bias[row + i]);`}`}let pe=o.slice(0,-2),J=u.slice(0,-2),we=Xt(pe,$),Z=Xt(J,$),ye=(me,ce)=>{let He=me.rank,Me=me.name;if(He===2)return`var ${Me}_indices = ${me.type.indices}(0u, 0u);`;let Le=z.rank,G=`var ${Me}_indices: ${me.type.indices};`;for(let ne=He-2-1,he=Le-1;ne>=0;ne--,he--)G+=`
${Me}_indices[${ne}] = ${Le>1?`batch_indices[${he}]`:"batch_indices"};`;return ce.forEach(ne=>{G+=`
${Me}_indices[${ne}] = 0;`}),G+=`${Me}_indices[${He-2}] = 0u;
                     ${Me}_indices[${He-1}] = 0u;`,G},_e=()=>{let me=`var a_data: ${E.type.value};`;for(let ce=0;ce<g;ce++)me+=`
              let b_data${ce} = b[(b_offset + (k + ${ce}) * uniforms.N + col) / ${f}];`;for(let ce=0;ce<m;ce++){me+=`a_data = a[(a_offset + (row + ${ce}) * uniforms.K + k) / ${g}];`;for(let He=0;He<g;He++)me+=`
            values[${ce}] = fma(${U.type.value}(a_data${g===1?"":`[${He}]`}), b_data${He}, values[${ce}]);
`}return me};return`
  ${A.registerUniform("outputSize","u32").registerUniform("M","u32").registerUniform("N","u32").registerUniform("K","u32").registerInternalVariables(z).declareVariables(...B,W)}
  ${L}
  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    let col = (global_idx % (uniforms.N / ${f})) * ${f};
    var index1 = global_idx / (uniforms.N / ${f});
    let stride1 = uniforms.M / ${m};
    let row = (index1 % stride1) * ${m};
    let batch = index1 / stride1;

    ${r.length===2?"":`let batch_indices = ${z.offsetToIndices("batch")};`}
    ${ye(E,we)}
    let a_offset = ${E.indicesToOffset("a_indices")};
    ${ye(U,Z)}
    let b_offset = ${U.indicesToOffset("b_indices")};
    var values: array<${W.type.value}, ${m}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${g}) {
      ${_e()}
    }
    for (var i = 0u; i < ${m}u; i++) {
      var value = values[i];
      ${j}
      ${X}
      let cur_indices = ${W.type.indices}(batch, row + i, col);
      let offset = ${W.indicesToOffset("cur_indices")};
      ${W.setByOffset(`offset / ${f}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${t.activationCacheKey}_${f}_${g}_${m}_${n}`,inputDependencies:b?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:_}),getShaderSource:k}},gc=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Ms=e=>{gc(e.inputs);let t=pt.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");let r=t[t.length-1],a=e.inputs[0].dims[e.inputs[0].dims.length-1];r<8&&a<8?e.compute(la(e.inputs,{activation:"",activationCacheKey:""},t)):e.compute(yn(e.inputs,{activation:"",activationCacheKey:""},t))}});var bn,ca,yc,zs,pa,bc,wc,fa,ua=q(()=>{"use strict";$e();Re();Rs();xr();Bs();Ot();da();Jt();bn=(e,t,r,a,n,o)=>{let u=e[0],l=e.slice(o?1:2,o?3:4),i=l.length,c=t[0],g=t.slice(2).map((b,$)=>b+(b-1)*(r[$]-1)),w=l.map((b,$)=>b+a[$]+a[$+i]).map((b,$)=>Math.floor((b-g[$]+n[$])/n[$]));return w.splice(0,0,u),w.splice(o?3:1,0,c),w},ca=[2,3,1,0],yc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],a=e[1].dims[1]*t.group;if(r!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},zs=(e,t)=>{let r=e.kernelShape.slice();for(let o=2;o<t[1].dims.length;++o)r[o-2]===0&&(r[o-2]=t[1].dims[o]);let a=e.pads.slice();Ht.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,a,e.format==="NHWC",e.autoPad);let n=Object.assign({},e);return Object.assign(n,{kernelShape:r,pads:a,cacheKey:e.cacheKey}),n},pa=e=>{let t=fn(e),r=e.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],n=e.dilations,o=e.group,u=e.kernel_shape,l=e.pads,i=e.strides,c=e.w_is_const();return ee({autoPad:a,format:r,dilations:n,group:o,kernelShape:u,pads:l,strides:i,wIsConst:c,...t})},bc=(e,t,r)=>{let a=zs(r,t),n=r.format==="NHWC";if(r.group!==1){if(n&&t[1].dims[0]===r.group&&t[1].dims[1]===1&&r.dilations[0]===1&&r.dilations[1]===1){let E=bn(t[0].dims,t[1].dims,r.dilations,a.pads,r.strides,n),U=e.kernelCustomData.wT??e.compute(at(t[1],ca),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=U);let W=[t[0],U];t.length===3&&W.push(t[2]),e.compute(Ps(W,a,E),{inputs:W})}else e.compute(sa(t,a));return}let o=t.length===3,u=t[0].dims[n?1:2],l=t[0].dims[n?2:3],i=t[0].dims[n?3:1],c=t[1].dims[2],f=t[1].dims[3],g=bn(t[0].dims,t[1].dims,r.dilations,a.pads,r.strides,n),m=g[n?1:2],w=g[n?2:3],b=g[n?3:1],$=n&&c===u&&f===l&&r.pads[0]===0&&r.pads[1]===0;if($||c===1&&f===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let E=g[0],U,W,L,X=[];if(n){let pe=e.kernelCustomData.wT??e.compute(at(t[1],ca),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=pe),$){let J=u*l*i;U=t[0].reshape([1,E,J]),W=pe.reshape([1,J,b]),L=[1,E,b]}else U=t[0].reshape([E,u*l,i]),W=pe.reshape([1,i,b]),L=[E,m*w,b];X.push(U),X.push(W)}else U=t[0].reshape([E,i,u*l]),W=t[1].reshape([1,b,i]),L=[E,b,m*w],X.push(W),X.push(U);o&&X.push(t[2]);let B=L[2],j=X[0].dims[X[0].dims.length-1];B<8&&j<8?e.compute(la(X,a,g,L,n),{inputs:X}):e.compute(yn(X,a,g,L,n),{inputs:X});return}let I=!0,S=e.kernelCustomData.wT??e.compute(at(t[1],ca),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=S);let _=[t[0],S];o&&_.push(t[2]);let k=n?m*w:b,A=n?b:m*w,z=c*f*i;e.compute(ks(_,a,g,k,A,z,o,I),{inputs:_})},wc=(e,t)=>{let r=t.format==="NHWC",a=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&a.push(e.inputs[2]);let n=[0,t.pads[0],0,t.pads[1]],o=[1].concat(t.strides),u=[1].concat(t.dilations),l=[1].concat(t.kernelShape),i=zs({...t,pads:n,strides:o,dilations:u,kernelShape:l},a);e.compute(sa(a,i,c=>r?[c[0],c[2],c[3]]:[]))},fa=(e,t)=>{yc(e.inputs,t),e.inputs[0].dims.length===3?wc(e,t):bc(e,e.inputs,t)}});var vc,Ds,Ws=q(()=>{"use strict";Et();be();Ot();hn();oa();xr();vc=(e,t=!1,r,a=4)=>{let n=Fe(a,"f32"),o=_=>{switch(_){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${_} is not supported.`)}},u=e?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,l=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,i=e?"outBackprop[1]":"outBackprop[2]",c=e?"outBackprop[2]":"outBackprop[3]",f=e?"row":"col",g=e?"col":"row",m=`
      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      let outRow = ${f} / outWidth;
      let outCol = ${f} % outWidth;

      let WRow = ${g} / (filterDims[1] * inChannels);
      let WCol = ${g} / inChannels % filterDims[1];
      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);
      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);
      if (xR < 0.0 || xR >= f32(${i}) || fract(xR) > 0.0) {
        return ${n}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${c}) || fract(xC) > 0.0) {
        return ${n}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${g} % inChannels;
      ${u}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${a}];`,w=e?`
      let col = colIn * ${a};
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${m}
      }
      return ${n}(0.0);`:`
      let col = colIn * ${a};
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${m}
      }
      return ${n}(0.0);`,b=`
      let col = colIn * ${a};
      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};
      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);
      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];
      if (${e?"row < uniforms.dimInner && col < uniforms.dimBOuter":"row < uniforms.dimInner && col < uniforms.dimAOuter"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${o(a)}
      }
      return ${n}(0.0);
      `,{activationFunction:$,applyActivation:I}=st(r,n);return`
      ${$}
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${n} {
    ${e?w:b}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${n} {
    ${e?b:w}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${n}) {
    let col = colIn * ${a};
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${l}
      ${mn(t)}
      ${I}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${a}] = value;
    }
  }`},Ds=(e,t,r,a,n,o,u,l)=>{let i=t.format==="NHWC",c=i?e[0].dims[3]:e[0].dims[1],f=r[0],g=i?r[2]:r[3],m=i?r[1]:r[2],w=i?r[3]:r[1],b=i?c%4===0&&w%4===0:g%4===0&&w%4===0,$=i?w:g*m,I=i?g*m:w,S=b?[8,8,1]:[$<=4||I<=4?4:16,$>4&&I<=4?4:16,1],_=b?[4,4,1]:[$<=4?1:4,$>4&&I<=4?1:4,1],k=[Math.ceil($/S[0]/_[0]),Math.ceil(I/S[1]/_[1]),Math.ceil(f/S[2]/_[2])];Be("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${k}`);let A=b?4:1,z=Math.max(S[0]*A,S[1]),E=b?4:1,U=[{type:"int32",data:a},{type:"int32",data:n},{type:"int32",data:o}],W=V("x",e[0].dataType,e[0].dims.length,E),L=V("w",e[1].dataType,e[1].dims.length,1),X=Y("result",e[0].dataType,r.length,E),B=[W,L];U.push(...K(e[0].dims)),U.push(...K(e[1].dims));let j="";if(u){let pe=V("bias",e[2].dataType,e[2].dims.length,E);B.push(pe),U.push(...K(e[2].dims)),j+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${b?"vec4<f32>":"f32"} {
          return bias[coords.${i?"w":"y"}${b?"/ 4":""}];
        }`}return U.push(...K(r)),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:k[0],y:k[1],z:k[2]},programUniforms:U}),getShaderSource:pe=>`
        ${gn("uniforms.result_strides")}
        ${pe.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...B,X)};
        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[i?1:2]}, ${t.kernelShape[i?2:3]});
        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(
              ${t.dilations[0]<=1?0:(t.kernelShape[i?1:2]-1)*(t.dilations[0]-1)},
              ${t.dilations[1]<=1?0:(t.kernelShape[i?2:3]-1)*(t.dilations[1]-1)});
        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,
                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);
        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});
        const dimAOuter : i32 = ${a};
        const dimBOuter : i32 = ${n};
        const dimInner : i32 = ${o};
        ${j}
        ${vc(i,u,t,A)}
        ${b?$r(_,S,"f32",void 0,!i,z):Sr(_,S,"f32",void 0,!i,z,!1,void 0,l)}`}}});var $c,ma,Vs=q(()=>{"use strict";Et();$e();be();$c=(e,t,r,a,n,o,u=!1,l)=>{let i=r.format==="NHWC",c=i?1:2,f=i?2:3,g=i?3:1,m=D.size(a),w=u?2:1,b=r.group,$=t[1].dims,I=$[0]/b,S=$[1],_=`
  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${l}>`:l}) {
    result[flatIndex] = ${u?`vec4<${l}>`:l}(value);
  }`;n&&(_+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${l}>`:l} {
      return bias[coords.${i?"w":"y"}${u?"/ 4":""}];
    }`);let k=u?4:1,A=V("W",t[1].dataType,t[1].dims,k),z=V("Dy",t[0].dataType,t[0].dims,k),E=[z,A];n&&E.push(V("bias",t[2].dataType,[a[g]],k));let U=Y("result",t[0].dataType,a,k),W=`{
        let batch: u32 = ${o?"global_id.z":"workgroup_id.z"} / outShape[1];
        let r = ${o?"global_id.z":"workgroup_id.z"} % outShape[1];
        let c = ${o?"global_id.y":"workgroup_id.y"} * ${w};
        let d1: u32 = ${o?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${l}>, ${w}>;
        for (var i = 0; i < ${w}; i++) {
          dotProd[i] = vec4<${l}>(0.0);
        }
        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {
          var dyR = (${l}(dyCorner.x) + ${l}(wR)) / ${l}(strides.x);
          let wRPerm = filterDims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${l}(outBackprop[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {
            let dyC = (${l}(dyCorner.y) + ${l}(wC)) / ${l}(strides.y);
            let dyC2 = (${l}(dyCorner.y) + 1.0 + ${l}(wC)) / ${l}(strides.y);
            let wCPerm = filterDims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${l}(outBackprop[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${l}(outBackprop[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${z.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${z.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${l}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = outBackprop[${g}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${z.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${z.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${w}; i = i + 1) {
          let value = dotProd[i] + ${n?"bias[c+i]":"0.0"};
          ${U.set("batch","r","c + i","d1","value")};
        }
      }`,L=`
          let outputIndices = ${U.offsetToIndices("global_idx")};
          let batch = ${U.indicesGet("outputIndices",0)};
          let d1 = ${U.indicesGet("outputIndices",g)};
          let r = ${U.indicesGet("outputIndices",c)};
          let c = ${U.indicesGet("outputIndices",f)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / ${S};
          let wOutChannel = d1 - groupId * ${S};
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = 0.0;
          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {
            if (wR % dilations.x != 0) {
              continue;
            }
            let dyR = (${l}(dyRCorner) + ${l}(wR)) / ${l}(strides[0]);
            let wRPerm = filterDims.x - 1 - wR / dilations.x;
            if (dyR < 0.0 || dyR >= ${l}(outBackprop[${c}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {
              if (wC % dilations.y != 0) {
                continue;
              }
              let dyC = (${l}(dyCCorner) + ${l}(wC)) / ${l}(strides.y);
              let wCPerm = filterDims.y - 1 - wC / dilations.y;
              if (dyC < 0.0 || dyC >= ${l}(outBackprop[${f}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * ${I};
              for (var d2: u32 = 0; d2 < ${I}; d2 = d2 + 1) {
                let xValue = ${i?z.get("batch","idyR","idyC","inputChannel"):z.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${A.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${n?"bias[d1]":"0.0"};
          ${U.setByOffset("global_idx","value")};
        `;return`
  ${e.declareVariables(...E,U)}
  ${_}
  const outShape : vec4<u32> = vec4<u32>(${a.join(",")});
  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});
  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});
  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[i?1:2]}, ${r.kernelShape[i?2:3]});
  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});
  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(
          ${r.dilations[0]<=1?0:(r.kernelShape[i?1:2]-1)*(r.dilations[0]-1)},
          ${r.dilations[1]<=1?0:(r.kernelShape[i?2:3]-1)*(r.dilations[1]-1)});
  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,
                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);
    ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes(m)};
  ${u?W:L}}`},ma=(e,t,r)=>{let a=e.length>2,n=t.outputShape,o=D.size(n),u=[Math.ceil(o/64),1,1];Be("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${u}`);let l=ke(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:u[0],y:u[1],z:u[2]},outputs:[{dims:r?r(n):n,dataType:e[0].dataType}]}),getShaderSource:i=>$c(i,e,t,n,a,u[1]===1&&u[2]===1,!1,l)}}});var Sc,xc,_c,Us,Ns,Cc,Ic,Ac,Ec,Hs,Ls=q(()=>{"use strict";Re();Ws();Vs();Ot();Jt();Sc=(e,t,r,a,n,o)=>(e-1)*t+r+(a-1)*n+1-o,xc=(e,t,r,a,n)=>{let o=Math.floor(e/2);t==="SAME_UPPER"?(r[a]=o,r[n]=e-o):t==="SAME_LOWER"&&(r[a]=e-o,r[n]=o)},_c=(e,t,r,a,n,o,u,l,i,c)=>{let f=e.length-2,g=c.length===0;if(i.length===0)for(let b=0;b<f;++b)i.push(0);let m=e[0],w=t[l?3:1]*n;for(let b=0,$=e.length-f-(l?1:0);b<f;++b,++$){let I=e[$],S=g?I*u[b]:c[b],_=Sc(I,u[b],o[b],t[$],r[b],S);xc(_,a,o,b,b+f),g&&c.push(u[b]*(I-1)+i[b]+(t[$]-1)*r[b]+1-o[b]-o[b+f])}c.splice(0,0,m),c.splice(l?3:1,0,w)},Us=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((m,w)=>m*w,1)===0){r.length=0;for(let m=2;m<t[1].dims.length;++m)r.push(t[1].dims[m])}let a=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(a?3:1,0,t[1].dims[1]);let n=e.pads.slice(),o=e.outputShape.slice(),u=e.outputPadding.slice(),l=t[0].dims,i=e.dilations.slice();if(i.reduce((m,w)=>m+w,0)===0){let m=t[0].dims.length-2;i=new Array(m).fill(1)}let c=e.strides.slice();if(c.reduce((m,w)=>m+w,0)===0){let m=t[0].dims.length-2;c=new Array(m).fill(1)}_c(l,r,i,e.autoPad,e.group,n,c,a,u,o);let f=Object.assign({},e),g=e.cacheKey+[r.join("n,"),n.join(","),c.join(","),u.join(","),o.join(","),i.join(",")].join("_");return Object.assign(f,{kernelShape:r,pads:n,outputPadding:u,outputShape:o,dilations:i,strides:c,cacheKey:g}),f},Ns=e=>{let t=fn(e),r=e.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],n=e.dilations,o=e.group,u=e.kernelShape,l=e.pads,i=e.strides,c=e.wIsConst(),f=e.outputPadding,g=e.outputShape;return ee({autoPad:a,format:r,dilations:n,group:o,kernelShape:u,outputPadding:f,outputShape:g,pads:l,strides:i,wIsConst:c,...t})},Cc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],a=e[1].dims[0];if(r!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==n))throw new Error("invalid bias");let o=e[0].dims.length-2;if(t.dilations.reduce((f,g)=>f+g,0)>0&&t.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(t.strides.reduce((f,g)=>f+g,0)>0&&t.strides.length!==o)throw new Error(`strides should be ${o}D`);if(t.pads.reduce((f,g)=>f+g,0)>0&&t.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(t.outputPadding.length!==o&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${o}D`);if(t.kernelShape.reduce((f,g)=>f+g,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Ic=[2,3,1,0],Ac=(e,t,r)=>{let a=Us(r,t),n=r.format==="NHWC",o=a.outputShape,u=o[n?3:1],l=t[0].dims[n?3:1];if(a.group!==1||u===1&&l===1){e.compute(ma(t,a));return}let i=o[n?1:2],c=o[n?2:3],f=t[1].dims[2],g=t[1].dims[3],m=n?i*c:u,w=n?u:i*c,b=f*g*l,$=!0,I=e.kernelCustomData.wT??e.compute(at(t[1],Ic),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let S=[t[0],I],_=t.length===3;_&&(!n&&t[2].dims.length===1?S.push(t[2].reshape([t[2].dims[0],1,1])):S.push(t[2])),e.compute(Ds(S,a,o,m,w,b,_,$),{inputs:S})},Ec=(e,t)=>{let r=t.format==="NHWC",a=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];a.length===3&&a.push(e.inputs[2]);let n=t.kernelShape;(n.length===0||n[0]===0)&&(n=[e.inputs[1].dims[2]]);let o=t.dilations;(o.length===0||o[0]===0)&&(o=[1]);let u=t.strides;(u.length===0||u[0]===0)&&(u=[1]);let l=t.pads;l.length===0&&(l=[0,0]),l=[0,l[0],0,l[1]],u=[1].concat(u),o=[1].concat(o),n=[1].concat(n);let i=Us({...t,pads:l,strides:u,dilations:o,kernelShape:n},a);e.compute(ma(a,i,c=>r?[c[0],c[2],c[3]]:[c[0],c[1],c[3]]))},Hs=(e,t)=>{Cc(e.inputs,t),e.inputs[0].dims.length===3?Ec(e,t):Ac(e,e.inputs,t)}});var Tc,Gs,Fs,qs=q(()=>{"use strict";We();$e();Re();be();Tc=(e,t,r,a)=>{let n=D.size(t),o=t.length,u=V("input",e,o),l=Y("output",e,o),i=r.dataType===6?r.getInt32Array()[0]:Number(r.getBigInt64Array()[0]),c=D.normalizeAxis(i,o),f=g=>{let m=` i32(${u.indicesGet("inputIndices","uniforms.axis")}) `,w=Ae("uniforms.input_shape","uniforms.axis",o),b=a.reverse?m+(a.exclusive?" + 1":""):"0",$=a.reverse?w:m+(a.exclusive?"":" + 1");return`
                ${g.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(u,l)}
                ${g.mainStart()}
                  ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${l.offsetToIndices("global_idx")};
                  var sum = ${l.type.value}(0);
                  let first : i32 = ${b};
                  let last : i32 = ${$};
                  for (var i : i32 = first; i < last; i++) {
                    ${u.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${u.getByIndices("inputIndices")};
                  }
                  ${l.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:a.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:[{type:"uint32",data:n},{type:"int32",data:c},...K(t),...K(t)]}),getShaderSource:f}},Gs=(e,t)=>{let r=e.inputs[0].dims,a=e.inputs[0].dataType,n=e.inputs[1];e.compute(Tc(a,r,n,t),{inputs:[0]})},Fs=e=>{let t=e.exclusive===1,r=e.reverse===1;return ee({exclusive:t,reverse:r})}});var ha,wn,js,Oc,kc,ga,ya,Ks,Rc,Ys,Zs,Qs=q(()=>{"use strict";$e();Re();be();ha="[a-zA-Z]|\\.\\.\\.",wn="("+ha+")+",js="^"+wn+"$",Oc="("+wn+",)*"+wn,kc="^"+Oc+"$",ga=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let a=this.symbolToIndices.get(t);a===void 0?a=[r]:a.push(r),this.symbolToIndices.set(t,a)}},ya=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[a,n]=r.includes("->")?r.split("->",2):[r,""];if(!a.match(RegExp(kc)))throw new Error("Invalid LHS term");if(a.split(",").forEach((l,i)=>{let c=t[i].dims.slice();if(!l.match(RegExp(js)))throw new Error("Invalid LHS term");let f=this.processTerm(l,!0,c,i);this.lhs.push(f)}),n==="")n+=[...this.symbolToInfo.entries()].filter(([l,i])=>i.count===1||l==="...").map(([l])=>l).join("");else if(!n.match(RegExp(wn)))throw new Error("Invalid RHS");n.match(RegExp(ha,"g"))?.forEach(l=>{if(l==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let i=this.symbolToInfo.get(l);if(i===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(i.dimValue)}}),this.rhs=this.processTerm(n,!1,this.outputDims)}addSymbol(t,r,a){let n=this.symbolToInfo.get(t);if(n!==void 0){if(n.dimValue!==r&&n.count!==1)throw new Error("Dimension mismatch");n.count++,n.inputIndices.push(a)}else n={count:1,dimValue:r,inputIndices:[a]};this.symbolToInfo.set(t,n)}processTerm(t,r,a,n=-1){let o=a.length,u=!1,l=[],i=0;if(!t.match(RegExp(js))&&!r&&t!=="")throw new Error("Invalid LHS term");let c=t.match(RegExp(ha,"g")),f=new ga(n);return c?.forEach((g,m)=>{if(g==="..."){if(u)throw new Error("Only one ellipsis is allowed per input term");u=!0;let w=o-c.length+1;if(w<0)throw new Error("Ellipsis out of bounds");if(l=a.slice(i,i+w),this.hasEllipsis){if(this.ellipsisDims.length!==l.length||this.ellipsisDims.toString()!==l.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=l;else throw new Error("Ellipsis must be specified in the LHS");for(let b=0;b<l.length;b++){let $=String.fromCharCode("0".charCodeAt(0)+b);f.addSymbol($,m+b),this.addSymbol($,a[i++],n)}}else f.addSymbol(g,m+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(g,a[i++],n)}),f}},Ks=e=>e+"_max",Rc=(e,t,r,a,n)=>{let u=t.map((w,b)=>e[b]?w.length:w).map((w,b)=>V(`input${b}`,r,w)),l=D.size(n),i=Pe(n.length),c=i?n.length:n,f=Y("output",r,c),g=[...a.symbolToInfo.keys()].filter(w=>!a.rhs.symbolToIndices.has(w)),m=w=>{let b=[],$="var prod = 1.0;",I="var sum = 0.0;",S="sum += prod;",_=[],k=[],A=[],z=[],E=a.symbolToInfo.size===a.rhs.symbolToIndices.size;a.symbolToInfo.forEach((W,L)=>{if(a.rhs.symbolToIndices.has(L)){let X=a.rhs.symbolToIndices.get(L)?.[0];X!==void 0&&a.lhs.forEach((B,j)=>{if(W.inputIndices.includes(j)){let pe=B.symbolToIndices.get(L);if(pe===void 0)throw new Error("Invalid symbol error");pe.forEach(J=>{b.push(`${u[j].indicesSet(`input${j}Indices`,J,f.indicesGet("outputIndices",X))}`)})}})}else a.lhs.forEach((X,B)=>{if(W.inputIndices.includes(B)){let j=X.symbolToIndices.get(L);if(j===void 0)throw new Error("Invalid symbol error");j.forEach(pe=>{_.push(`${u[B].indicesSet(`input${B}Indices`,pe,`${L}`)}`)}),z.push(`prod *= ${u[B].getByIndices(`input${B}Indices`)};`)}}),k.push(`for(var ${L}: u32 = 0; ${L} < uniforms.${Ks(L)}; ${L}++) {`),A.push("}")});let U=E?[...b,`let sum = ${u.map((W,L)=>W.getByIndices(`input${L}Indices`)).join(" * ")};`]:[...b,I,...k,..._,$,...z,S,...A];return`
            ${w.registerUniforms(g.map(W=>({name:`${Ks(W)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...u,f)}

            ${w.mainStart()}
            ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${f.offsetToIndices("global_idx")};
            ${u.map((W,L)=>`var input${L}Indices: ${u[L].type.indices};`).join(`
`)}
            ${U.join(`
`)};
            ${f.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:a.equation,inputDependencies:e.map(w=>w?"rank":"dims")},getRunData:()=>{let w=g.filter($=>a.symbolToInfo.has($)).map($=>({type:"uint32",data:a.symbolToInfo.get($)?.dimValue||0}));w.push({type:"uint32",data:l});let b=t.filter(($,I)=>e[I]).map(($,I)=>[...K($)]).reduce(($,I)=>$.concat(I),w);return i&&b.push(...K(n)),{outputs:[{dims:n,dataType:r}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:b}},getShaderSource:m}},Ys=(e,t)=>{let r=new ya(e.inputs,t.equation),a=e.inputs.map((u,l)=>Pe(u.dims.length)),n=r.outputDims,o=e.inputs.map((u,l)=>u.dims);e.compute(Rc(a,o,e.inputs[0].dataType,r,n))},Zs=e=>{let t=e.equation.replace(/\s+/g,"");return ee({equation:t})}});var Pc,Xs,Bc,Mc,Js,eu=q(()=>{"use strict";We();$e();be();Pc=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),a=r.length<t.length?0:r.length-t.length,n=t.length<r.length?0:t.length-r.length;for(;a<r.length&&n<t.length;++a,++n)if(r[a]!==t[n]&&r[a]!==1&&t[n]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Xs=(e,t)=>{let r=e.length-t.length,a=[];for(let n=0;n<r;++n)a.push(e[n]);for(let n=0;n<t.length;++n)a.push(t[n]===1?e[n+r]:t[n]);return a},Bc=(e,t)=>e.length>t.length?Xs(e,t):Xs(t,e),Mc=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),a=Bc(t,r),n=e[0].dataType,o=n===9?4:1,u=D.size(a)/o,l=Pe(t.length),i=Pe(a.length),c=g=>{let m=l?t.length:t,w=i?a.length:a,b=V("input",n,m,o),$=Y("output",n,w,o),I;if(n===9){let S=(_,k,A="")=>`
          let outputIndices${k} = ${$.offsetToIndices(`outputOffset + ${k}u`)};
          let offset${k} = ${b.broadcastedIndicesToOffset(`outputIndices${k}`,$)};
          let index${k} = offset${k} / 4u;
          let component${k} = offset${k} % 4u;
          ${_}[${k}] = ${A}(${b.getByOffset(`index${k}`)}[component${k}]);
        `;I=`
        let outputOffset = global_idx * ${o};
        var data = vec4<u32>(0);
        ${S("data",0,"u32")}
        ${S("data",1,"u32")}
        ${S("data",2,"u32")}
        ${S("data",3,"u32")}
        ${$.setByOffset("global_idx","data")}
      }`}else I=`
        let outputIndices = ${$.offsetToIndices("global_idx")};
        let inputOffset = ${b.broadcastedIndicesToOffset("outputIndices",$)};
        ${$.setByOffset("global_idx",b.getByOffset("inputOffset"))}
      }`;return`
    ${g.registerUniform("vec_size","u32").declareVariables(b,$)}
    ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${I}`},f=[{type:"uint32",data:u}];return l&&f.push(...K(t)),i&&f.push(...K(a)),{name:"Expand",shaderCache:{hint:`${a.length}`,inputDependencies:[l?"rank":"dims"]},getShaderSource:c,getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:f})}},Js=e=>{Pc(e.inputs),e.compute(Mc(e.inputs),{inputs:[0]})}});var zc,Dc,tu,ru,nu=q(()=>{"use strict";We();$e();Re();be();zc=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},Dc=(e,t)=>{let r=e[0].dims,a=e[1].dims,n=r.length,o=D.normalizeAxis(t.axis,n),u=r.slice(0);u.splice(o,1,...a);let l=r[o],i=e[0].dataType===9?4:1,c=D.size(u)/i,f=Pe(e[0].dims.length),g=f?e[0].dims.length:e[0].dims,m=Pe(e[1].dims.length),w=m?e[1].dims.length:e[1].dims,b=Pe(u.length),$=b?u.length:u,I=[{type:"uint32",data:c},{type:"int32",data:l},{type:"uint32",data:o}];f&&I.push(...K(e[0].dims)),m&&I.push(...K(e[1].dims)),b&&I.push(...K(u));let S=[];S.push(f?"rank":"dims"),S.push(m?"rank":"dims");let _=k=>{let A=V("data",e[0].dataType,g,i),z=V("inputIndices",e[1].dataType,w),E=Y("output",e[0].dataType,$,i),U=L=>{let X=a.length,B=`var indicesIndices${L}  = ${z.type.indices}(0);`;for(let j=0;j<X;j++)B+=`${X>1?`indicesIndices${L}[${j}]`:`indicesIndices${L}`} = ${u.length>1?`outputIndices${L}[uniforms.axis + ${j}]`:`outputIndices${L}`};`;B+=`
          var idx${L} = ${z.getByIndices(`indicesIndices${L}`)};
          if (idx${L} < 0) {
            idx${L} = idx${L} + uniforms.axisDimLimit;
          }
          var dataIndices${L} = ${A.type.indices}(0);
        `;for(let j=0,pe=0;j<n;j++)j===o?(B+=`${n>1?`dataIndices${L}[${j}]`:`dataIndices${L}`} = u32(idx${L});`,pe+=X):(B+=`${n>1?`dataIndices${L}[${j}]`:`dataIndices${L}`} = ${u.length>1?`outputIndices${L}[${pe}]`:`outputIndices${L}`};`,pe++);return B},W;if(e[0].dataType===9){let L=(X,B,j="")=>`
          let outputIndices${B} = ${E.offsetToIndices(`outputOffset + ${B}u`)};
          ${U(B)};
          let offset${B} = ${A.indicesToOffset(`dataIndices${B}`)};
          let index${B} = offset${B} / 4u;
          let component${B} = offset${B} % 4u;
          ${X}[${B}] = ${j}(${A.getByOffset(`index${B}`)}[component${B}]);
        `;W=`
        let outputOffset = global_idx * ${i};
        var value = vec4<u32>(0);
        ${L("value",0,"u32")}
        ${L("value",1,"u32")}
        ${L("value",2,"u32")}
        ${L("value",3,"u32")}
        ${E.setByOffset("global_idx","value")}
      `}else W=`
      let outputIndices = ${E.offsetToIndices("global_idx")};
      ${U("")};
      let value = ${A.getByIndices("dataIndices")};
      ${E.setByOffset("global_idx","value")};
      `;return`
      ${k.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(A,z,E)}
      ${k.mainStart()}
        ${k.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${W}
      }`};return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:S},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:I}),getShaderSource:_}},tu=e=>ee({axis:e.axis}),ru=(e,t)=>{let r=e.inputs;zc(r),e.compute(Dc(e.inputs,t))}});var Wc,Vc,au,iu,ou=q(()=>{"use strict";$e();Re();be();Wc=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},Vc=(e,t)=>{let r=e[0].dims,a=e[0].dataType,n=r.length,o=e[1].dims,u=e[1].dataType,l=D.normalizeAxis(t.axis,n),i=r[l],c=o.slice(0),f=D.size(c),g=V("input",a,n),m=V("indicesInput",u,o.length),w=Y("output",a,c.length),b=[{type:"uint32",data:f},{type:"int32",data:i},{type:"uint32",data:l}];return b.push(...K(r)),b.push(...K(o)),b.push(...K(c)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:c,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:b}),getShaderSource:S=>`
      ${S.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(g,m,w)}
      ${S.mainStart()}
      ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${w.offsetToIndices("global_idx")};

      var idx = ${m.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${g.type.indices}(outputIndices);
      ${g.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${g.getByIndices("inputIndices")};

      ${w.setByOffset("global_idx","value")};
  }`}},au=e=>ee({axis:e.axis}),iu=(e,t)=>{let r=e.inputs;Wc(r),e.compute(Vc(e.inputs,t))}});var Uc,Nc,Hc,su,uu,lu=q(()=>{"use strict";$e();Re();be();Uc=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Nc=(e,t,r)=>{if(r.length===0)return"0u";let a=r.length===1&&e!==1||r.length===2&&r[0]!==e,n=r[r.length-1]!==t,o="0u";return a||(o+=`+ m * ${r[r.length-1]}u`),n||(o+="+n"),o},Hc=(e,t)=>{let r=e[0].dims.slice(),a=e[1].dims.slice(),[n,o,u]=nn.getShapeOfGemmResult(r,t.transA,a,t.transB,e.length===3?e[2].dims:void 0),l=[n,o];if(!l)throw new Error("Can't use gemm on the given tensors");let i=D.size(l),c="";t.transA&&t.transB?c="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?c="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?c="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(c="value += a[m * K + k] * b[k * N + n];");let f=ke(e[0].dataType),g=t.alpha===1?"":"value *= alpha;",m=e.length===3?`value += beta * c[${Nc(n,o,e[2].dims)}];`:"",w=[`@group(0) @binding(0) var<storage, read> a : array<${f}>;`,`@group(0) @binding(1) var<storage, read> b : array<${f}>;`];e.length===3&&w.push(`@group(0) @binding(2) var<storage, read> c : array<${f}>;`);let b=$=>`
  const M: u32 = ${n}u;
  const N: u32 = ${o}u;
  const K: u32 = ${u}u;
  const alpha = ${f}(${t.alpha});
  const beta = ${f}(${t.beta});

  ${w.join(`
`)}
  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${f}>;

  ${$.mainStart()}
    ${$.guardAgainstOutOfBoundsWorkgroupSizes(i)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${f}(0);
    for (var k: u32 = 0u; k<${u}u; k++) {
      ${c}
    }

    ${g}
    ${m}
    output[global_id.x] = value;

  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:l,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:b}},su=(e,t)=>{Uc(e.inputs),e.compute(Hc(e.inputs,t))},uu=e=>ee(e)});var Lc,Gc,Fc,qc,du,cu,pu=q(()=>{"use strict";We();$e();Re();be();Lc={name:"InstanceNormalization"},Gc=(e,t)=>{let r=e[0].dims,a=r,n=2,o=D.sizeToDimension(r,n),u=D.sizeFromDimension(r,n),l=Ve(u),i=u/l,c=r[1],f=V("x",e[0].dataType,[r[0],r[1],i],l),g=V("scale",e[1].dataType,e[1].dims),m=V("bias",e[2].dataType,e[2].dims),w=Y("output",e[0].dataType,[r[0],r[1],i],l),b=[f,g,m,w],$=f.type.value,I=l===1?"f32":`vec${l}<f32>`,S=64,_=k=>`

  const C: u32 = ${c};
  const normSize: u32 = ${u};
  const epsilon: f32 = ${t.epsilon};
  var<workgroup> meanShared : f32;
  var<workgroup> squaredNormShared : f32;
  var<workgroup> workgroupShared : array<${I}, ${S}>;
  const workgroupSize = ${S}u;
  ${k.declareVariables(...b)}
  ${k.mainStart(S)}
    let norm = global_idx / workgroupSize;
    let batch = norm / C;
    let channel = norm % C;
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial = ${I}(0);
    for (var h = localIndex; h < ${i}; h += workgroupSize) {
      initial = initial + ${I}(${f.get("batch","channel","h")});
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = ${et("workgroupShared[0]",l)} / f32(normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = ${I}(0);
    for (var h = localIndex; h < ${i}; h += workgroupSize) {
      let deviation =  ${I}(${f.get("batch","channel","h")}) - ${I}(meanShared);
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = ${et("workgroupShared[0]",l)};
    }
    workgroupBarrier();

    let invStdDev = 1 / sqrt(squaredNormShared / f32(normSize) + epsilon);
    let channelScale = invStdDev * f32(${g.getByOffset("channel")});
    let channelShift = f32(${m.getByOffset("channel")}) - meanShared * channelScale;
    for (var h = localIndex; h < ${i}; h += workgroupSize) {
      let value = ${f.get("batch","channel","h")} * ${$}(${I}(channelScale)) + ${$}(${I}(channelShift));
      ${w.set("batch","channel","h","value")};
    }
  }`;return{...Lc,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:o}}),getShaderSource:_}},Fc=(e,t,r,a,n,o,u,l)=>{let i=Ve(u),c=V("input",t.dataType,t.dims,i),f=V("scale",r.dataType,r.dims,i),g=V("bias",a.dataType,a.dims,i),m=64,w=i===1?"vec2f":`mat2x${i}f`,b=i===1?"f32":`vec${i}f`,$=(z,E)=>`${w}(${z}, ${E})`,I=n*u/i,S=Math.ceil(o/m),_=z=>`
  const H: u32 = ${o};
  const C: u32 = ${u/i};
  const imageSize: u32 = ${o*u/i};

  ${z.declareVariables(c)}
  @group(0) @binding(1) var<storage, read_write> output : array<${w}>;

  ${z.mainStart(m)}
    let currentImageNumber = global_idx / ${m} / C;
    let currentChannelNumber = (global_idx / ${m}) % C;
    let wgId = global_idx % ${m};
    let wgOffset = wgId * ${S};
    if (wgOffset >= H) {
        return;
    }
    let wgMax = min(wgOffset + ${S}, H);

    let offset = currentImageNumber * imageSize + currentChannelNumber;
    var sum = ${Ye("f32",i)};
    var squaredSum = ${Ye("f32",i)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${b}(input[offset + i * C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${$("sum","squaredSum")};
  }`,k=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:i,n,h:o,c:u})},getRunData:()=>({outputs:[{dims:[n,u,m,2],dataType:1}],dispatchGroup:{x:n*u/i}}),getShaderSource:_},{inputs:[t],outputs:[-1]})[0],A=z=>`
  const H: u32 = ${o};
  const C: u32 = ${u/i};
  const imageSize: u32 = ${m*u/i};
  const epsilon: f32 = ${l};

  @group(0) @binding(0) var<storage, read> input : array<${w}>;
  @group(0) @binding(1) var<storage, read> scale : array<${f.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${g.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${w}>;

  ${z.mainStart()}
    ${z.guardAgainstOutOfBoundsWorkgroupSizes(I)}
    let currentImageNumber = global_idx / C;
    let currentChannelNumber = global_idx % C;

    let offset = currentImageNumber * imageSize;
    var sum = ${Ye("f32",i)};
    var squaredSum = ${Ye("f32",i)};
    for (var i: u32 = 0; i < ${m}; i++) {
        let value = input[offset + i + currentChannelNumber * ${m}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(H);
    squaredSum = squaredSum / f32(H);
    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);
    let channelScale = invStdDev * ${b}(scale[currentChannelNumber]);
    let channelShift = ${b}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${$("channelScale","channelShift")};
  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:i,n,h:o,c:u,epsilon:l})},getRunData:()=>({outputs:[{dims:[n,u,2],dataType:1}],dispatchGroup:{x:Math.ceil(I/64)}}),getShaderSource:A},{inputs:[k,r,a],outputs:[-1]})[0]},qc=(e,t,r)=>{let a=t[0].dims,n=a,o=a[0],u=a[a.length-1],l=D.sizeFromDimension(a,1)/u,i=Ve(u),c=D.size(n)/i,f=V("input",t[0].dataType,t[0].dims,i),g=Y("output",t[0].dataType,n,i),m=ke(t[0].dataType),w=i===1?"vec2f":`mat2x${i}f`,b=i===1?m:`vec${i}<${m}>`,$=Fc(e,t[0],t[1],t[2],o,l,u,r.epsilon),I=S=>`
  const H: u32 = ${l};
  const C: u32 = ${u/i};

  @group(0) @binding(0) var<storage, read> input : array<${f.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${w}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${g.type.storage}>;

  ${S.mainStart()}
    let currentImageNumber = global_idx / (C * H);
    let currentChannelNumber = global_idx % C;

    let scaleOffset = currentImageNumber * C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${b}(scale[0]), ${b}(scale[1]));
  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${r.cacheKey}`},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)}}),getShaderSource:I},{inputs:[t[0],$]})},du=e=>ee({epsilon:e.epsilon,format:e.format}),cu=(e,t)=>{t.format==="NHWC"?qc(e,e.inputs,t):e.compute(Gc(e.inputs,t))}});var jc,Kc,fu,mu,hu=q(()=>{"use strict";We();$e();Re();be();jc=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Kc=(e,t,r)=>{let a=e[0].dims,n=e[1],o=e[2],u=a,l=D.normalizeAxis(t.axis,a.length),i=D.sizeToDimension(a,l),c=D.sizeFromDimension(a,l),f=D.size(n.dims),g=o?D.size(o.dims):0;if(f!==c||o&&g!==c)throw new Error(`Size of X.shape()[axis:] == ${c}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${f} and bias size of ${g}`);let m=[];for(let A=0;A<a.length;++A)A<l?m.push(a[A]):m.push(1);let w=Ve(c),b=ke(e[0].dataType),$=[V("x",e[0].dataType,e[0].dims,w),V("scale",n.dataType,n.dims,w)];o&&$.push(V("bias",o.dataType,o.dims,w)),$.push(Y("output",e[0].dataType,u,w));let I=r>1,S=r>2;I&&$.push(Y("meanDataOutput",1,m)),S&&$.push(Y("invStdOutput",1,m));let _=A=>`
  const normSize: f32 = ${c};
  const normSizeVectorized: u32 = ${c/w};
  const epsilon: f32 = ${t.epsilon};

  ${A.declareVariables(...$)}
  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes(i)}
    let offset = global_idx * normSizeVectorized;
    var meanVector = ${Ye("f32",w)};
    var meanSquareVector = ${Ye("f32",w)};

    for (var h: u32 = 0u; h < normSizeVectorized; h++) {
      let value = ${ot(b,w,"x[h + offset]")};
      meanVector += value;
      meanSquareVector += value * value;
    }
    let mean = ${et("meanVector",w)} / normSize;
    let meanSquare = sqrt(${et("meanSquareVector",w)} 
      / normSize - mean * mean + epsilon);

    for (var j: u32 = 0; j < normSizeVectorized; j++) {
      let f32input = ${ot(b,w,"x[j + offset]")};
      let f32scale = ${ot(b,w,"scale[j]")};
      output[j + offset] = ${$[0].type.value}((f32input - mean) / meanSquare * f32scale
        ${o?`+ ${ot(b,w,"bias[j]")}`:""}
      );
    }

    ${I?"meanDataOutput[global_idx] = mean":""};
    ${S?"invStdOutput[global_idx] = 1 / meanSquare":""};
  }`,k=[{dims:u,dataType:e[0].dataType}];return I&&k.push({dims:m,dataType:1}),S&&k.push({dims:m,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:k,dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:_}},fu=e=>ee({axis:e.axis,epsilon:e.epsilon}),mu=(e,t)=>{jc(e.inputs),e.compute(Kc(e.inputs,t,e.outputCount))}});var Yc,yu,gu,Zc,ba,bu,wu=q(()=>{"use strict";$e();Re();tn();aa();be();Jt();Yc=(e,t)=>{let r=e[0],a=e[1],n=e[2],o=e[3],u=e[4],l=e[5],i=e[6],c=e[7];if(r.dims.length!==3&&r.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let f=!1,g=r.dims[0],m=r.dims[1],w=r.dims.length===3?f?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],b=m,$=0,I=0,S=Math.floor(w/t.numHeads);if(i&&c){if(i.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(c.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');$=i.dims[2],I=i.dims[2]}else if(i||c)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let _;if(a){if(r.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(a.dims.length<3||a.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(r.dims[0]!==a.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(a.dims.length===3){if(a.dims[2]!==r.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');_=2,b=a.dims[1]}else if(a.dims.length===5){if(a.dims[2]!==t.numHeads||a.dims[3]!==2||a.dims[4]!==S)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(n)throw new Error('Expect "value" be none when "key" has packed kv format.');_=5,b=a.dims[1]}else{if(a.dims[1]!==t.numHeads||a.dims[3]!==S)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');_=0,b=a.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');_=3}if(o){if(o.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(n&&r.dims.length===5&&r.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let k=0;if(u){k=8;let W=u.dims;throw W.length===1?W[0]===g?k=1:W[0]===3*g+2&&(k=3):W.length===2&&W[0]===g&&W[1]===b&&(k=5),k===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)'):new Error("Mask not supported")}let A=!1,z=w;if(n){if(n.dims.length!==3&&n.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(r.dims[0]!==n.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(n.dims.length===3){if(b!==n.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');z=n.dims[2]}else{if(b!==n.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');z=n.dims[1]*n.dims[3],A=!0}}let E=$+b,U=!1;if(u)throw new Error("Key padding mask is not supported");if(l)throw new Error("extraAddQk is not supported");if(i)throw new Error("pastKey is not supported");if(c)throw new Error("pastValue is not supported");return{batchSize:g,sequenceLength:m,pastSequenceLength:$,kvSequenceLength:b,totalSequenceLength:E,maxSequenceLength:I,inputHiddenSize:0,hiddenSize:w,vHiddenSize:z,headSize:S,vHeadSize:Math.floor(z/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:k,scale:t.scale,broadcastResPosBias:U,passPastInKv:A,qkvFormat:_}},yu=e=>ee({...e}),gu=ee({perm:[0,2,1,3]}),Zc=(e,t,r,a,n,o,u)=>{let l=[a,n,o],i=D.size(l),c=ke(t.dataType),f=g=>`
  const biasOffset = ${u}u;
  const hiddenSize = ${o}u;

  @group(0) @binding(0) var<storage, read> qkv: array<${c}>;
  @group(0) @binding(1) var<storage, read> bias: array<${c}>;
  @group(0) @binding(2) var<storage, read_write> qkv_with_bias: array<${c}>;

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes(i)}
    let biasOffsetIdx = (global_idx % hiddenSize) + biasOffset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[biasOffsetIdx];
  }`;return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{hint:JSON.stringify({batchSize:a,sequenceLength:n,hiddenSize:o,biasOffset:u})},getRunData:()=>({outputs:[{dims:l,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:f},{inputs:[t,r],outputs:[-1]})[0]},ba=(e,t,r,a,n,o,u,l)=>{let i=o;if(u){if(a===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return i=Zc(e,o,u,t,a,r*n,l),i=i.reshape([t,a,r,n]),e.compute(at(i,gu.perm),{inputs:[i],outputs:[-1]})[0]}else return o.dims.length===3&&(i=o.reshape([t,a,r,n])),e.compute(at(i,gu.perm),{inputs:[i],outputs:[-1]})[0]},bu=(e,t)=>{let r=Yc(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(e.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let a=e.inputs[1]&&e.inputs[2]&&e.inputs[1].dims.length===4&&e.inputs[2].dims.length===4,n=ba(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,e.inputs[0],e.inputs[3],0);if(a)return dn(e,n,e.inputs[1],e.inputs[2],e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t);let o=ba(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,e.inputs[1],e.inputs[3],r.hiddenSize),u=ba(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,e.inputs[2],e.inputs[3],2*r.hiddenSize);dn(e,n,o,u,e.inputs[4],void 0,e.inputs[6],e.inputs[7],e.inputs[5],r,t)}});var Qc,Xc,Jc,ep,tp,rp,np,ap,ip,vu,$u,Su=q(()=>{"use strict";We();$e();Re();be();Qc=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Xc=(e,t,r,a,n,o)=>{let u=t.length,l="";for(let i=u-1;i>=0;--i)l+=`
            k = i32(${e.indicesGet("indices",i)}) - ${a[i]};
            if (k < 0) {
              break;
            }
            if (k >= ${t[i]}) {
              break;
            }
            offset += k * ${r[i]};
        `;return`
          value = ${n}(${o});
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${l}
            value = x[offset];
          }
      `},Jc=(e,t,r,a)=>{let n=t.length,o="";for(let u=n-1;u>=0;--u)o+=`
                k = i32(${e.indicesGet("indices",u)}) - ${a[u]};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = ${2*(t[u]-1)};
                  k = k % _2n_1;
                  if(k >= ${t[u]}) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * ${r[u]};
            `;return`
              var offset = 0;
              var k = 0;
              ${o}
              value = x[offset];
          `},ep=(e,t,r,a)=>{let n=t.length,o="";for(let u=n-1;u>=0;--u)o+=`
                k = i32(${e.indicesGet("indices",u)}) - ${a[u]};
                if (k < 0) {
                  k = 0;
                }
                if (k >= ${t[u]}) {
                  k = ${t[u]-1};
                }
                offset += k * ${r[u]};
            `;return`
              var offset = 0;
              var k = 0;
              ${o}
              value = x[offset];
          `},tp=(e,t,r,a)=>{let n=t.length,o="";for(let u=n-1;u>=0;--u)o+=`
                k = i32(${e.indicesGet("indices",u)}) - ${a[u]};
                if (k < 0)  {
                  k += ${t[u]};
                }
                if (k >= ${t[u]}) {
                  k -= ${t[u]};
                }
                offset += k * ${r[u]};
            `;return`
              var offset = 0;
              var k = 0;
              ${o}
              value = x[offset];
          `},rp=(e,t,r,a,n)=>{switch(a.mode){case 0:return Xc(e,t,r,a.pads,n,a.value);case 1:return Jc(e,t,r,a.pads);case 2:return ep(e,t,r,a.pads);case 3:return tp(e,t,r,a.pads);default:throw new Error("Invalid mode")}},np=(e,t,r,a)=>{let n=t[0].dims,o=D.padShape(n.slice(),r.pads),u=D.size(o),l=D.computeStrides(n),i=Y("output",t[0].dataType,o),c=V("x",t[0].dataType,n),f=rp(i,n,l,r,a);return`
              ${e.declareVariables(c,i)}
              ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}

              let indices = ${i.offsetToIndices("global_idx")};

              var value = ${a}(0);
              ${f}
              output[global_idx] = value;
          }`},ap=(e,t)=>{let r=D.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(D.size(r)/64)}}),getShaderSource:a=>np(a,e,t,"f32")}},ip=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),a=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,n=e[0].dims.length,o=new Int32Array(2*n).fill(0);if(e.length>=4){let l=e[3].getBigInt64Array();for(let i=0;i<l.length;i++)o[Number(l[i])]=Number(r[i]),o[Number(l[i])+n]=Number(r[i+l.length])}else r.forEach((l,i)=>o[Number(i)]=Number(l));let u=[];return o.forEach(l=>u.push(l)),ee({mode:t.mode,value:a,pads:u})}else return t},vu=(e,t)=>{Qc(e.inputs);let r=ip(e.inputs,t);e.compute(ap(e.inputs,r),{inputs:[0]})},$u=e=>{let t=e.mode,r=e.value,a=e.pads;return ee({mode:t,value:r,pads:a})}});var vn,xu,_u,Cu,Iu,Au,Eu,Tu,Ou,ku,Ru,Pu,Bu,Mu,zu,Du,Wu=q(()=>{"use strict";ct();$e();Re();be();vn=e=>{if(Ee.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error("Pool ops requires 1 input.")},xu=(e,t,r)=>{let a=t.format==="NHWC",n=e.dims.slice();a&&n.splice(1,0,n.pop());let o=Object.hasOwnProperty.call(t,"dilations"),u=t.kernelShape.slice(),l=t.strides.slice(),i=o?t.dilations.slice():[],c=t.pads.slice();Ht.adjustPoolAttributes(r,n,u,l,i,c);let f=Ht.computePoolOutputShape(r,n,l,i,u,c,t.autoPad),g=Object.assign({},t);o?Object.assign(g,{kernelShape:u,strides:l,pads:c,dilations:i,cacheKey:t.cacheKey}):Object.assign(g,{kernelShape:u,strides:l,pads:c,cacheKey:t.cacheKey});let m=f.slice();return m.push(m.splice(1,1)[0]),[g,a?m:f]},_u=(e,t)=>{let r=t.format==="NHWC",a=D.size(e),n=D.size(t.kernelShape),o=[{type:"uint32",data:a},{type:"uint32",data:n}],u=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let l=t.kernelShape[t.kernelShape.length-1],i=t.strides[t.strides.length-1],c=t.pads[t.pads.length/2-1],f=t.pads[t.pads.length-1],g=!!(c+f);o.push({type:"uint32",data:l},{type:"uint32",data:i},{type:"uint32",data:c},{type:"uint32",data:f}),u.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let m=!1;if(t.kernelShape.length===2){let w=t.kernelShape[t.kernelShape.length-2],b=t.strides[t.strides.length-2],$=t.pads[t.pads.length/2-2],I=t.pads[t.pads.length-2];m=!!($+I),o.push({type:"uint32",data:w},{type:"uint32",data:b},{type:"uint32",data:$},{type:"uint32",data:I}),u.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[o,u,!0,g,m]}else{if(r)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let l=D.computeStrides(t.kernelShape);o.push({type:"uint32",data:l},{type:"uint32",data:t.pads},{type:"uint32",data:t.strides}),u.push({name:"kernelStrides",type:"u32",length:l.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let i=t.pads.reduce((c,f)=>c+f);return[o,u,!!i,!1,!1]}},Cu=(e,t,r,a,n,o,u,l,i,c,f,g)=>{let m=n.format==="NHWC",w=t.type.value,b=Y("output",t.type.tensor,a);if(n.kernelShape.length<=2){let $="",I="",S="",_=r-(m?2:1);if(f===!0?$=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${_}] < 0 || xIndices[${_}]
                      >= uniforms.x_shape[${_}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${o}
                }`:$=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${o}
                }`,n.kernelShape.length===2){let A=r-(m?3:2);g===!0?I=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${A}] = indices[${A}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${A}] < 0 || xIndices[${A}] >= uniforms.x_shape[${A}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:I=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${A}] = indices[${A}] * uniforms.sh - uniforms.phStart + j;
                `,S=`
              }
            `}return`
            ${e.registerUniforms(i).declareVariables(t,b)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${b.offsetToIndices("global_idx")};
              var xIndices = ${b.offsetToIndices("global_idx")};

              var value = ${w}(${l});
              var pad = 0;
              ${I}
              ${$}
              ${S}
              ${u}

              output[global_idx] = value;
            }`}else{if(m)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let $=n.kernelShape.length,I=n.pads.length,S="";return c?S=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${t.indicesToOffset("xIndices")}];
                ${o}
              }`:S=`
              }
              let x_val = x[${t.indicesToOffset("xIndices")}];
              ${o}
            `,`
            ${e.registerUniforms(i).declareVariables(t,b)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${b.offsetToIndices("global_idx")};
              var xIndices = ${b.offsetToIndices("global_idx")};

              var offsets: array<u32, ${$}>;

              var value = ${w}(${l});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${$-1}u; j++) {
                  offsets[j] = offset / ${Ae("uniforms.kernelStrides","j",$)};
                  offset -= offsets[j] * ${Ae("uniforms.kernelStrides","j",$)};
                }
                offsets[${$-1}] = offset;

                isPad = false;
                for (var j = ${r-$}u; j < ${r}u; j++) {
                  xIndices[j] = indices[j] * ${Ae("uniforms.strides",`j - ${r-$}u`,$)}
                    + offsets[j - ${r-$}u] - ${Ae("uniforms.pads","j - 2u",I)};
                  ${S}
              }
              ${u}

              output[global_idx] = value;
            }`}},Iu=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Au=(e,t,r,a)=>{let[n,o]=xu(t,a,r),u=V("x",t.dataType,t.dims.length),l=u.type.value,i="value += x_val;",c="";n.countIncludePad?c+=`value /= ${l}(uniforms.kernelSize);`:c+=`value /= ${l}(i32(uniforms.kernelSize) - pad);`;let[f,g,m,w,b]=_u(o,n);f.push(...K(t.dims)),f.push(...K(o));let $=["rank"];return{name:e,shaderCache:{hint:a.cacheKey+m+w+b+n.countIncludePad,inputDependencies:$},getRunData:()=>({outputs:[{dims:o,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(D.size(o)/64)},programUniforms:f}),getShaderSource:I=>Cu(I,u,t.dims.length,o.length,n,i,c,0,g,m,w,b)}},Eu=e=>{let t=e.count_include_pad!==0,r=Iu(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ee({countIncludePad:t,...r})},Tu=(e,t)=>{vn(e.inputs),e.compute(Au("AveragePool",e.inputs[0],!1,t))},Ou={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},ku=e=>{let t=e.format;return{format:t,...Ou,cacheKey:t}},Ru=(e,t)=>{vn(e.inputs),e.compute(Au("GlobalAveragePool",e.inputs[0],!0,t))},Pu=(e,t,r,a)=>{let[n,o]=xu(t,a,r),u=`
      value = max(x_val, value);
    `,l="",i=V("x",t.dataType,t.dims.length),c=["rank"],[f,g,m,w,b]=_u(o,n);return f.push(...K(t.dims)),f.push(...K(o)),{name:e,shaderCache:{hint:a.cacheKey+m,inputDependencies:c},getRunData:()=>({outputs:[{dims:o,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(D.size(o)/64)},programUniforms:f}),getShaderSource:$=>Cu($,i,t.dims.length,o.length,n,u,l,-1e5,g,m,w,b)}},Bu=(e,t)=>{vn(e.inputs),e.compute(Pu("MaxPool",e.inputs[0],!1,t))},Mu=e=>{let t=e.storage_order,r=e.dilations,a=Iu(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(a.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ee({storageOrder:t,dilations:r,...a})},zu=e=>{let t=e.format;return{format:t,...Ou,cacheKey:t}},Du=(e,t)=>{vn(e.inputs),e.compute(Pu("GlobalMaxPool",e.inputs[0],!0,t))}});var sp,up,Vu,Uu=q(()=>{"use strict";ct();We();be();sp=(e,t,r)=>{let a=e===t,n=e<t&&r<0,o=e>t&&r>0;if(a||n||o)throw new Error("Range these inputs' contents are invalid.")},up=(e,t,r,a)=>{let n=Math.abs(Math.ceil((t-e)/r)),o=[n],u=n,l=Y("output",a,o),i=l.type.storage,c=f=>`
        ${f.declareVariables(l)}
        ${f.mainStart()}
        ${f.guardAgainstOutOfBoundsWorkgroupSizes(u)}
        output[global_idx] = ${i}(${e}) + ${i}(global_idx) * ${i}(${r});
      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(f=>f.toString()).join("_")},getShaderSource:c,getRunData:()=>({outputs:[{dims:o,dataType:a}],dispatchGroup:{x:Math.ceil(u/64)}})}},Vu=e=>{let t=0,r=0,a=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],a=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],a=e.inputs[2].getFloat32Array()[0]),Ee.webgpu.validateInputContent&&sp(t,r,a),e.compute(up(t,r,a,e.inputs[0].dataType),{inputs:[]})}});var lp,dp,cp,pp,fp,mp,hp,gp,yp,bp,wp,vp,$p,Sp,xp,Nu,Hu,Lu=q(()=>{"use strict";$e();Re();be();lp=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},dp=(e,t,r)=>{t.every(n=>n>=0&&n<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let a=new Array(r).fill(1);return t.forEach((n,o)=>a[n]=e[o]),a},cp=(e,t,r,a,n,o)=>{let[u,l,i]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],c=e[0].dims.length;if(u>0&&e.length>u&&e[u].dims.length>0)e[u].getFloat32Array().forEach(f=>o.push(f));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(l>0&&e.length>l&&e[l].dims.length>0){if(e[l].getFloat32Array().forEach(f=>a.push(f)),a.length!==0&&a.length!==c&&r>=18&&a.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");lp(a,t),t.axes.length>0&&dp(a,t.axes,c).forEach((f,g)=>a[g]=f)}if(i>0&&e.length>i&&(e[i].getBigInt64Array().forEach(f=>n.push(Number(f))),n.length!==c||r>=18&&n.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(a.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(n.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof a<"u"&&typeof n<"u"&&a.length>0&&n.length>c)throw new Error("Resize requires only of scales or sizes to be specified")},pp=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: ${t}, xScale: ${t}, lengthResized: ${t},
     lengthOriginal: ${t}, roiStart: ${t}, roiEnd: ${t}) -> ${t} { `+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return`if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * ${t}(lengthOriginal - 1);                   }`;case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`
`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",fp=(e,t,r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",mp=(e,t,r)=>{let a=new Array(r).fill(0).concat(new Array(r).fill(1)),n=e.length===0?a:e.slice();return t.length>0?(t.forEach((o,u)=>{a[o]=n[u],a[u+r]=n[t.length+u]}),a):n},hp=(e,t,r,a)=>{let n=[];if(r.length>0)if(a.length>0){if(e.forEach(o=>n.push(o)),Math.max(...a)>e.length)throw new Error("axes is out of bound");a.forEach((o,u)=>n[o]=r[u])}else r.forEach(o=>n.push(o));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");n=e.map((o,u)=>Math.round(o*t[u]))}return n},gp=(e,t,r)=>{let a=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map(o=>t[o]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map(o=>t[o]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let n=e.slice();return r.axes.length>0?(r.axes.forEach(o=>t[o]=a),r.axes.forEach(o=>n[o]=Math.round(e[o]*t[o]))):(t.fill(a,0,t.length),n.forEach((o,u)=>n[u]=Math.round(o*t[u]))),n},yp=(e,t,r,a,n)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${r.length}> {
      var original_indices: array<${e.type.value}, ${r.length}>;
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var output_index = ${e.type.value}(${e.indicesGet("output_indices","i")});
        var scale = ${Ae("uniforms.scales","i",a)};
        var roi_low = ${Ae("uniforms.roi","i",n)};
        var roi_hi = ${Ae("uniforms.roi",`i + ${t.length}`,n)};
        if (scale == 1.0) {
          original_indices[i] = output_index;
        } else {
          var input_shape_i = ${e.type.value}(${Ae("uniforms.input_shape","i",t.length)});
          var output_shape_i = ${e.type.value}(${Ae("uniforms.output_shape","i",r.length)});
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,bp=(e,t,r,a,n,o,u)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {
      var input_indices: ${e.type.indices};
      for (var i:u32 = 0; i < ${a.length}; i++) {
        var output_index = ${t.type.value}(${t.indicesGet("output_indices","i")});
        var input_index: u32;
        var scale = ${Ae("uniforms.scales","i",n)};
        if (scale == 1.0) {
          input_index = u32(output_index);
        } else {
          var roi_low = ${Ae("uniforms.roi","i",o)};
          var roi_hi = ${Ae("uniforms.roi",`i + ${r.length}`,o)};
          var input_shape_i = ${t.type.value}(${Ae("uniforms.input_shape","i",r.length)});
          var output_shape_i = ${t.type.value}(${Ae("uniforms.output_shape","i",a.length)});
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${u} || (original_idx >= 0 && original_idx < input_shape_i)) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > (input_shape_i - 1)) {
              input_index = u32(input_shape_i) - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${e.indicesSet("input_indices","i"," input_index")}
      }
      return input_indices;
    }`,wp=(e,t)=>`
    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var input_index = ${e.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${Ae("uniforms.input_shape","i",t.length)}) {
          return false;
        }
      }
      return true;
    }`,vp=(e,t,r,a,n,o)=>{let[u,l,i,c]=r.length===2?[-1,0,1,-1]:a[1]===1?[0,2,3,1]:[0,1,2,3],f=e.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${f} {
      var input_indices: ${e.type.indices};
      ${e.indicesSet("input_indices",l,`max(0, min(row, ${r[l]} - 1))`)};
      ${e.indicesSet("input_indices",i,`max(0, min(col, ${r[i]} - 1))`)};
      if (${r.length} > 2) {
        ${e.indicesSet("input_indices",c,"channel")};
        ${e.indicesSet("input_indices",u,"batch")};
      };
      return ${e.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${f} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${f} = originalIndices[${l}];
      var col:${f} = originalIndices[${i}];
      if (${n} && (row < 0 || row > (${r[l]} - 1) || col < 0 || col > ${r[i]} - 1)) {
        return ${o};
      }
      row = max(0, min(row, ${r[l]} - 1));
      col = max(0, min(col, ${r[i]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = 0;
      var batch: u32 = 0;
      if (${r.length>2}) {
        channel = u32(originalIndices[${c}]);
        batch = u32(originalIndices[${u}]);
      }
      var x11: ${f} = getInputValue(batch, channel, row1, col1);
      var x12: ${f} = getInputValue(batch, channel, row1, col2);
      var x21: ${f} = getInputValue(batch, channel, row2, col1);
      var x22: ${f} = getInputValue(batch, channel, row2, col2);
      var dx1: ${f} = row - ${f}(row1);
      var dx2: ${f} = ${f}(row2) - row;
      var dy1 = col - ${f}(col1);
      var dy2 = ${f}(col2) - col;
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},$p=(e,t,r,a,n,o,u,l,i,c)=>{let[f,g]=r.length===2?[0,1]:n[1]===1?[2,3]:[1,2],m=e.type.value,w=b=>{let $=b===f?"row":"col";return`
      fn ${$}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${m} {
        var output_index = ${t.indicesGet("output_indices",b)};
        var originalIdx: ${m} = getOriginalCoordinateFromResizedCoordinate(${m}(output_index), ${n[b]},
        ${m}(${a[b]}), ${m}(${r[b]}), ${o[b]}, ${o[b]} + ${r.length});
        var fractOriginalIdx: ${m} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${l} && (originalIdx < 0 || originalIdx > (${r[b]} - 1))) {
          return ${i};
        }
        var data: array<${m}, 4> = array<${m}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${$}: ${m} = originalIdx + ${m}(i);
          if (${$} < 0 || ${$} >= ${r[b]}) {
            if (${c}) {
              coefs[i + 1] = 0.0;
              continue;
            } else if (${l}) {
              return ${i};
            } else {
              ${$} = max(0, min(${$}, ${r[b]} - 1));
            }
          }
          var input_indices_copy: ${e.type.indices} = input_indices;
          ${e.indicesSet("input_indices_copy",b,`u32(${$})`)};
          data[i + 1] = ${b===f?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${w(f)};
    ${w(g)};
  fn getCubicInterpolationCoefs(s: ${m}) -> array<${m}, 4> {
    var absS = abs(s);
    var coeffs: array<${m}, 4> = array<${m}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${m} = 1.0 - absS;
    var twoMinusAbsS: ${m} = 2.0 - absS;
    var onePlusAbsS: ${m} = 1.0 + absS;
    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};
    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;
    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${m}, 4>, coefs: array<${m}, 4>) -> ${m} {
    var coefsSum: ${m} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${m} {
    var input_indices: ${e.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},Sp=(e,t,r,a,n,o)=>{let u=e.dims,l=mp(o,t.axes,u.length),i=hp(u,a,n,t.axes),c=a.slice();a.length===0&&(c=u.map((S,_)=>S===0?1:i[_]/S),t.keepAspectRatioPolicy!=="stretch"&&(i=gp(u,c,t)));let f=Y("output",e.dataType,i.length),g=V("input",e.dataType,u.length),m=D.size(i),w=u.length===i.length&&u.every((S,_)=>S===i[_]),b=t.coordinateTransformMode==="tf_crop_and_resize",$=g.type.value,I=S=>`
      ${w?"":`
      ${pp(t.coordinateTransformMode,$)};
      ${(()=>{switch(t.mode){case"nearest":return`
              ${wp(g,u)};
              ${fp(t.nearestMode,r,$)};
              ${bp(g,f,u,i,c.length,l.length,b)};
              `;case"linear":return`
              ${yp(f,u,i,c.length,l.length)};
              ${vp(g,f,u,c,b,t.extrapolationValue)};
              `;case"cubic":return`
            ${$p(g,f,u,i,c,l,t.cubicCoeffA,b,t.extrapolationValue,t.excludeOutside)};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${S.registerUniform("output_size","u32").registerUniform("scales","f32",c.length).registerUniform("roi","f32",l.length).declareVariables(g,f)}
      ${S.mainStart()}
        ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${w?"output[global_idx] = input[global_idx];":`
        let output_indices = ${f.offsetToIndices("global_idx")};
        var input_indices: ${g.type.indices};
        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${g.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${t.extrapolationValue};
                }`;case"linear":return"output[global_idx] = bilinearInterpolation(output_indices);";case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};
        `}
      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${c.length>0?c:""}|${n.length>0?n:""}|${l.length>0?l:""}|${w}`,inputDependencies:["rank"]},getShaderSource:I,getRunData:()=>({outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:[{type:"uint32",data:m},{type:"float32",data:c},{type:"float32",data:l},...K(u),...K(i)]})}},xp=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Nu=(e,t)=>{let r=[],a=[],n=[],o=xp(e);cp(e.inputs,t,o,r,a,n),e.compute(Sp(e.inputs[0],t,o,r,a,n),{inputs:[0]})},Hu=e=>{let t=e.antialias,r=e.axes,a=e.coordinateTransformMode,n=e.cubicCoeffA,o=e.excludeOutside!==0,u=e.extrapolationValue,l=e.keepAspectRatioPolicy,i=e.mode,c=e.nearestMode===""?"simple":e.nearestMode;return ee({antialias:t,axes:r,coordinateTransformMode:a,cubicCoeffA:n,excludeOutside:o,extrapolationValue:u,keepAspectRatioPolicy:l,mode:i,nearestMode:c})}});var _p,Cp,Gu,Fu,qu=q(()=>{"use strict";We();$e();Re();be();_p=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],a=e[2];if(t.dataType!==r.dataType||t.dataType!==a.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let n=t.dims[t.dims.length-1],o=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==n)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==o)throw new Error("Skip must have the same sequence length as input");if(a.dims.length!==1)throw new Error("Gamma must be 1D");if(a.dims[a.dims.length-1]!==n)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let u=e[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let u=e[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Bias must have the same hidden size as input")}},Cp=(e,t,r,a)=>{let n=e[0].dims,o=D.size(n),u=n,l=o,i=n.slice(-1)[0],c=a?n.slice(0,-1).concat(1):[],f=e.length>3,g=e.length>4,m=a&&r>1,w=a&&r>2,b=r>3,$=Ve(i),I=[V("x",e[0].dataType,e[0].dims,$),V("skip",e[1].dataType,e[1].dims,$),V("gamma",e[2].dataType,e[2].dims,$)];f&&I.push(V("beta",e[3].dataType,e[3].dims,$)),g&&I.push(V("bias",e[4].dataType,e[4].dims,$)),I.push(Y("output",e[0].dataType,u,$)),m&&I.push(Y("meanOutput",1,c)),w&&I.push(Y("invStdOutput",1,c)),b&&I.push(Y("inputSkipBiasSum",e[0].dataType,u,$));let S=ke(e[0].dataType),_=A=>`
      const hiddenSize: f32 = ${i};
      const hiddenSizeVectorized: u32 = ${i/$};
      const epsilon: f32 = ${t.epsilon};

      ${A.declareVariables(...I)}

      ${A.mainStart()}
        ${A.guardAgainstOutOfBoundsWorkgroupSizes(l/i)}
        let offset = global_idx * hiddenSizeVectorized;
        var sum = ${Ye("f32",$)};
        var squareSum = ${Ye("f32",$)};
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          let skipValue = skip[offset + i];
          let biasValue = ${g?"bias[i]":"0.0"};
          let inputValue = x[offset + i];
          let value = inputValue + skipValue + biasValue;
          ${b?"inputSkipBiasSum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32Value = ${ot(S,$,"value")};
          sum += f32Value;
          squareSum += f32Value * f32Value;
        }
        let mean = ${et("sum",$)} / hiddenSize;
        let variance = sqrt(${et("squareSum",$)} / hiddenSize - mean * mean + epsilon);
        ${m?"meanOutput[global_idx] = mean;":""}
        ${w?"invStdOutput[global_idx] = 1.0 / variance;":""}
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          output[offset + i] = (output[offset + i] - ${S}(mean)) / ${S}(variance) * gamma[i]
           + ${f?"beta[i]":"0.0"};
        }
      }`,k=[{dims:u,dataType:e[0].dataType}];return r>1&&k.push({dims:c,dataType:1}),r>2&&k.push({dims:c,dataType:1}),r>3&&k.push({dims:n,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:_,getRunData:()=>({outputs:k,dispatchGroup:{x:Math.ceil(l/i/64)}})}},Gu=(e,t)=>{_p(e.inputs);let a=[0];e.outputCount>1&&a.push(-3),e.outputCount>2&&a.push(-3),e.outputCount>3&&a.push(3),e.compute(Cp(e.inputs,t,e.outputCount,!1),{outputs:a})},Fu=e=>{let t=e.epsilon;return ee({epsilon:t})}});var Ip,$n,Ap,ju,Ep,Tp,Ku,Yu,Zu=q(()=>{"use strict";We();$e();Re();be();Ip=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,a)=>{if(e[a+1].dataType!==6&&e[a+1].dataType!==7)throw new Error(`Input ${a} must be an array of int32 or int64`)})},$n=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(a=>r.push(Number(a)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(a=>r.push(Number(a)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Ap=(e,t)=>{if(e.length>1){let r=$n(e,1),a=$n(e,2),n=$n(e,3);return n.length===0&&(n=[...Array(e[0].dims.length).keys()]),ee({starts:r,ends:a,axes:n})}else return t},ju=(e,t,r,a,n)=>{let o=e;return e<0&&(o+=r[a[t]]),n[t]<0?Math.max(0,Math.min(o,r[a[t]]-1)):Math.max(0,Math.min(o,r[a[t]]))},Ep=(e,t,r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {
          var input_indices: ${e.type.indices};
          var carry = 0u;
          for (var i = ${r.length}; i >= 0; i--) {
            let input_shape_i = ${Ae("uniforms.input_shape","i",r.length)};
            let steps_i = ${Ae("uniforms.steps","i",r.length)};
            let signs_i = ${Ae("uniforms.signs","i",r.length)};
            let starts_i = ${Ae("uniforms.starts","i",r.length)};
            var output_index = ${t.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${e.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,Tp=(e,t)=>{let r=e[0].dims,a=D.size(r),n=t.axes.length>0?D.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],o=$n(e,4);o.forEach(S=>S!==0||(()=>{throw new Error("step cannot be 0")})),o.length===0&&(o=Array(n.length).fill(1));let u=t.starts.map((S,_)=>ju(S,_,r,n,o)),l=t.ends.map((S,_)=>ju(S,_,r,n,o));if(n.length!==u.length||n.length!==l.length)throw new Error("start, ends and axes should have the same number of elements");if(n.length!==r.length)for(let S=0;S<r.length;++S)n.includes(S)||(u.splice(S,0,0),l.splice(S,0,r[S]),o.splice(S,0,1));let i=o.map(S=>Math.sign(S));o.forEach((S,_,k)=>{if(S<0){let A=(l[_]-u[_])/S,z=u[_],E=z+A*o[_];u[_]=E,l[_]=z,k[_]=-S}});let c=r.slice(0);n.forEach((S,_)=>{c[S]=Math.ceil((l[S]-u[S])/o[S])});let f={dims:c,dataType:e[0].dataType},g=Y("output",e[0].dataType,c.length),m=V("input",e[0].dataType,e[0].dims.length),w=D.size(c),b=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:u.length},{name:"signs",type:"i32",length:i.length},{name:"steps",type:"u32",length:o.length}],$=[{type:"uint32",data:w},{type:"uint32",data:u},{type:"int32",data:i},{type:"uint32",data:o},...K(e[0].dims),...K(c)],I=S=>`
      ${S.registerUniforms(b).declareVariables(m,g)}
        ${Ep(m,g,r)}
        ${S.mainStart()}
          ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${g.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${g.setByOffset("global_idx",m.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${i.length}_${u.length}_${o.length}`,inputDependencies:["rank"]},getShaderSource:I,getRunData:()=>({outputs:[f],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:$})}},Ku=(e,t)=>{Ip(e.inputs,t);let r=Ap(e.inputs,t);e.compute(Tp(e.inputs,r),{inputs:[0]})},Yu=e=>{let t=e.starts,r=e.ends,a=e.axes;return ee({starts:t,ends:r,axes:a})}});var Op,kp,Qu,Xu,Ju=q(()=>{"use strict";$e();Re();be();Op=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},kp=(e,t)=>{let r=e.dims,a=D.size(r),n=64,o=t.axis;if(o<0&&(o=r.length+o),o<r.length-1)throw new Error("softmax only supports last axis for now.");let u=r[o],l=a/u,i=Ve(u),c=u/i,f=(I,S)=>S===4?`max(max(${I}.x, ${I}.y), max(${I}.z, ${I}.w))`:S===2?`max(${I}.x, ${I}.y)`:S===3?`max(max(${I}.x, ${I}.y), ${I}.z)`:I,g=V("x",e.dataType,e.dims,i),m=Y("result",e.dataType,e.dims,i),w=g.type.value,b=ke(e.dataType)==="f32"?`var threadMax = ${w}(-3.402823e+38f);`:`var threadMax = ${w}(-65504.0h);`,$=I=>`
      var<workgroup> rowMaxShared : ${w};
      var<workgroup> rowSumShared : ${w};
      var<workgroup> threadShared : array<${w}, ${n}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${w} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${w}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${I.registerUniform("packedCols","i32").declareVariables(g,m)}
      ${I.mainStart()}
        let gindex = i32(global_id.x);
        let lindex = i32(local_id.x);
        const wg = ${n};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${b}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${w}(${f("threadShared[0]",i)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${w}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${w}(${et("threadShared[0]",i)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;return{name:"Softmax",shaderCache:{hint:`${i}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:l},programUniforms:[{type:"uint32",data:c}]}),getShaderSource:$}},Qu=(e,t)=>{Op(e.inputs),e.compute(kp(e.inputs[0],t))},Xu=e=>ee({axis:e.axis})});var Rp,Pp,Bp,Mp,zp,el,tl,rl=q(()=>{"use strict";$e();Re();be();Rp=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Pp=(e,t)=>{let r=[],a=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),a=r.length),ee({numOutputs:a,axis:t.axis,splitSizes:r})},Bp=e=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
    if (index < ${Ae("uniforms.size_in_split_axis","i",e)}) {
        return i;
    }
    }
    return ${e}u;
}`,Mp=e=>{let t=e.length,r=[];for(let a=0;a<t;++a){let n=e[a].setByIndices("indices","input[global_idx]");t===1?r.push(n):a===0?r.push(`if (output_number == ${a}u) { ${n} }`):a===t-1?r.push(`else { ${n} }`):r.push(`else if (output_number == ${a}) { ${n} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {
        ${r.join(`
`)}
      }`},zp=(e,t)=>{let r=e[0].dims,a=D.size(r),n=e[0].dataType,o=D.normalizeAxis(t.axis,r.length),u=new Array(t.numOutputs),l=V("input",n,r),i=new Array(t.numOutputs),c=[],f=[],g=0,m=[{type:"uint32",data:a}];for(let b=0;b<t.numOutputs;b++){g+=t.splitSizes[b],i[b]=g;let $=r.slice();$[t.axis]=t.splitSizes[b],f.push($),u[b]=Y(`output${b}`,n,$),c.push({dims:f[b],dataType:e[0].dataType})}m.push({type:"uint32",data:i}),m.push(...K(r)),f.forEach(b=>m.push(...K(b)));let w=b=>`
  ${b.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",i.length).declareVariables(l,...u)}
  ${Bp(i.length)}
  ${Mp(u)}

  ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${l.offsetToIndices("global_idx")};
    var index = ${l.indicesGet("indices",o)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${Ae("uniforms.size_in_split_axis","output_number - 1u",i.length)};
      ${l.indicesSet("indices",o,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:w,getRunData:()=>({outputs:c,dispatchGroup:{x:Math.ceil(a/64)},programUniforms:m})}},el=(e,t)=>{Rp(e.inputs);let r=e.inputs.length===1?t:Pp(e.inputs,t);e.compute(zp(e.inputs,r),{inputs:[0]})},tl=e=>{let t=e.axis,r=e.splitSizes,a=e.numOutputs<0?r.length:e.numOutputs;if(a!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ee({axis:t,numOutputs:a,splitSizes:r})}});var nl,Dp,Wp,Vp,al,il=q(()=>{"use strict";We();$e();be();nl=e=>Array.from(e.getBigInt64Array(),Number),Dp=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(nl(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Wp=(e,t)=>{let r=[];for(let a=0;a<e.length;++a)r.push(e[a]*t[a]);return r},Vp=e=>{let t=e[0].dims,r=nl(e[1]),a=Wp(t,r),n=D.size(a),o=e[0].dataType,u=V("input",o,t.length),l=Y("output",o,a.length),i=c=>`
      const inputShape = ${u.indices(...t)};
      ${c.registerUniform("output_size","u32").declareVariables(u,l)}
      ${c.mainStart()}
      ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${l.offsetToIndices("global_idx")};
      var input_indices: ${u.type.indices};
      for (var i = 0; i < ${t.length}; i++) {
        let input_dim_i = ${u.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${l.indicesGet("output_indices","i")}  % input_dim_i;

        ${u.indicesSet("input_indices","i","input_dim_value")}
      }
      ${l.setByOffset("global_idx",u.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:[{type:"uint32",data:n},...K(e[0].dims),...K(a)]}),getShaderSource:i}},al=e=>{Dp(e.inputs),e.compute(Vp(e.inputs),{inputs:[0]})}});var Up,Np,ol,sl=q(()=>{"use strict";We();$e();be();Up=(e,t,r,a,n)=>{let o=Y("output_data",n,r.length,4),u=V("a_data",t[1].dataType,t[1].dims.length,4),l=V("b_data",t[2].dataType,t[2].dims.length,4),i=V("c_data",t[0].dataType,t[0].dims.length,4),c,f=(g,m,w)=>`select(${m}, ${g}, ${w})`;if(!a)c=o.setByOffset("global_idx",f(u.getByOffset("global_idx"),l.getByOffset("global_idx"),i.getByOffset("global_idx")));else{let g=(m,w,b="")=>{let $=`a_data[index_a${w}][component_a${w}]`,I=`b_data[index_b${w}][component_b${w}]`,S=`bool(c_data[index_c${w}] & ${4278190080>>>(3-w)*8}u)`;return`
            let output_indices${w} = ${o.offsetToIndices(`global_idx * 4u + ${w}u`)};
            let offset_a${w} = ${u.broadcastedIndicesToOffset(`output_indices${w}`,o)};
            let offset_b${w} = ${l.broadcastedIndicesToOffset(`output_indices${w}`,o)};
            let offset_c${w} = ${i.broadcastedIndicesToOffset(`output_indices${w}`,o)};
            let index_a${w} = offset_a${w} / 4u;
            let index_b${w} = offset_b${w} / 4u;
            let index_c${w} = offset_c${w} / 4u;
            let component_a${w} = offset_a${w} % 4u;
            let component_b${w} = offset_b${w} % 4u;
            ${m}[${w}] = ${b}(${f($,I,S)});
          `};n===9?c=`
            var data = vec4<u32>(0);
            ${g("data",0,"u32")}
            ${g("data",1,"u32")}
            ${g("data",2,"u32")}
            ${g("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:c=`
            ${g("output_data[global_idx]",0)}
            ${g("output_data[global_idx]",1)}
            ${g("output_data[global_idx]",2)}
            ${g("output_data[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(i,u,l,o)}
        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${c}
      }`},Np=e=>{let t=e[1].dims,r=e[2].dims,a=e[0].dims,n=e[1].dataType,o=!(D.areEqual(t,r)&&D.areEqual(r,a)),u=t,l=D.size(t),i=Math.ceil(l/4);if(o){let c=pt.calcShape(pt.calcShape(t,r,!1),a,!1);if(!c)throw new Error("Can't perform where op on the given tensors");u=c,l=D.size(u)}return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:c=>Up(c,e,u,o,n),getRunData:()=>({outputs:[{dims:u,dataType:n}],dispatchGroup:{x:Math.ceil(l/64/4)},programUniforms:[{type:"uint32",data:i},...K(a),...K(t),...K(r),...K(u)]})}},ol=e=>{e.compute(Np(e.inputs))}});var ul,ll=q(()=>{"use strict";Oo();aa();Bo();zo();hs();Is();Ts();ua();Ls();qs();Qs();eu();nu();ou();lu();pu();hu();da();wu();Su();Wu();Uu();un();Lu();qu();Zu();Ju();rl();il();Jt();ia();sl();ul=new Map([["Abs",[Do]],["Acos",[Wo]],["Acosh",[Vo]],["Add",[gs]],["ArgMax",[To,na]],["ArgMin",[Eo,na]],["Asin",[Uo]],["Asinh",[No]],["Atan",[Ho]],["Atanh",[Lo]],["Attention",[Ro,ko]],["AveragePool",[Tu,Eu]],["BatchNormalization",[Po]],["BiasAdd",[Mo]],["BiasSplitGelu",[ms]],["Cast",[Fo,Go]],["Ceil",[jo]],["Clip",[qo]],["Concat",[As,Es]],["Conv",[fa,pa]],["ConvTranspose",[Hs,Ns]],["Cos",[Ko]],["Cosh",[Yo]],["CumSum",[Gs,Fs]],["Div",[ys]],["Einsum",[Ys,Zs]],["Elu",[Zo,cn]],["Equal",[bs]],["Erf",[Qo]],["Exp",[Xo]],["Expand",[Js]],["Floor",[Jo]],["FusedConv",[fa,pa]],["Gather",[ru,tu]],["GatherElements",[iu,au]],["Gelu",[es]],["Gemm",[su,uu]],["GlobalAveragePool",[Ru,ku]],["GlobalMaxPool",[Du,zu]],["Greater",[Ss]],["GreaterOrEqual",[_s]],["InstanceNormalization",[cu,du]],["LayerNormalization",[mu,fu]],["LeakyRelu",[ts,cn]],["Less",[xs]],["LessOrEqual",[Cs]],["Log",[fs]],["MatMul",[Ms]],["MaxPool",[Bu,Mu]],["Mul",[ws]],["MultiHeadAttention",[bu,yu]],["Neg",[ns]],["Not",[rs]],["Pad",[vu,$u]],["Pow",[vs]],["Range",[Vu]],["Reciprocal",[as]],["ReduceMin",[So]],["ReduceMean",[yo]],["ReduceMax",[$o]],["ReduceSum",[_o]],["ReduceProd",[xo]],["ReduceL1",[bo]],["ReduceL2",[wo]],["ReduceLogSum",[Io]],["ReduceLogSumExp",[vo]],["ReduceSumSquare",[Co]],["Relu",[is]],["Resize",[Nu,Hu]],["Sigmoid",[os]],["Sin",[ss]],["Sinh",[us]],["Slice",[Ku,Yu]],["SkipLayerNormalization",[Gu,Fu]],["Split",[el,tl]],["Sqrt",[ls]],["Softmax",[Qu,Xu]],["Sub",[$s]],["Tan",[ds]],["Tanh",[cs]],["ThresholdedRelu",[ps,cn]],["Tile",[al]],["Transpose",[no,ao]],["Where",[ol]]])});var Sn,dl=q(()=>{"use strict";We();Et();be();Sn=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,a,n,o,u,l){let i=this.backend.device,c=this.backend.getComputePassEncoder();c.setPipeline(t.computePipeline);let f=[];for(let m of n)f.push({binding:f.length,resource:{buffer:m.buffer}});for(let m of o)f.push({binding:f.length,resource:{buffer:m.buffer}});l&&f.push({binding:f.length,resource:l});let g=i.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:f,label:t.programInfo.name});if(c.setBindGroup(0,g),c.dispatchWorkgroups(...u),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let m=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,m.buffer,0,this.backend.querySetCount*8),this.backend.flush();let w=this.backend.currentKernelId,b=this.backend.kernels.get(w);m.buffer.mapAsync(GPUMapMode.READ).then(()=>{let $=new BigUint64Array(m.buffer.getMappedRange()),[I,S]=$,[_,k]=b;m.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=I);let A=Number(I-this.backend.queryTimeBase),z=Number(S-this.backend.queryTimeBase);if(!Number.isSafeInteger(A)||!Number.isSafeInteger(z))throw new RangeError("incorrect timestamp range");if(this.backend.gpuDataManager.release(m.id),this.backend.env.webgpu.profiling?.ondata)this.backend.env.webgpu.profiling.ondata({version:1,inputsMetadata:r.map(E=>({dims:E.dims,dataType:Nt(E.dataType)})),outputsMetadata:a.map(E=>({dims:E.dims,dataType:Nt(E.dataType)})),kernelId:w,kernelType:_,kernelName:k,startTime:A,endTime:z});else{let E="";r.forEach((W,L)=>{E+=`input[${L}]: [${W.dims}] | ${Nt(W.dataType)}, `});let U="";a.forEach((W,L)=>{U+=`output[${L}]: [${W.dims}] | ${Nt(W.dataType)}, `}),console.log(`[profiling] kernel "${w}|${k}|${t.programInfo.name}" ${E}${U}execution time: ${z-A} ns`)}})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(t,r){let a=this.backend.device,n=[];a.features.has("shader-f16")&&n.push("enable f16;");let o=to(r),u=t.getShaderSource(o),l=`${n.join(`
`)}
${o.additionalImplementations}
${u}`,i=a.createShaderModule({code:l,label:t.name});Be("verbose",()=>`[WebGPU] ${t.name} shader code: ${l}`);let c=a.createComputePipeline({compute:{module:i,entryPoint:"main"},layout:"auto",label:t.name});return{programInfo:t,computePipeline:c}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,a=typeof t=="number"?1:t.y||1,n=typeof t=="number"?1:t.z||1,o=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=o&&a<=o&&n<=o)return[r,a,n];let u=r*a*n,l=Math.ceil(Math.sqrt(u));if(l>o){if(l=Math.ceil(Math.cbrt(u)),l>o)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[l,l,l]}else return[l,l,1]}}});var Hp,Lp,xn,cl=q(()=>{"use strict";Et();Zi();eo();ll();dl();Hp=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let a=0;a<e.length;++a){let n=e[a].dataType;switch(t[a]){case"none":{r.push("");break}case"type":{r.push(`${n}`);break}case"rank":{let o=e[a].dims.length;r.push(`${n};${o}`);break}case"dims":{let o=e[a].dims.join(",");r.push(`${n};${o}`);break}default:throw new Error(`unsupported input dependency: ${t[a]}`)}}return r.join("|")},Lp=(e,t,r)=>{let a=e.name;return e.shaderCache?.hint&&(a+="["+e.shaderCache.hint+"]"),a+=":"+r+`:${Hp(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,a},xn=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let a=[],n={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:a};r.features.has("timestamp-query")&&a.push("timestamp-query"),r.features.has("shader-f16")&&a.push("shader-f16"),this.device=await r.requestDevice(n),this.gpuDataManager=Ji(this),this.programManager=new Sn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Ki(t.logLevel,!!t.debug),this.device.onuncapturederror=o=>{o.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${o.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return this.device.features.has("timestamp-query")&&(this.env.webgpu.profiling?.mode==="default"||!this.env.webgpu.profiling?.mode&&this.env.webgpu.profilingMode==="default")}run(t,r,a,n,o){let u=[];for(let _=0;_<r.length;++_){let k=this.gpuDataManager.get(r[_].data);if(!k)throw new Error(`no GPU data for input: ${r[_].data}`);u[_]=k}let{outputs:l,dispatchGroup:i,programUniforms:c}=t.getRunData(r),f=a.length===0?l.map((_,k)=>k):a;if(f.length!==l.length)throw new Error(`Output size ${f.length} must be equal to ${l.length}.`);let g=[],m=[];for(let _=0;_<l.length;++_){if(!Number.isInteger(f[_])||f[_]<-3||f[_]>=l.length)throw new Error(`Invalid output index: ${f[_]}`);if(f[_]===-3)continue;let k=f[_]===-1,A=f[_]===-2,z=k||A?o(l[_].dataType,l[_].dims):n(f[_],l[_].dataType,l[_].dims),E=this.gpuDataManager.get(z.data);if(!E)throw new Error(`no GPU data for output: ${z.data}`);if(k&&this.temporaryData.push(E),A){let U=this.kernelPersistentData.get(this.currentKernelId);U||(U=[],this.kernelPersistentData.set(this.currentKernelId,U)),U.push(E)}g.push(z),m.push(E)}let w;if(c){let _=0,k=[];c.forEach(U=>{let W=typeof U.data=="number"?[U.data]:U.data;if(W.length===0)return;let L=W.length<=2?W.length*4:16;_=Math.ceil(_/L)*L,k.push(_),_+=W.length>4?Math.ceil(W.length/4)*16:W.length*4});let A=16;_=Math.ceil(_/A)*A;let z=new ArrayBuffer(_);c.forEach((U,W)=>{let L=k[W],X=typeof U.data=="number"?[U.data]:U.data;U.type==="int32"?new Int32Array(z,L,X.length).set(X):U.type==="uint32"?new Uint32Array(z,L,X.length).set(X):new Float32Array(z,L,X.length).set(X)});let E=this.gpuDataManager.create(_,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(E.buffer,0,z,0,_),this.gpuDataManager.release(E.id),w={offset:0,size:_,buffer:E.buffer}}let b=this.programManager.normalizeDispatchGroupSize(i),$=b[1]===1&&b[2]===1,I=Lp(t,r,$),S=this.programManager.getArtifact(I);return S||(S=this.programManager.build(t,b),this.programManager.setArtifact(I,S),Be("info",()=>`[artifact] key: ${I}, programName: ${t.name}`)),Be("info",()=>`[ProgramManager] run "${t.name}" (key=${I}) with ${b[0]}x${b[1]}x${b[2]}`),this.programManager.run(S,r,g,u,m,b,w),g}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,a,n){let o=ul.get(t);if(!o)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,n,o[0],[o[1],a]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let a of r)this.gpuDataManager.release(a.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,a){let n=this.kernels.get(t);if(!n)throw new Error(`kernel not created: ${t}`);let[o,u,l,i]=n;if(this.currentKernelId!==null)throw new Error(`kernel "[${o}] ${u}" is not allowed to be called recursively`);this.currentKernelId=t,i[0]&&(i[1]=i[0](i[1]),i[0]=void 0),Be("info",()=>`[WebGPU] Start to run kernel "[${o}] ${u}"...`);let c=this.env.debug;this.temporaryData=[];try{return c&&this.device.pushErrorScope("validation"),l(r,i[1]),0}catch(f){return a.push(Promise.resolve(`[WebGPU] Kernel "[${o}] ${u}" failed. ${f}`)),1}finally{c&&a.push(this.device.popErrorScope().then(f=>f?`GPU validation error for kernel "[${o}] ${u}": ${f.message}`:null));for(let f of this.temporaryData)this.gpuDataManager.release(f.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,a,n){let o=this.sessionExternalDataMapping.get(t);o||(o=new Map,this.sessionExternalDataMapping.set(t,o));let u=o.get(r),l=this.gpuDataManager.registerExternalBuffer(a,n,u?.[1]);return o.set(r,[l,a]),l}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(a=>this.gpuDataManager.unregisterExternalBuffer(a[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,a){return async()=>{let n=await Zn(this,t,r);return Yi(n.buffer,a)}}}});var pl={};Vt(pl,{init:()=>Gp});var _r,wa,Gp,fl=q(()=>{"use strict";We();cl();Et();$e();_r=class e{constructor(t,r,a,n){this.module=t;this.dataType=r;this.data=a;this.dims=n}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=D.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=D.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=D.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(D.size(t)!==D.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},wa=class{constructor(t,r,a){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let n=t.HEAPU32,o=a>>2;this.opKernelContext=n[o++];let u=n[o++];this.outputCount=n[o++],this.customDataOffset=n[o++],this.customDataSize=n[o++];let l=[];for(let i=0;i<u;i++){let c=n[o++],f=n[o++],g=n[o++],m=[];for(let w=0;w<g;w++)m.push(n[o++]);l.push(new _r(t,c,f,m))}this.inputs=l}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let a=r?.inputs?.map(l=>typeof l=="number"?this.inputs[l]:l)??this.inputs,n=r?.outputs??[],o=(l,i,c)=>new _r(this.module,i,this.output(l,c),c),u=(l,i)=>{let c=wr(l);if(!c)throw new Error(`Unsupported data type: ${l}`);let f=c*D.size(i);return new _r(this.module,l,this.backend.gpuDataManager.create(f).id,i)};return this.backend.run(t,a,n,o,u)}output(t,r){let a=this.module.stackSave();try{let n=this.module.stackAlloc((1+r.length)*4),o=n>>2;this.module.HEAPU32[o++]=r.length;for(let u=0;u<r.length;u++)this.module.HEAPU32[o++]=r[u];return this.module._JsepOutput(this.opKernelContext,t,n)}catch(n){throw new Error(`Failed to generate kernel's output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(a)}}},Gp=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let a=new xn;await a.initialize(t),r(a,n=>a.alloc(n),n=>a.free(n),(n,o,u,l=!1)=>{if(l)Be("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${n}, dst=${o}, size=${u}`),a.memcpy(n,o);else{Be("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${n}, gpuDataId=${o}, size=${u}`);let i=e.HEAPU8.subarray(n,n+u);a.upload(o,i)}},async(n,o,u)=>{Be("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${o}, size=${u}`),await a.download(n,()=>e.HEAPU8.subarray(o,o+u))},(n,o,u)=>a.createKernel(n,o,u,t.debug||a.isQueryEnabled()?e.UTF8ToString(e._JsepGetNodeName(o)):`${o}`),n=>a.releaseKernel(n),(n,o,u,l)=>{Be("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${n}, contextDataOffset=${o}`);let i=new wa(e,a,o);return a.computeKernel(n,i,l)})}}});var hl,Fp,qp,gl,Cr,yl,va,$a,bl,wl,ml,vl,$l,Sl,xl=q(()=>{"use strict";Li();Fi();We();Qt();Xr();hl=!1,Fp=e=>{let t=De(),r=t.stackSave();try{let a=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,a,a+4)!==0&&Oe("Can't get session input/output count."),[t.HEAP32[a/4],t.HEAP32[a/4+1]]}finally{t.stackRestore(r)}},qp=(e,t)=>{De()._OrtInit(e,t)!==0&&Oe("Can't initialize onnxruntime.")},gl=async e=>{qp(e.wasm.numThreads,vr(e.logLevel));{let t=(fl(),At(pl)).init;await t(De(),e)}hl=!0},Cr=new Map,yl=()=>hl,va=e=>{let t=De(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},$a=(e,t)=>{let r=De(),a=0,n=0,o=0,u=[],l=[],i=[];try{[n,u]=Gi(t),a=r._OrtCreateSession(e[0],e[1],n),a===0&&Oe("Can't create a session.");let[c,f]=Fp(a),g=[],m=[],w=[];for(let $=0;$<c;$++){let I=r._OrtGetInputName(a,$);I===0&&Oe("Can't get an input name."),l.push(I),g.push(r.UTF8ToString(I))}for(let $=0;$<f;$++){let I=r._OrtGetOutputName(a,$);I===0&&Oe("Can't get an output name."),i.push(I);let S=r.UTF8ToString(I);m.push(S);{let _=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[S]??"cpu";if(_!=="cpu"&&_!=="cpu-pinned"&&_!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${_}.`);w.push(_)}}let b=null;return w.some($=>$==="gpu-buffer")&&(o=r._OrtCreateBinding(a),o===0&&Oe("Can't create IO binding."),b={handle:o,outputPreferredLocations:w,outputPreferredLocationsEncoded:w.map($=>Kn($))}),Cr.set(a,[a,l,i,b]),[a,g,m]}catch(c){throw l.forEach(f=>r._OrtFree(f)),i.forEach(f=>r._OrtFree(f)),o!==0&&r._OrtReleaseBinding(o),a!==0&&r._OrtReleaseSession(a),c}finally{r._free(e[0]),n!==0&&r._OrtReleaseSessionOptions(n),u.forEach(c=>r._free(c))}},bl=(e,t)=>{let r=va(e);return $a(r,t)},wl=e=>{let t=De(),r=Cr.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[a,n,o,u]=r;u&&t._OrtReleaseBinding(u.handle),t.jsepUnregisterBuffers?.(e),n.forEach(l=>t._OrtFree(l)),o.forEach(l=>t._OrtFree(l)),t._OrtReleaseSession(a),Cr.delete(e)},ml=(e,t,r,a,n)=>{if(!e){t.push(0);return}let o=De(),u=e[0],l=e[1],i=e[3],c,f;if(u==="string"&&i==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(i==="gpu-buffer"){let w=e[2].gpuBuffer,b=wr(jn(u));f=l.reduce(($,I)=>$*I,1)*b,c=o.jsepRegisterBuffer(a,n,w,f)}else{let w=e[2];if(Array.isArray(w)){f=4*w.length,c=o._malloc(f),r.push(c);let b=c/4;for(let $=0;$<w.length;$++){if(typeof w[$]!="string")throw new TypeError(`tensor data at index ${$} is not a string`);o.HEAPU32[b++]=Ne(w[$],r)}}else f=w.byteLength,c=o._malloc(f),r.push(c),o.HEAPU8.set(new Uint8Array(w.buffer,w.byteOffset,f),c)}let g=o.stackSave(),m=o.stackAlloc(4*l.length);try{let w=m/4;l.forEach($=>o.HEAP32[w++]=$);let b=o._OrtCreateTensor(jn(u),c,f,m,l.length,Kn(i));b===0&&Oe(`Can't create tensor for input/output. session=${a}, index=${n}.`),t.push(b)}finally{o.stackRestore(g)}},vl=async(e,t,r,a,n,o)=>{let u=De(),l=Cr.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let[i,c,f,g]=l,m=t.length,w=a.length,b=0,$=[],I=[],S=[],_=[],k=u.stackSave(),A=u.stackAlloc(m*4),z=u.stackAlloc(m*4),E=u.stackAlloc(w*4),U=u.stackAlloc(w*4);try{[b,$]=Hi(o);for(let J=0;J<m;J++)ml(r[J],I,_,e,t[J]);for(let J=0;J<w;J++)ml(n[J],S,_,e,m+a[J]);let W=A/4,L=z/4,X=E/4,B=U/4;for(let J=0;J<m;J++)u.HEAPU32[W++]=I[J],u.HEAPU32[L++]=c[t[J]];for(let J=0;J<w;J++)u.HEAPU32[X++]=S[J],u.HEAPU32[B++]=f[a[J]];if(g){let{handle:J,outputPreferredLocations:we,outputPreferredLocationsEncoded:Z}=g;if(c.length!==m)throw new Error(`input count from feeds (${m}) is expected to be always equal to model's input count (${c.length}).`);for(let ye=0;ye<m;ye++){let _e=t[ye];await u._OrtBindInput(J,c[_e],I[ye])!==0&&Oe(`Can't bind input[${ye}] for session=${e}.`)}for(let ye=0;ye<w;ye++){let _e=a[ye];n[ye]?.[3]?u._OrtBindOutput(J,f[_e],S[ye],0)!==0&&Oe(`Can't bind pre-allocated output[${ye}] for session=${e}.`):u._OrtBindOutput(J,f[_e],0,Z[_e])!==0&&Oe(`Can't bind output[${ye}] to ${we[ye]} for session=${e}.`)}}let j;g?j=await u._OrtRunWithBinding(i,g.handle,w,E,b):j=await u._OrtRun(i,z,A,m,U,w,E,b),j!==0&&Oe("failed to call OrtRun().");let pe=[];for(let J=0;J<w;J++){let we=u.HEAPU32[E/4+J];if(we===S[J]){pe.push(n[J]);continue}let Z=u.stackSave(),ye=u.stackAlloc(4*4),_e=!1,me,ce=0;try{u._OrtGetTensorData(we,ye,ye+4,ye+8,ye+12)!==0&&Oe(`Can't access output tensor data on index ${J}.`);let Me=ye/4,Le=u.HEAPU32[Me++];ce=u.HEAPU32[Me++];let G=u.HEAPU32[Me++],ne=u.HEAPU32[Me++],he=[];for(let ze=0;ze<ne;ze++)he.push(u.HEAPU32[G/4+ze]);u._OrtFree(G);let qe=he.reduce((ze,Ge)=>ze*Ge,1);me=Nt(Le);let Je=g?.outputPreferredLocations[a[J]];if(me==="string"){if(Je==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let ze=[],Ge=ce/4;for(let Ze=0;Ze<qe;Ze++){let ut=u.HEAPU32[Ge++],rt=Ze===qe-1?void 0:u.HEAPU32[Ge]-ut;ze.push(u.UTF8ToString(ut,rt))}pe.push([me,he,ze,"cpu"])}else if(Je==="gpu-buffer"&&qe>0){let ze=u.jsepGetBuffer(ce),Ge=wr(Le);if(Ge===void 0||!en(me))throw new Error(`Unsupported data type: ${me}`);_e=!0,pe.push([me,he,{gpuBuffer:ze,download:u.jsepCreateDownloader(ze,qe*Ge,me),dispose:()=>{u._OrtReleaseTensor(we)}},"gpu-buffer"])}else{let ze=Jr(me),Ge=new ze(qe);new Uint8Array(Ge.buffer,Ge.byteOffset,Ge.byteLength).set(u.HEAPU8.subarray(ce,ce+Ge.byteLength)),pe.push([me,he,Ge,"cpu"])}}finally{u.stackRestore(Z),me==="string"&&ce&&u._free(ce),_e||u._OrtReleaseTensor(we)}}return g&&u._OrtClearBoundOutputs(g.handle),pe}finally{u.stackRestore(k),I.forEach(W=>u._OrtReleaseTensor(W)),S.forEach(W=>u._OrtReleaseTensor(W)),_.forEach(W=>u._free(W)),b!==0&&u._OrtReleaseRunOptions(b),$.forEach(W=>u._free(W))}},$l=e=>{let t=De(),r=Cr.get(e);if(!r)throw new Error("invalid session id");let a=r[0],n=t._OrtEndProfiling(a);n===0&&Oe("Can't get an profile file name."),t._OrtFree(n)},Sl=e=>{let t=[];for(let r of e){let a=r[2];!Array.isArray(a)&&"buffer"in a&&t.push(a.buffer)}return t}});var _l=Zt((dw,Kp)=>{Kp.exports='/*!\n * ONNX Runtime Web v1.17.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var fn=Object.defineProperty;var Nu=Object.getOwnPropertyDescriptor;var Hu=Object.getOwnPropertyNames;var Gu=Object.prototype.hasOwnProperty;var Y=(e,t)=>()=>(e&&(t=e(e=0)),t);var ir=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Pr=(e,t)=>{for(var r in t)fn(e,r,{get:t[r],enumerable:!0})},Lu=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Hu(t))!Gu.call(e,n)&&n!==r&&fn(e,n,{get:()=>t[n],enumerable:!(o=Nu(t,n))||o.enumerable});return e};var Wt=e=>Lu(fn({},"__esModule",{value:!0}),e);var hn={};Pr(hn,{readFile:()=>Fu});var Fu,gn=Y(()=>{Fu=void 0});var yn={};Pr(yn,{join:()=>qu});var qu,bn=Y(()=>{qu=void 0});var $o=ir((vo,wn)=>{"use strict";var wo=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,o,n;r.ready=new Promise((l,m)=>{o=l,n=m}),r.jsepInit=(l,m,b,C,O,F,H,de)=>{r.Za=l,r.Oa=m,r.Qa=b,r.Ja=C,r.Pa=O,r.ra=F,r.Ra=H,r.Sa=de,m=(X,ae,te)=>(...ge)=>{let Se=Je,k=ae?.();ge=X(...ge);let se=ae?.();return k!==se&&(X=se,te(k),ae=te=null),Je!=Se?Sr():ge},b=X=>async(...ae)=>{try{if(r.Da)throw Error("Session already started");let te=r.Da={Ta:ae[0],errors:[]},ge=await X(...ae);if(r.Da!==te)throw Error("Session mismatch");l.flush();let Se=te.errors;if(0<Se.length){let k=await Promise.all(Se);if(k=k.filter(se=>se),0<k.length)throw Error(k.join(`\n`))}return ge}finally{r.Da=null}},r._OrtRun=b(m(r._OrtRun,()=>r._OrtRun,X=>r._OrtRun=X)),r._OrtRunWithBinding=b(m(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,X=>r._OrtRunWithBinding=X)),r._OrtBindInput=m(r._OrtBindInput,()=>r._OrtBindInput,X=>r._OrtBindInput=X),r.jsepRegisterBuffer=(X,ae,te,ge)=>l.registerBuffer(X,ae,te,ge),r.jsepUnregisterBuffers=X=>{l.unregisterBuffers(X)},r.jsepGetBuffer=X=>l.getBuffer(X),r.jsepCreateDownloader=(X,ae,te)=>l.createDownloader(X,ae,te)};var s=Object.assign({},r),u="./this.program",d=(l,m)=>{throw m},a=typeof window=="object",p=typeof importScripts=="function",h=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",v="",g,w,y;if(h){var S=(gn(),Wt(hn)),I=(bn(),Wt(yn));v=p?I.dirname(v)+"/":__dirname+"/",g=(l,m)=>(l=l.startsWith("file://")?new URL(l):I.normalize(l),S.readFileSync(l,m?void 0:"utf8")),y=l=>(l=g(l,!0),l.buffer||(l=new Uint8Array(l)),l),w=(l,m,b,C=!0)=>{l=l.startsWith("file://")?new URL(l):I.normalize(l),S.readFile(l,C?void 0:"utf8",(O,F)=>{O?b(O):m(C?F.buffer:F)})},!r.thisProgram&&1<process.argv.length&&(u=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),d=(l,m)=>{throw process.exitCode=l,m},r.inspect=()=>"[Emscripten Module object]"}else(a||p)&&(p?v=self.location.href:typeof document<"u"&&document.currentScript&&(v=document.currentScript.src),e&&(v=e),v.indexOf("blob:")!==0?v=v.substr(0,v.replace(/[?#].*/,"").lastIndexOf("/")+1):v="",g=l=>{var m=new XMLHttpRequest;return m.open("GET",l,!1),m.send(null),m.responseText},p&&(y=l=>{var m=new XMLHttpRequest;return m.open("GET",l,!1),m.responseType="arraybuffer",m.send(null),new Uint8Array(m.response)}),w=(l,m,b)=>{var C=new XMLHttpRequest;C.open("GET",l,!0),C.responseType="arraybuffer",C.onload=()=>{C.status==200||C.status==0&&C.response?m(C.response):b()},C.onerror=b,C.send(null)});var x=r.print||console.log.bind(console),_=r.printErr||console.error.bind(console);Object.assign(r,s),s=null,r.thisProgram&&(u=r.thisProgram),r.quit&&(d=r.quit);var B;r.wasmBinary&&(B=r.wasmBinary);var E=r.noExitRuntime||!0;typeof WebAssembly!="object"&&He("no native wasm support detected");var z,A,U=!1,V,G,Q,R,q,pe,J;function we(){var l=z.buffer;r.HEAP8=G=new Int8Array(l),r.HEAP16=new Int16Array(l),r.HEAP32=R=new Int32Array(l),r.HEAPU8=Q=new Uint8Array(l),r.HEAPU16=new Uint16Array(l),r.HEAPU32=q=new Uint32Array(l),r.HEAPF32=pe=new Float32Array(l),r.HEAPF64=J=new Float64Array(l)}var Z=[],ye=[],Ce=[];function fe(){var l=r.preRun.shift();Z.unshift(l)}var ce=0,Ne=null,Be=null;function He(l){throw r.onAbort&&r.onAbort(l),l="Aborted("+l+")",_(l),U=!0,V=1,l=new WebAssembly.RuntimeError(l+". Build with -sASSERTIONS for more info."),n(l),l}function L(l){return l.startsWith("data:application/octet-stream;base64,")}var ne;if(ne="ort-wasm-simd.wasm",!L(ne)){var he=ne;ne=r.locateFile?r.locateFile(he,v):v+he}function Fe(l){if(l==ne&&B)return new Uint8Array(B);if(y)return y(l);throw"both async and sync fetching of the wasm failed"}function Ze(l){if(!B&&(a||p)){if(typeof fetch=="function"&&!l.startsWith("file://"))return fetch(l,{credentials:"same-origin"}).then(m=>{if(!m.ok)throw"failed to load wasm binary file at \'"+l+"\'";return m.arrayBuffer()}).catch(()=>Fe(l));if(w)return new Promise((m,b)=>{w(l,C=>m(new Uint8Array(C)),b)})}return Promise.resolve().then(()=>Fe(l))}function Me(l,m,b){return Ze(l).then(C=>WebAssembly.instantiate(C,m)).then(C=>C).then(b,C=>{_("failed to asynchronously prepare wasm: "+C),He(C)})}function Ge(l,m){var b=ne;return B||typeof WebAssembly.instantiateStreaming!="function"||L(b)||b.startsWith("file://")||h||typeof fetch!="function"?Me(b,l,m):fetch(b,{credentials:"same-origin"}).then(C=>WebAssembly.instantiateStreaming(C,l).then(m,function(O){return _("wasm streaming compile failed: "+O),_("falling back to ArrayBuffer instantiation"),Me(b,l,m)}))}var Ke,ot={1424824:l=>{r.ra("Abs",l,void 0)},1424875:l=>{r.ra("Neg",l,void 0)},1424926:l=>{r.ra("Floor",l,void 0)},1424979:l=>{r.ra("Ceil",l,void 0)},1425031:l=>{r.ra("Reciprocal",l,void 0)},1425089:l=>{r.ra("Sqrt",l,void 0)},1425141:l=>{r.ra("Exp",l,void 0)},1425192:l=>{r.ra("Erf",l,void 0)},1425243:l=>{r.ra("Sigmoid",l,void 0)},1425298:l=>{r.ra("Log",l,void 0)},1425349:l=>{r.ra("Sin",l,void 0)},1425400:l=>{r.ra("Cos",l,void 0)},1425451:l=>{r.ra("Tan",l,void 0)},1425502:l=>{r.ra("Asin",l,void 0)},1425554:l=>{r.ra("Acos",l,void 0)},1425606:l=>{r.ra("Atan",l,void 0)},1425658:l=>{r.ra("Sinh",l,void 0)},1425710:l=>{r.ra("Cosh",l,void 0)},1425762:l=>{r.ra("Asinh",l,void 0)},1425815:l=>{r.ra("Acosh",l,void 0)},1425868:l=>{r.ra("Atanh",l,void 0)},1425921:l=>{r.ra("Tanh",l,void 0)},1425973:l=>{r.ra("Not",l,void 0)},1426024:(l,m,b)=>{r.ra("Clip",l,{min:m,max:b})},1426093:l=>{r.ra("Clip",l,void 0)},1426145:(l,m)=>{r.ra("Elu",l,{alpha:m})},1426203:l=>{r.ra("Relu",l,void 0)},1426255:(l,m)=>{r.ra("LeakyRelu",l,{alpha:m})},1426319:(l,m)=>{r.ra("ThresholdedRelu",l,{alpha:m})},1426389:l=>{r.Ra(l)},1426423:(l,m)=>r.Sa(l,m,r.Da.Ta,r.Da.errors),1426535:(l,m)=>{r.ra("Cast",l,{to:m})},1426593:l=>{r.ra("Add",l,void 0)},1426644:l=>{r.ra("Sub",l,void 0)},1426695:l=>{r.ra("Mul",l,void 0)},1426746:l=>{r.ra("Div",l,void 0)},1426797:l=>{r.ra("Pow",l,void 0)},1426848:l=>{r.ra("Equal",l,void 0)},1426901:l=>{r.ra("Greater",l,void 0)},1426956:l=>{r.ra("GreaterOrEqual",l,void 0)},1427018:l=>{r.ra("Less",l,void 0)},1427070:l=>{r.ra("LessOrEqual",l,void 0)},1427129:(l,m,b,C,O)=>{r.ra("ReduceMean",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(R.subarray(O>>>0,O+C>>>0)):[]})},1427293:(l,m,b,C,O)=>{r.ra("ReduceMax",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(R.subarray(O>>>0,O+C>>>0)):[]})},1427456:(l,m,b,C,O)=>{r.ra("ReduceMin",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(R.subarray(O>>>0,O+C>>>0)):[]})},1427619:(l,m,b,C,O)=>{r.ra("ReduceProd",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(R.subarray(O>>>0,O+C>>>0)):[]})},1427783:(l,m,b,C,O)=>{r.ra("ReduceSum",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(R.subarray(O>>>0,O+C>>>0)):[]})},1427946:(l,m,b,C,O)=>{r.ra("ReduceL1",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(R.subarray(O>>>0,O+C>>>0)):[]})},1428108:(l,m,b,C,O)=>{r.ra("ReduceL2",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(R.subarray(O>>>0,O+C>>>0)):[]})},1428270:(l,m,b,C,O)=>{r.ra("ReduceLogSum",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(R.subarray(O>>>0,O+C>>>0)):[]})},1428436:(l,m,b,C,O)=>{r.ra("ReduceSumSquare",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(R.subarray(O>>>0,O+C>>>0)):[]})},1428605:(l,m,b,C,O)=>{r.ra("ReduceLogSumExp",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(R.subarray(O>>>0,O+C>>>0)):[]})},1428774:l=>{r.ra("Where",l,void 0)},1428827:(l,m,b)=>{r.ra("Transpose",l,{perm:m?Array.from(R.subarray(b>>>0,b+m>>>0)):[]})},1428940:(l,m,b,C,O,F,H,de,X,ae,te,ge,Se)=>{r.ra("Conv",l,{format:X?"NHWC":"NCHW",auto_pad:m,dilations:[b],group:C,kernel_shape:[O],pads:F?Array.from(R.subarray(H>>>0,H+F>>>0)):[],strides:[de],w_is_const:()=>!!G[ae>>>0],activation:Ve(te),activation_params:ge?Array.from(pe.subarray(Se>>>0,Se+ge>>>0)):[]})},1429321:(l,m,b,C,O,F,H,de,X,ae,te,ge,Se,k,se,ve)=>{r.ra("Conv",l,{format:ge?"NHWC":"NCHW",auto_pad:m,dilations:[b,C],group:O,kernel_shape:[F,H],pads:de?Array.from(R.subarray(X>>>0,X+de>>>0)):[],strides:[ae,te],w_is_const:()=>!!G[Se>>>0],activation:Ve(k),activation_params:se?Array.from(pe.subarray(ve>>>0,ve+se>>>0)):[]})},1429723:(l,m,b,C,O,F,H,de,X,ae,te,ge,Se,k,se)=>{r.ra("ConvTranspose",l,{format:X?"NHWC":"NCHW",autoPad:m,dilations:[b],group:C,kernel_shape:[O],pads:[F,H],strides:[de],wIsConst:()=>!!G[ae>>>0],outputPadding:te?Array.from(R.subarray(ge>>>0,ge+te>>>0)):[],outputShape:Se?Array.from(R.subarray(k>>>0,k+Se>>>0)):[],activation:Ve(se)})},1430137:(l,m,b,C,O,F,H,de,X,ae,te,ge,Se,k)=>{r.ra("ConvTranspose",l,{format:de?"NHWC":"NCHW",autoPad:m,dilations:Array.from(R.subarray(b>>>0,b+2>>>0)),group:C,kernelShape:Array.from(R.subarray(O>>>0,O+2>>>0)),pads:Array.from(R.subarray(F>>>0,F+4>>>0)),strides:Array.from(R.subarray(H>>>0,H+2>>>0)),wIsConst:()=>!!G[X>>>0],outputPadding:0<ae?Array.from(R.subarray(te>>>0,te+ae>>>0)):[],outputShape:0<ge?Array.from(R.subarray(Se>>>0,Se+ge>>>0)):[],activation:Ve(k)})},1430694:(l,m,b,C,O,F,H,de,X,ae,te,ge,Se,k,se)=>{r.ra("ConvTranspose",l,{format:X?"NHWC":"NCHW",autoPad:m,dilations:[b],group:C,kernel_shape:[O],pads:[F,H],strides:[de],wIsConst:()=>!!G[ae>>>0],outputPadding:te?Array.from(R.subarray(ge>>>0,ge+te>>>0)):[],outputShape:Se?Array.from(R.subarray(k>>>0,k+Se>>>0)):[],activation:Ve(se)})},1431108:(l,m,b,C,O,F,H,de,X,ae,te,ge,Se,k)=>{r.ra("ConvTranspose",l,{format:de?"NHWC":"NCHW",autoPad:m,dilations:Array.from(R.subarray(b>>>0,b+2>>>0)),group:C,kernelShape:Array.from(R.subarray(O>>>0,O+2>>>0)),pads:Array.from(R.subarray(F>>>0,F+4>>>0)),strides:Array.from(R.subarray(H>>>0,H+2>>>0)),wIsConst:()=>!!G[X>>>0],outputPadding:0<ae?Array.from(R.subarray(te>>>0,te+ae>>>0)):[],outputShape:0<ge?Array.from(R.subarray(Se>>>0,Se+ge>>>0)):[],activation:Ve(k)})},1431665:(l,m)=>{r.ra("GlobalAveragePool",l,{format:m?"NHWC":"NCHW"})},1431756:(l,m,b,C,O,F,H,de,X,ae,te,ge,Se,k,se,ve)=>{r.ra("AveragePool",l,{format:ve?"NHWC":"NCHW",auto_pad:m,ceil_mode:b,count_include_pad:C,storage_order:O,dilations:[F,H],kernel_shape:[de,X],pads:[ae,te,ge,Se],strides:[k,se]})},1432040:(l,m)=>{r.ra("GlobalAveragePool",l,{format:m?"NHWC":"NCHW"})},1432131:(l,m,b,C,O,F,H,de,X,ae,te,ge,Se,k,se,ve)=>{r.ra("AveragePool",l,{format:ve?"NHWC":"NCHW",auto_pad:m,ceil_mode:b,count_include_pad:C,storage_order:O,dilations:[F,H],kernel_shape:[de,X],pads:[ae,te,ge,Se],strides:[k,se]})},1432415:(l,m)=>{r.ra("GlobalMaxPool",l,{format:m?"NHWC":"NCHW"})},1432502:(l,m,b,C,O,F,H,de,X,ae,te,ge,Se,k,se,ve)=>{r.ra("MaxPool",l,{format:ve?"NHWC":"NCHW",auto_pad:m,ceil_mode:b,count_include_pad:C,storage_order:O,dilations:[F,H],kernel_shape:[de,X],pads:[ae,te,ge,Se],strides:[k,se]})},1432782:(l,m)=>{r.ra("GlobalMaxPool",l,{format:m?"NHWC":"NCHW"})},1432869:(l,m,b,C,O,F,H,de,X,ae,te,ge,Se,k,se,ve)=>{r.ra("MaxPool",l,{format:ve?"NHWC":"NCHW",auto_pad:m,ceil_mode:b,count_include_pad:C,storage_order:O,dilations:[F,H],kernel_shape:[de,X],pads:[ae,te,ge,Se],strides:[k,se]})},1433149:(l,m,b,C,O)=>{r.ra("Gemm",l,{alpha:m,beta:b,transA:C,transB:O})},1433253:l=>{r.ra("MatMul",l,void 0)},1433307:(l,m,b,C)=>{r.ra("ArgMax",l,{keepDims:!!m,selectLastIndex:!!b,axis:C})},1433415:(l,m,b,C)=>{r.ra("ArgMin",l,{keepDims:!!m,selectLastIndex:!!b,axis:C})},1433523:(l,m)=>{r.ra("Softmax",l,{axis:m})},1433586:(l,m)=>{r.ra("Concat",l,{axis:m})},1433646:(l,m,b,C,O)=>{r.ra("Split",l,{axis:m,numOutputs:b,splitSizes:C?Array.from(R.subarray(O>>>0,O+C>>>0)):[]})},1433791:l=>{r.ra("Expand",l,void 0)},1433845:(l,m)=>{r.ra("Gather",l,{axis:Number(m)})},1433916:(l,m)=>{r.ra("GatherElements",l,{axis:Number(m)})},1433995:(l,m,b,C,O,F,H,de,X,ae,te)=>{r.ra("Resize",l,{antialias:m,axes:b?Array.from(R.subarray(C>>>0,C+b>>>0)):[],coordinateTransformMode:Ve(O),cubicCoeffA:F,excludeOutside:H,extrapolationValue:de,keepAspectRatioPolicy:Ve(X),mode:Ve(ae),nearestMode:Ve(te)})},1434346:(l,m,b,C,O,F,H)=>{r.ra("Slice",l,{starts:m?Array.from(R.subarray(b>>>0,b+m>>>0)):[],ends:C?Array.from(R.subarray(O>>>0,O+C>>>0)):[],axes:F?Array.from(R.subarray(H>>>0,H+F>>>0)):[]})},1434577:l=>{r.ra("Tile",l,void 0)},1434629:(l,m,b)=>{r.ra("LayerNormalization",l,{axis:Number(m),epsilon:Number(b)})},1434736:(l,m,b)=>{r.ra("InstanceNormalization",l,{epsilon:m,format:b?"NHWC":"NCHW"})},1434850:(l,m,b)=>{r.ra("InstanceNormalization",l,{epsilon:m,format:b?"NHWC":"NCHW"})},1434964:l=>{r.ra("Range",l,void 0)},1435017:(l,m)=>{r.ra("Einsum",l,{equation:Ve(m)})},1435098:(l,m,b,C,O)=>{r.ra("Pad",l,{mode:m,value:b,pads:C?Array.from(R.subarray(O>>>0,O+C>>>0)):[]})},1435230:(l,m,b,C,O,F)=>{r.ra("BatchNormalization",l,{epsilon:m,momentum:b,spatial:!!O,trainingMode:!!C,format:F?"NHWC":"NCHW"})},1435399:(l,m,b,C,O,F)=>{r.ra("BatchNormalization",l,{epsilon:m,momentum:b,spatial:!!O,trainingMode:!!C,format:F?"NHWC":"NCHW"})},1435568:(l,m,b)=>{r.ra("CumSum",l,{exclusive:Number(m),reverse:Number(b)})},1435665:(l,m,b,C,O,F,H,de,X)=>{r.ra("Attention",l,{numHeads:m,isUnidirectional:b,maskFilterValue:C,scale:O,doRotary:F,qkvHiddenSizes:H?Array.from(R.subarray(Number(de)>>>0,Number(de)+H>>>0)):[],pastPresentShareBuffer:!!X})},1435937:l=>{r.ra("Gelu",l,void 0)},1435989:(l,m,b,C,O,F)=>{r.ra("MultiHeadAttention",l,{numHeads:m,isUnidirectional:b,maskFilterValue:C,scale:O,doRotary:F})},1436148:l=>{r.ra("BiasAdd",l,void 0)},1436203:l=>{r.ra("BiasSplitGelu",l,void 0)},1436264:(l,m)=>{r.ra("SkipLayerNormalization",l,{epsilon:m})},1436345:l=>r.Oa(l),1436378:l=>r.Qa(l),1436410:(l,m,b)=>{r.Ja(l,m,b,!0)},1436449:(l,m,b)=>{r.Ja(l,m,b)}};function Qe(l){this.name="ExitStatus",this.message=`Program terminated with exit(${l})`,this.status=l}var xt=l=>{for(;0<l.length;)l.shift()(r)};function Ct(l){this.Ha=l-24,this.Ma=function(m){q[this.Ha+4>>2>>>0]=m},this.La=function(m){q[this.Ha+8>>2>>>0]=m},this.Ya=function(m,b){this.Ka(),this.Ma(m),this.La(b)},this.Ka=function(){q[this.Ha+16>>2>>>0]=0}}var Gt=0,hr=0,tt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Lt=(l,m,b)=>{m>>>=0;var C=m+b;for(b=m;l[b]&&!(b>=C);)++b;if(16<b-m&&l.buffer&&tt)return tt.decode(l.subarray(m,b));for(C="";m<b;){var O=l[m++];if(O&128){var F=l[m++]&63;if((O&224)==192)C+=String.fromCharCode((O&31)<<6|F);else{var H=l[m++]&63;O=(O&240)==224?(O&15)<<12|F<<6|H:(O&7)<<18|F<<12|H<<6|l[m++]&63,65536>O?C+=String.fromCharCode(O):(O-=65536,C+=String.fromCharCode(55296|O>>10,56320|O&1023))}}else C+=String.fromCharCode(O)}return C},Ve=(l,m)=>(l>>>=0)?Lt(Q,l,m):"",Pt=l=>{for(var m=0,b=0;b<l.length;++b){var C=l.charCodeAt(b);127>=C?m++:2047>=C?m+=2:55296<=C&&57343>=C?(m+=4,++b):m+=3}return m},Ft=(l,m,b,C)=>{if(b>>>=0,!(0<C))return 0;var O=b;C=b+C-1;for(var F=0;F<l.length;++F){var H=l.charCodeAt(F);if(55296<=H&&57343>=H){var de=l.charCodeAt(++F);H=65536+((H&1023)<<10)|de&1023}if(127>=H){if(b>=C)break;m[b++>>>0]=H}else{if(2047>=H){if(b+1>=C)break;m[b++>>>0]=192|H>>6}else{if(65535>=H){if(b+2>=C)break;m[b++>>>0]=224|H>>12}else{if(b+3>=C)break;m[b++>>>0]=240|H>>18,m[b++>>>0]=128|H>>12&63}m[b++>>>0]=128|H>>6&63}m[b++>>>0]=128|H&63}}return m[b>>>0]=0,b-O},mt=l=>l%4===0&&(l%100!==0||l%400===0),gr=[0,31,60,91,121,152,182,213,244,274,305,335],ft=[0,31,59,90,120,151,181,212,243,273,304,334],Rt=l=>{var m=Pt(l)+1,b=zt(m);return b&&Ft(l,Q,b,m),b},yt=[],Bt=(l,m)=>{yt.length=0;var b;for(m>>=2;b=Q[l++>>>0];)m+=b!=105&m,yt.push(b==105?R[m>>>0]:J[m++>>>1]),++m;return yt},Mt={},qt=()=>{if(!Dt){var l={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:u||"./this.program"},m;for(m in Mt)Mt[m]===void 0?delete l[m]:l[m]=Mt[m];var b=[];for(m in l)b.push(`${m}=${l[m]}`);Dt=b}return Dt},Dt,yr=[null,[],[]],qe=[31,29,31,30,31,30,31,31,30,31,30,31],jt=[31,28,31,30,31,30,31,31,30,31,30,31];function Kt(l){var m=Array(Pt(l)+1);return Ft(l,m,0,m.length),m}function le(l,m,b,C){function O(k,se,ve){for(k=typeof k=="number"?k.toString():k||"";k.length<se;)k=ve[0]+k;return k}function F(k,se){return O(k,se,"0")}function H(k,se){function ve(ar){return 0>ar?-1:0<ar?1:0}var gt;return(gt=ve(k.getFullYear()-se.getFullYear()))===0&&(gt=ve(k.getMonth()-se.getMonth()))===0&&(gt=ve(k.getDate()-se.getDate())),gt}function de(k){switch(k.getDay()){case 0:return new Date(k.getFullYear()-1,11,29);case 1:return k;case 2:return new Date(k.getFullYear(),0,3);case 3:return new Date(k.getFullYear(),0,2);case 4:return new Date(k.getFullYear(),0,1);case 5:return new Date(k.getFullYear()-1,11,31);case 6:return new Date(k.getFullYear()-1,11,30)}}function X(k){var se=k.Ba;for(k=new Date(new Date(k.Ca+1900,0,1).getTime());0<se;){var ve=k.getMonth(),gt=(mt(k.getFullYear())?qe:jt)[ve];if(se>gt-k.getDate())se-=gt-k.getDate()+1,k.setDate(1),11>ve?k.setMonth(ve+1):(k.setMonth(0),k.setFullYear(k.getFullYear()+1));else{k.setDate(k.getDate()+se);break}}return ve=new Date(k.getFullYear()+1,0,4),se=de(new Date(k.getFullYear(),0,4)),ve=de(ve),0>=H(se,k)?0>=H(ve,k)?k.getFullYear()+1:k.getFullYear():k.getFullYear()-1}l>>>=0,m>>>=0,b>>>=0,C>>>=0;var ae=R[C+40>>2>>>0];C={Wa:R[C>>2>>>0],Va:R[C+4>>2>>>0],Ea:R[C+8>>2>>>0],Ia:R[C+12>>2>>>0],Fa:R[C+16>>2>>>0],Ca:R[C+20>>2>>>0],wa:R[C+24>>2>>>0],Ba:R[C+28>>2>>>0],$a:R[C+32>>2>>>0],Ua:R[C+36>>2>>>0],Xa:ae?Ve(ae):""},b=Ve(b),ae={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var te in ae)b=b.replace(new RegExp(te,"g"),ae[te]);var ge="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Se="January February March April May June July August September October November December".split(" ");ae={"%a":k=>ge[k.wa].substring(0,3),"%A":k=>ge[k.wa],"%b":k=>Se[k.Fa].substring(0,3),"%B":k=>Se[k.Fa],"%C":k=>F((k.Ca+1900)/100|0,2),"%d":k=>F(k.Ia,2),"%e":k=>O(k.Ia,2," "),"%g":k=>X(k).toString().substring(2),"%G":k=>X(k),"%H":k=>F(k.Ea,2),"%I":k=>(k=k.Ea,k==0?k=12:12<k&&(k-=12),F(k,2)),"%j":k=>{for(var se=0,ve=0;ve<=k.Fa-1;se+=(mt(k.Ca+1900)?qe:jt)[ve++]);return F(k.Ia+se,3)},"%m":k=>F(k.Fa+1,2),"%M":k=>F(k.Va,2),"%n":()=>`\n`,"%p":k=>0<=k.Ea&&12>k.Ea?"AM":"PM","%S":k=>F(k.Wa,2),"%t":()=>"	","%u":k=>k.wa||7,"%U":k=>F(Math.floor((k.Ba+7-k.wa)/7),2),"%V":k=>{var se=Math.floor((k.Ba+7-(k.wa+6)%7)/7);if(2>=(k.wa+371-k.Ba-2)%7&&se++,se)se==53&&(ve=(k.wa+371-k.Ba)%7,ve==4||ve==3&&mt(k.Ca)||(se=1));else{se=52;var ve=(k.wa+7-k.Ba-1)%7;(ve==4||ve==5&&mt(k.Ca%400-1))&&se++}return F(se,2)},"%w":k=>k.wa,"%W":k=>F(Math.floor((k.Ba+7-(k.wa+6)%7)/7),2),"%y":k=>(k.Ca+1900).toString().substring(2),"%Y":k=>k.Ca+1900,"%z":k=>{k=k.Ua;var se=0<=k;return k=Math.abs(k)/60,(se?"+":"-")+("0000"+(k/60*100+k%60)).slice(-4)},"%Z":k=>k.Xa,"%%":()=>"%"},b=b.replace(/%%/g,"\\0\\0");for(te in ae)b.includes(te)&&(b=b.replace(new RegExp(te,"g"),ae[te](C)));return b=b.replace(/\\0\\0/g,"%"),te=Kt(b),te.length>m?0:(G.set(te,l>>>0),te.length-1)}function ht(l){try{l()}catch(m){He(m)}}function br(l){var m={},b;for(b in l)(function(C){var O=l[C];m[C]=typeof O=="function"?function(){_t.push(C);try{return O.apply(null,arguments)}finally{U||(_t.pop()===C||He(),Je&&at===1&&_t.length===0&&(at=0,ht(nr),typeof Fibers<"u"&&Fibers.ab()))}}:O})(b);return m}var at=0,Je=null,wr=0,_t=[],Yt={},Zt={},vr=0,It=null,$r=[];function Sr(){return new Promise((l,m)=>{It={resolve:l,reject:m}})}function xr(){var l=zt(65548),m=l+12;q[l>>2>>>0]=m,q[l+4>>2>>>0]=m+65536,m=_t[0];var b=Yt[m];return b===void 0&&(b=vr++,Yt[m]=b,Zt[b]=m),R[l+8>>2>>>0]=b,l}function Cr(l){if(!U){if(at===0){var m=!1,b=!1;l((C=0)=>{if(!U&&(wr=C,m=!0,b)){at=2,ht(()=>Vt(Je)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),C=!1;try{var O=(0,A[Zt[R[Je+8>>2>>>0]]])()}catch(de){O=de,C=!0}var F=!1;if(!Je){var H=It;H&&(It=null,(C?H.reject:H.resolve)(O),F=!0)}if(C&&!F)throw O}}),b=!0,m||(at=1,Je=xr(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),ht(()=>rr(Je)))}else at===2?(at=0,ht(At),Xt(Je),Je=null,$r.forEach(C=>{if(!U)try{if(C(),!E)try{V=V=C=V,E||(r.onExit&&r.onExit(C),U=!0),d(C,new Qe(C))}catch(O){O instanceof Qe||O=="unwind"||d(1,O)}}catch(O){O instanceof Qe||O=="unwind"||d(1,O)}})):He(`invalid state: ${at}`);return wr}}function _r(l){return Cr(m=>{l().then(m)})}var Ir={n:function(l,m,b){return _r(async()=>{await r.Pa(l,m,b)})},a:function(l,m,b){throw l>>>=0,new Ct(l).Ya(m>>>0,b>>>0),Gt=l,hr++,Gt},d:function(){return 0},L:function(){},A:function(){},C:function(){},u:function(){return 0},J:function(){},E:function(){},I:function(){},l:function(){},B:function(){},y:function(){},K:function(){},z:function(){},m:()=>!0,q:function(l,m,b){l=m+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*m:NaN,b>>>=0,l=new Date(1e3*l),R[b>>2>>>0]=l.getUTCSeconds(),R[b+4>>2>>>0]=l.getUTCMinutes(),R[b+8>>2>>>0]=l.getUTCHours(),R[b+12>>2>>>0]=l.getUTCDate(),R[b+16>>2>>>0]=l.getUTCMonth(),R[b+20>>2>>>0]=l.getUTCFullYear()-1900,R[b+24>>2>>>0]=l.getUTCDay(),R[b+28>>2>>>0]=(l.getTime()-Date.UTC(l.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(l,m,b){l=m+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*m:NaN,b>>>=0,l=new Date(1e3*l),R[b>>2>>>0]=l.getSeconds(),R[b+4>>2>>>0]=l.getMinutes(),R[b+8>>2>>>0]=l.getHours(),R[b+12>>2>>>0]=l.getDate(),R[b+16>>2>>>0]=l.getMonth(),R[b+20>>2>>>0]=l.getFullYear()-1900,R[b+24>>2>>>0]=l.getDay(),R[b+28>>2>>>0]=(mt(l.getFullYear())?gr:ft)[l.getMonth()]+l.getDate()-1|0,R[b+36>>2>>>0]=-(60*l.getTimezoneOffset()),m=new Date(l.getFullYear(),6,1).getTimezoneOffset();var C=new Date(l.getFullYear(),0,1).getTimezoneOffset();R[b+32>>2>>>0]=(m!=C&&l.getTimezoneOffset()==Math.min(C,m))|0},s:function(l){l>>>=0;var m=new Date(R[l+20>>2>>>0]+1900,R[l+16>>2>>>0],R[l+12>>2>>>0],R[l+8>>2>>>0],R[l+4>>2>>>0],R[l>>2>>>0],0),b=R[l+32>>2>>>0],C=m.getTimezoneOffset(),O=new Date(m.getFullYear(),6,1).getTimezoneOffset(),F=new Date(m.getFullYear(),0,1).getTimezoneOffset(),H=Math.min(F,O);return 0>b?R[l+32>>2>>>0]=+(O!=F&&H==C):0<b!=(H==C)&&(O=Math.max(F,O),m.setTime(m.getTime()+6e4*((0<b?H:O)-C))),R[l+24>>2>>>0]=m.getDay(),R[l+28>>2>>>0]=(mt(m.getFullYear())?gr:ft)[m.getMonth()]+m.getDate()-1|0,R[l>>2>>>0]=m.getSeconds(),R[l+4>>2>>>0]=m.getMinutes(),R[l+8>>2>>>0]=m.getHours(),R[l+12>>2>>>0]=m.getDate(),R[l+16>>2>>>0]=m.getMonth(),R[l+20>>2>>>0]=m.getYear(),l=m.getTime()/1e3,Qt((Ke=l,1<=+Math.abs(Ke)?0<Ke?+Math.floor(Ke/4294967296)>>>0:~~+Math.ceil((Ke-+(~~Ke>>>0))/4294967296)>>>0:0)),l>>>0},o:function(){return-52},p:function(){},w:function(l,m,b){function C(X){return(X=X.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?X[1]:"GMT"}b>>>=0;var O=new Date().getFullYear(),F=new Date(O,0,1),H=new Date(O,6,1);O=F.getTimezoneOffset();var de=H.getTimezoneOffset();q[l>>>0>>2>>>0]=60*Math.max(O,de),R[m>>>0>>2>>>0]=+(O!=de),l=C(F),m=C(H),l=Rt(l),m=Rt(m),de<O?(q[b>>2>>>0]=l,q[b+4>>2>>>0]=m):(q[b>>2>>>0]=m,q[b+4>>2>>>0]=l)},e:()=>{He("")},b:function(l,m,b){return l>>>=0,m=Bt(m>>>0,b>>>0),ot[l].apply(null,m)},j:function(l,m,b){return l>>>=0,m=Bt(m>>>0,b>>>0),ot[l].apply(null,m)},i:function(){return Date.now()},x:function(){return 4294901760},f:()=>performance.now(),H:function(l,m,b){return m>>>=0,Q.copyWithin(l>>>0>>>0,m>>>0,m+(b>>>0)>>>0)},v:function(l){l>>>=0;var m=Q.length;if(4294901760<l)return!1;for(var b=1;4>=b;b*=2){var C=m*(1+.2/b);C=Math.min(C,l+100663296);var O=Math;C=Math.max(l,C);e:{O=O.min.call(O,4294901760,C+(65536-C%65536)%65536)-z.buffer.byteLength+65535>>>16;try{z.grow(O),we();var F=1;break e}catch{}F=void 0}if(F)return!0}return!1},F:function(l,m){l>>>=0,m>>>=0;var b=0;return qt().forEach(function(C,O){var F=m+b;for(O=q[l+4*O>>2>>>0]=F,F=0;F<C.length;++F)G[O++>>0>>>0]=C.charCodeAt(F);G[O>>0>>>0]=0,b+=C.length+1}),0},G:function(l,m){l>>>=0,m>>>=0;var b=qt();q[l>>2>>>0]=b.length;var C=0;return b.forEach(function(O){C+=O.length+1}),q[m>>2>>>0]=C,0},g:()=>52,k:function(){return 52},t:function(){return 70},h:function(l,m,b,C){m>>>=0,b>>>=0,C>>>=0;for(var O=0,F=0;F<b;F++){var H=q[m>>2>>>0],de=q[m+4>>2>>>0];m+=8;for(var X=0;X<de;X++){var ae=Q[H+X>>>0],te=yr[l];ae===0||ae===10?((l===1?x:_)(Lt(te,0)),te.length=0):te.push(ae)}O+=de}return q[C>>2>>>0]=O,0},D:le,c:function(l,m,b,C){return le(l>>>0,m>>>0,b>>>0,C>>>0)}};(function(){function l(b){if(b=b.exports,b=br(b),A=b=bt(b),z=A.M,we(),ye.unshift(A.N),ce--,r.monitorRunDependencies&&r.monitorRunDependencies(ce),ce==0&&(Ne!==null&&(clearInterval(Ne),Ne=null),Be)){var C=Be;Be=null,C()}return b}var m={a:Ir};if(ce++,r.monitorRunDependencies&&r.monitorRunDependencies(ce),r.instantiateWasm)try{return r.instantiateWasm(m,l)}catch(b){_("Module.instantiateWasm callback failed with error: "+b),n(b)}return Ge(m,function(b){l(b.instance)}).catch(n),{}})(),r._OrtInit=(l,m)=>(r._OrtInit=A.O)(l,m),r._OrtGetLastError=(l,m)=>(r._OrtGetLastError=A.P)(l,m),r._OrtCreateSessionOptions=(l,m,b,C,O,F,H,de,X,ae)=>(r._OrtCreateSessionOptions=A.Q)(l,m,b,C,O,F,H,de,X,ae),r._OrtAppendExecutionProvider=(l,m)=>(r._OrtAppendExecutionProvider=A.R)(l,m),r._OrtAddFreeDimensionOverride=(l,m,b)=>(r._OrtAddFreeDimensionOverride=A.S)(l,m,b),r._OrtAddSessionConfigEntry=(l,m,b)=>(r._OrtAddSessionConfigEntry=A.T)(l,m,b),r._OrtReleaseSessionOptions=l=>(r._OrtReleaseSessionOptions=A.U)(l),r._OrtCreateSession=(l,m,b)=>(r._OrtCreateSession=A.V)(l,m,b),r._OrtReleaseSession=l=>(r._OrtReleaseSession=A.W)(l),r._OrtGetInputOutputCount=(l,m,b)=>(r._OrtGetInputOutputCount=A.X)(l,m,b),r._OrtGetInputName=(l,m)=>(r._OrtGetInputName=A.Y)(l,m),r._OrtGetOutputName=(l,m)=>(r._OrtGetOutputName=A.Z)(l,m),r._OrtFree=l=>(r._OrtFree=A._)(l),r._OrtCreateTensor=(l,m,b,C,O,F)=>(r._OrtCreateTensor=A.$)(l,m,b,C,O,F),r._OrtGetTensorData=(l,m,b,C,O)=>(r._OrtGetTensorData=A.aa)(l,m,b,C,O),r._OrtReleaseTensor=l=>(r._OrtReleaseTensor=A.ba)(l),r._OrtCreateRunOptions=(l,m,b,C)=>(r._OrtCreateRunOptions=A.ca)(l,m,b,C),r._OrtAddRunConfigEntry=(l,m,b)=>(r._OrtAddRunConfigEntry=A.da)(l,m,b),r._OrtReleaseRunOptions=l=>(r._OrtReleaseRunOptions=A.ea)(l),r._OrtCreateBinding=l=>(r._OrtCreateBinding=A.fa)(l),r._OrtBindInput=(l,m,b)=>(r._OrtBindInput=A.ga)(l,m,b),r._OrtBindOutput=(l,m,b,C)=>(r._OrtBindOutput=A.ha)(l,m,b,C),r._OrtClearBoundOutputs=l=>(r._OrtClearBoundOutputs=A.ia)(l),r._OrtReleaseBinding=l=>(r._OrtReleaseBinding=A.ja)(l),r._OrtRunWithBinding=(l,m,b,C,O)=>(r._OrtRunWithBinding=A.ka)(l,m,b,C,O),r._OrtRun=(l,m,b,C,O,F,H,de)=>(r._OrtRun=A.la)(l,m,b,C,O,F,H,de),r._OrtEndProfiling=l=>(r._OrtEndProfiling=A.ma)(l),r._JsepOutput=(l,m,b)=>(r._JsepOutput=A.na)(l,m,b),r._JsepGetNodeName=l=>(r._JsepGetNodeName=A.oa)(l);var zt=r._malloc=l=>(zt=r._malloc=A.pa)(l),Xt=r._free=l=>(Xt=r._free=A.qa)(l),Qt=l=>(Qt=A.sa)(l),Jt=()=>(Jt=A.ta)(),er=l=>(er=A.ua)(l),tr=l=>(tr=A.va)(l),rr=l=>(rr=A.xa)(l),nr=()=>(nr=A.ya)(),Vt=l=>(Vt=A.za)(l),At=()=>(At=A.Aa)();r.___start_em_js=1436482,r.___stop_em_js=1436643;function bt(l){l=Object.assign({},l);var m=C=>()=>C()>>>0,b=C=>O=>C(O)>>>0;return l.__errno_location=m(l.__errno_location),l.malloc=b(l.malloc),l.stackSave=m(l.stackSave),l.stackAlloc=b(l.stackAlloc),l}r.stackAlloc=tr,r.stackSave=Jt,r.stackRestore=er,r.UTF8ToString=Ve,r.stringToUTF8=(l,m,b)=>Ft(l,Q,m,b),r.lengthBytesUTF8=Pt;var Tt;Be=function l(){Tt||or(),Tt||(Be=l)};function or(){function l(){if(!Tt&&(Tt=!0,r.calledRun=!0,!U)){if(xt(ye),o(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var m=r.postRun.shift();Ce.unshift(m)}xt(Ce)}}if(!(0<ce)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)fe();xt(Z),0<ce||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),l()},1)):l())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return or(),t.ready}})();typeof vo=="object"&&typeof wn=="object"?wn.exports=wo:typeof define=="function"&&define.amd&&define([],()=>wo)});var So=ir(()=>{});var xo=ir(()=>{});var Co={};Pr(Co,{cpus:()=>ju});var ju,_o=Y(()=>{ju=void 0});var To=ir((Ao,vn)=>{"use strict";var Io=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return we.buffer!=ce.buffer&&he(),ce}function o(){return we.buffer!=ce.buffer&&he(),Ne}function n(){return we.buffer!=ce.buffer&&he(),Be}function s(){return we.buffer!=ce.buffer&&he(),He}function u(){return we.buffer!=ce.buffer&&he(),L}function d(){return we.buffer!=ce.buffer&&he(),ne}var a=t,p,h;a.ready=new Promise((i,c)=>{p=i,h=c}),a.jsepInit=(i,c,f,$,T,M,N,ie)=>{a.Qb=i,a.wb=c,a.yb=f,a.jb=$,a.xb=T,a.Ea=M,a.zb=N,a.Ab=ie,c=(re,oe,ue)=>(...xe)=>{let Ie=it,P=oe?.();xe=re(...xe);let me=oe?.();return P!==me&&(re=me,ue(P),oe=ue=null),it!=Ie?Ru():xe},f=re=>async(...oe)=>{try{if(a.bb)throw Error("Session already started");let ue=a.bb={Fb:oe[0],errors:[]},xe=await re(...oe);if(a.bb!==ue)throw Error("Session mismatch");i.flush();let Ie=ue.errors;if(0<Ie.length){let P=await Promise.all(Ie);if(P=P.filter(me=>me),0<P.length)throw Error(P.join(`\n`))}return xe}finally{a.bb=null}},a._OrtRun=f(c(a._OrtRun,()=>a._OrtRun,re=>a._OrtRun=re)),a._OrtRunWithBinding=f(c(a._OrtRunWithBinding,()=>a._OrtRunWithBinding,re=>a._OrtRunWithBinding=re)),a._OrtBindInput=c(a._OrtBindInput,()=>a._OrtBindInput,re=>a._OrtBindInput=re),a.jsepRegisterBuffer=(re,oe,ue,xe)=>i.registerBuffer(re,oe,ue,xe),a.jsepUnregisterBuffers=re=>{i.unregisterBuffers(re)},a.jsepGetBuffer=re=>i.getBuffer(re),a.jsepCreateDownloader=(re,oe,ue)=>i.createDownloader(re,oe,ue)};var v=Object.assign({},a),g="./this.program",w=(i,c)=>{throw c},y=typeof window=="object",S=typeof importScripts=="function",I=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x=a.ENVIRONMENT_IS_PTHREAD||!1,_="";function B(i){return a.locateFile?a.locateFile(i,_):_+i}var E,z,A;if(I){var U=(gn(),Wt(hn)),V=(bn(),Wt(yn));_=S?V.dirname(_)+"/":__dirname+"/",E=(c,f)=>(c=c.startsWith("file://")?new URL(c):V.normalize(c),U.readFileSync(c,f?void 0:"utf8")),A=c=>(c=E(c,!0),c.buffer||(c=new Uint8Array(c)),c),z=(c,f,$,T=!0)=>{c=c.startsWith("file://")?new URL(c):V.normalize(c),U.readFile(c,T?void 0:"utf8",(M,N)=>{M?$(M):f(T?N.buffer:N)})},!a.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),w=(c,f)=>{throw process.exitCode=c,f},a.inspect=()=>"[Emscripten Module object]";let i;try{i=So()}catch(c){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),c}global.Worker=i.Worker}else(y||S)&&(S?_=self.location.href:typeof document<"u"&&document.currentScript&&(_=document.currentScript.src),typeof e<"u"&&e&&(_=e),_.indexOf("blob:")!==0?_=_.substr(0,_.replace(/[?#].*/,"").lastIndexOf("/")+1):_="",I||(E=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.send(null),c.responseText},S&&(A=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.responseType="arraybuffer",c.send(null),new Uint8Array(c.response)}),z=(i,c,f)=>{var $=new XMLHttpRequest;$.open("GET",i,!0),$.responseType="arraybuffer",$.onload=()=>{$.status==200||$.status==0&&$.response?c($.response):f()},$.onerror=f,$.send(null)}));I&&typeof performance>"u"&&(global.performance=xo().performance);var G=console.log.bind(console),Q=console.error.bind(console);I&&(G=(...i)=>U.writeSync(1,i.join(" ")+`\n`),Q=(...i)=>U.writeSync(2,i.join(" ")+`\n`));var R=a.print||G,q=a.printErr||Q;Object.assign(a,v),v=null,a.thisProgram&&(g=a.thisProgram),a.quit&&(w=a.quit);var pe;a.wasmBinary&&(pe=a.wasmBinary);var J=a.noExitRuntime||!0;typeof WebAssembly!="object"&&tt("no native wasm support detected");var we,Z,ye,Ce=!1,fe,ce,Ne,Be,He,L,ne;function he(){var i=we.buffer;a.HEAP8=ce=new Int8Array(i),a.HEAP16=new Int16Array(i),a.HEAP32=Be=new Int32Array(i),a.HEAPU8=Ne=new Uint8Array(i),a.HEAPU16=new Uint16Array(i),a.HEAPU32=He=new Uint32Array(i),a.HEAPF32=L=new Float32Array(i),a.HEAPF64=ne=new Float64Array(i)}var Fe=a.INITIAL_MEMORY||16777216;if(5242880<=Fe||tt("INITIAL_MEMORY should be larger than STACK_SIZE, was "+Fe+"! (STACK_SIZE=5242880)"),x)we=a.wasmMemory;else if(a.wasmMemory)we=a.wasmMemory;else if(we=new WebAssembly.Memory({initial:Fe/65536,maximum:65536,shared:!0}),!(we.buffer instanceof SharedArrayBuffer))throw q("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),I&&q("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");he(),Fe=we.buffer.byteLength;var Ze=[],Me=[],Ge=[],Ke=0;function ot(){return J||0<Ke}var Qe=0,xt=null,Ct=null;function Gt(){Qe++,a.monitorRunDependencies&&a.monitorRunDependencies(Qe)}function hr(){if(Qe--,a.monitorRunDependencies&&a.monitorRunDependencies(Qe),Qe==0&&(xt!==null&&(clearInterval(xt),xt=null),Ct)){var i=Ct;Ct=null,i()}}function tt(i){throw a.onAbort&&a.onAbort(i),i="Aborted("+i+")",q(i),Ce=!0,fe=1,i=new WebAssembly.RuntimeError(i+". Build with -sASSERTIONS for more info."),h(i),i}function Lt(i){return i.startsWith("data:application/octet-stream;base64,")}var Ve;Ve="ort-wasm-simd-threaded.wasm",Lt(Ve)||(Ve=B(Ve));function Pt(i){if(i==Ve&&pe)return new Uint8Array(pe);if(A)return A(i);throw"both async and sync fetching of the wasm failed"}function Ft(i){if(!pe&&(y||S)){if(typeof fetch=="function"&&!i.startsWith("file://"))return fetch(i,{credentials:"same-origin"}).then(c=>{if(!c.ok)throw"failed to load wasm binary file at \'"+i+"\'";return c.arrayBuffer()}).catch(()=>Pt(i));if(z)return new Promise((c,f)=>{z(i,$=>c(new Uint8Array($)),f)})}return Promise.resolve().then(()=>Pt(i))}function mt(i,c,f){return Ft(i).then($=>WebAssembly.instantiate($,c)).then($=>$).then(f,$=>{q("failed to asynchronously prepare wasm: "+$),tt($)})}function gr(i,c){var f=Ve;return pe||typeof WebAssembly.instantiateStreaming!="function"||Lt(f)||f.startsWith("file://")||I||typeof fetch!="function"?mt(f,i,c):fetch(f,{credentials:"same-origin"}).then($=>WebAssembly.instantiateStreaming($,i).then(c,function(T){return q("wasm streaming compile failed: "+T),q("falling back to ArrayBuffer instantiation"),mt(f,i,c)}))}var ft,Rt={913596:i=>{a.Ea("Abs",i,void 0)},913647:i=>{a.Ea("Neg",i,void 0)},913698:i=>{a.Ea("Floor",i,void 0)},913751:i=>{a.Ea("Ceil",i,void 0)},913803:i=>{a.Ea("Reciprocal",i,void 0)},913861:i=>{a.Ea("Sqrt",i,void 0)},913913:i=>{a.Ea("Exp",i,void 0)},913964:i=>{a.Ea("Erf",i,void 0)},914015:i=>{a.Ea("Sigmoid",i,void 0)},914070:i=>{a.Ea("Log",i,void 0)},914121:i=>{a.Ea("Sin",i,void 0)},914172:i=>{a.Ea("Cos",i,void 0)},914223:i=>{a.Ea("Tan",i,void 0)},914274:i=>{a.Ea("Asin",i,void 0)},914326:i=>{a.Ea("Acos",i,void 0)},914378:i=>{a.Ea("Atan",i,void 0)},914430:i=>{a.Ea("Sinh",i,void 0)},914482:i=>{a.Ea("Cosh",i,void 0)},914534:i=>{a.Ea("Asinh",i,void 0)},914587:i=>{a.Ea("Acosh",i,void 0)},914640:i=>{a.Ea("Atanh",i,void 0)},914693:i=>{a.Ea("Tanh",i,void 0)},914745:i=>{a.Ea("Not",i,void 0)},914796:(i,c,f)=>{a.Ea("Clip",i,{min:c,max:f})},914865:i=>{a.Ea("Clip",i,void 0)},914917:(i,c)=>{a.Ea("Elu",i,{alpha:c})},914975:i=>{a.Ea("Relu",i,void 0)},915027:(i,c)=>{a.Ea("LeakyRelu",i,{alpha:c})},915091:(i,c)=>{a.Ea("ThresholdedRelu",i,{alpha:c})},915161:(i,c)=>{a.Ea("Cast",i,{to:c})},915219:i=>{a.Ea("Add",i,void 0)},915270:i=>{a.Ea("Sub",i,void 0)},915321:i=>{a.Ea("Mul",i,void 0)},915372:i=>{a.Ea("Div",i,void 0)},915423:i=>{a.Ea("Pow",i,void 0)},915474:i=>{a.Ea("Equal",i,void 0)},915527:i=>{a.Ea("Greater",i,void 0)},915582:i=>{a.Ea("GreaterOrEqual",i,void 0)},915644:i=>{a.Ea("Less",i,void 0)},915696:i=>{a.Ea("LessOrEqual",i,void 0)},915755:(i,c,f,$,T)=>{a.Ea("ReduceMean",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},915919:(i,c,f,$,T)=>{a.Ea("ReduceMax",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},916082:(i,c,f,$,T)=>{a.Ea("ReduceMin",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},916245:(i,c,f,$,T)=>{a.Ea("ReduceProd",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},916409:(i,c,f,$,T)=>{a.Ea("ReduceSum",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},916572:(i,c,f,$,T)=>{a.Ea("ReduceL1",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},916734:(i,c,f,$,T)=>{a.Ea("ReduceL2",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},916896:(i,c,f,$,T)=>{a.Ea("ReduceLogSum",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},917062:(i,c,f,$,T)=>{a.Ea("ReduceSumSquare",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},917231:(i,c,f,$,T)=>{a.Ea("ReduceLogSumExp",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},917400:i=>{a.Ea("Where",i,void 0)},917453:(i,c,f)=>{a.Ea("Transpose",i,{perm:c?Array.from(n().subarray(f>>>0,f+c>>>0)):[]})},917566:(i,c,f,$,T,M,N,ie,re,oe,ue,xe,Ie,P,me)=>{a.Ea("ConvTranspose",i,{format:re?"NHWC":"NCHW",autoPad:c,dilations:[f],group:$,kernel_shape:[T],pads:[M,N],strides:[ie],wIsConst:()=>!!r()[oe>>>0],outputPadding:ue?Array.from(n().subarray(xe>>>0,xe+ue>>>0)):[],outputShape:Ie?Array.from(n().subarray(P>>>0,P+Ie>>>0)):[],activation:qe(me)})},917980:(i,c,f,$,T,M,N,ie,re,oe,ue,xe,Ie,P)=>{a.Ea("ConvTranspose",i,{format:ie?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(f>>>0,f+2>>>0)),group:$,kernelShape:Array.from(n().subarray(T>>>0,T+2>>>0)),pads:Array.from(n().subarray(M>>>0,M+4>>>0)),strides:Array.from(n().subarray(N>>>0,N+2>>>0)),wIsConst:()=>!!r()[re>>>0],outputPadding:0<oe?Array.from(n().subarray(ue>>>0,ue+oe>>>0)):[],outputShape:0<xe?Array.from(n().subarray(Ie>>>0,Ie+xe>>>0)):[],activation:qe(P)})},918537:(i,c,f,$,T,M,N,ie,re,oe,ue,xe,Ie,P,me)=>{a.Ea("ConvTranspose",i,{format:re?"NHWC":"NCHW",autoPad:c,dilations:[f],group:$,kernel_shape:[T],pads:[M,N],strides:[ie],wIsConst:()=>!!r()[oe>>>0],outputPadding:ue?Array.from(n().subarray(xe>>>0,xe+ue>>>0)):[],outputShape:Ie?Array.from(n().subarray(P>>>0,P+Ie>>>0)):[],activation:qe(me)})},918951:(i,c,f,$,T,M,N,ie,re,oe,ue,xe,Ie,P)=>{a.Ea("ConvTranspose",i,{format:ie?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(f>>>0,f+2>>>0)),group:$,kernelShape:Array.from(n().subarray(T>>>0,T+2>>>0)),pads:Array.from(n().subarray(M>>>0,M+4>>>0)),strides:Array.from(n().subarray(N>>>0,N+2>>>0)),wIsConst:()=>!!r()[re>>>0],outputPadding:0<oe?Array.from(n().subarray(ue>>>0,ue+oe>>>0)):[],outputShape:0<xe?Array.from(n().subarray(Ie>>>0,Ie+xe>>>0)):[],activation:qe(P)})},919508:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},919599:(i,c,f,$,T,M,N,ie,re,oe,ue,xe,Ie,P,me,_e)=>{a.Ea("AveragePool",i,{format:_e?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:$,storage_order:T,dilations:[M,N],kernel_shape:[ie,re],pads:[oe,ue,xe,Ie],strides:[P,me]})},919883:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},919974:(i,c,f,$,T,M,N,ie,re,oe,ue,xe,Ie,P,me,_e)=>{a.Ea("AveragePool",i,{format:_e?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:$,storage_order:T,dilations:[M,N],kernel_shape:[ie,re],pads:[oe,ue,xe,Ie],strides:[P,me]})},920258:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},920345:(i,c,f,$,T,M,N,ie,re,oe,ue,xe,Ie,P,me,_e)=>{a.Ea("MaxPool",i,{format:_e?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:$,storage_order:T,dilations:[M,N],kernel_shape:[ie,re],pads:[oe,ue,xe,Ie],strides:[P,me]})},920625:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},920712:(i,c,f,$,T,M,N,ie,re,oe,ue,xe,Ie,P,me,_e)=>{a.Ea("MaxPool",i,{format:_e?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:$,storage_order:T,dilations:[M,N],kernel_shape:[ie,re],pads:[oe,ue,xe,Ie],strides:[P,me]})},920992:(i,c,f,$,T)=>{a.Ea("Gemm",i,{alpha:c,beta:f,transA:$,transB:T})},921096:i=>{a.Ea("MatMul",i,void 0)},921150:(i,c,f,$)=>{a.Ea("ArgMax",i,{keepDims:!!c,selectLastIndex:!!f,axis:$})},921258:(i,c,f,$)=>{a.Ea("ArgMin",i,{keepDims:!!c,selectLastIndex:!!f,axis:$})},921366:(i,c)=>{a.Ea("Softmax",i,{axis:c})},921429:(i,c)=>{a.Ea("Concat",i,{axis:c})},921489:(i,c,f,$,T)=>{a.Ea("Split",i,{axis:c,numOutputs:f,splitSizes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},921634:i=>{a.Ea("Expand",i,void 0)},921688:(i,c)=>{a.Ea("Gather",i,{axis:Number(c)})},921759:(i,c)=>{a.Ea("GatherElements",i,{axis:Number(c)})},921838:(i,c,f,$,T,M,N,ie,re,oe,ue)=>{a.Ea("Resize",i,{antialias:c,axes:f?Array.from(n().subarray($>>>0,$+f>>>0)):[],coordinateTransformMode:qe(T),cubicCoeffA:M,excludeOutside:N,extrapolationValue:ie,keepAspectRatioPolicy:qe(re),mode:qe(oe),nearestMode:qe(ue)})},922189:(i,c,f,$,T,M,N)=>{a.Ea("Slice",i,{starts:c?Array.from(n().subarray(f>>>0,f+c>>>0)):[],ends:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[],axes:M?Array.from(n().subarray(N>>>0,N+M>>>0)):[]})},922420:i=>{a.Ea("Tile",i,void 0)},922472:(i,c,f)=>{a.Ea("LayerNormalization",i,{axis:Number(c),epsilon:Number(f)})},922579:(i,c,f)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:f?"NHWC":"NCHW"})},922693:(i,c,f)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:f?"NHWC":"NCHW"})},922807:i=>{a.Ea("Range",i,void 0)},922860:(i,c)=>{a.Ea("Einsum",i,{equation:qe(c)})},922941:(i,c,f,$,T)=>{a.Ea("Pad",i,{mode:c,value:f,pads:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},923073:(i,c,f,$,T,M)=>{a.Ea("BatchNormalization",i,{epsilon:c,momentum:f,spatial:!!T,trainingMode:!!$,format:M?"NHWC":"NCHW"})},923242:(i,c,f,$,T,M)=>{a.Ea("BatchNormalization",i,{epsilon:c,momentum:f,spatial:!!T,trainingMode:!!$,format:M?"NHWC":"NCHW"})},923411:(i,c,f)=>{a.Ea("CumSum",i,{exclusive:Number(c),reverse:Number(f)})},923508:(i,c,f,$,T,M,N,ie,re)=>{a.Ea("Attention",i,{numHeads:c,isUnidirectional:f,maskFilterValue:$,scale:T,doRotary:M,qkvHiddenSizes:N?Array.from(n().subarray(Number(ie)>>>0,Number(ie)+N>>>0)):[],pastPresentShareBuffer:!!re})},923780:i=>{a.Ea("Gelu",i,void 0)},923832:(i,c,f,$,T,M)=>{a.Ea("MultiHeadAttention",i,{numHeads:c,isUnidirectional:f,maskFilterValue:$,scale:T,doRotary:M})},923991:i=>{a.Ea("BiasAdd",i,void 0)},924046:i=>{a.Ea("BiasSplitGelu",i,void 0)},924107:(i,c)=>{a.Ea("SkipLayerNormalization",i,{epsilon:c})},924188:(i,c,f,$,T,M,N,ie,re,oe,ue,xe,Ie)=>{a.Ea("Conv",i,{format:re?"NHWC":"NCHW",auto_pad:c,dilations:[f],group:$,kernel_shape:[T],pads:M?Array.from(n().subarray(N>>>0,N+M>>>0)):[],strides:[ie],w_is_const:()=>!!r()[oe>>>0],activation:qe(ue),activation_params:xe?Array.from(u().subarray(Ie>>>0,Ie+xe>>>0)):[]})},924569:(i,c,f,$,T,M,N,ie,re,oe,ue,xe,Ie,P,me,_e)=>{a.Ea("Conv",i,{format:xe?"NHWC":"NCHW",auto_pad:c,dilations:[f,$],group:T,kernel_shape:[M,N],pads:ie?Array.from(n().subarray(re>>>0,re+ie>>>0)):[],strides:[oe,ue],w_is_const:()=>!!r()[Ie>>>0],activation:qe(P),activation_params:me?Array.from(u().subarray(_e>>>0,_e+me>>>0)):[]})},924971:i=>{a.zb(i)},925005:(i,c)=>a.Ab(i,c,a.bb.Fb,a.bb.errors),925117:i=>a.wb(i),925150:i=>a.yb(i),925182:(i,c,f)=>{a.jb(i,c,f,!0)},925221:(i,c,f)=>{a.jb(i,c,f)}};function yt(i){this.name="ExitStatus",this.message=`Program terminated with exit(${i})`,this.status=i}function Bt(i){i.terminate(),i.onmessage=()=>{}}function Mt(i){(i=le.Qa[i])||tt(),le.Eb(i)}function qt(i){var c=le.tb();if(!c)return 6;le.Ya.push(c),le.Qa[i.Xa]=c,c.Xa=i.Xa;var f={cmd:"run",start_routine:i.Gb,arg:i.rb,pthread_ptr:i.Xa};return I&&c.unref(),c.postMessage(f,i.Mb),0}var Dt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,yr=(i,c,f)=>{c>>>=0;var $=c+f;for(f=c;i[f]&&!(f>=$);)++f;if(16<f-c&&i.buffer&&Dt)return Dt.decode(i.buffer instanceof SharedArrayBuffer?i.slice(c,f):i.subarray(c,f));for($="";c<f;){var T=i[c++];if(T&128){var M=i[c++]&63;if((T&224)==192)$+=String.fromCharCode((T&31)<<6|M);else{var N=i[c++]&63;T=(T&240)==224?(T&15)<<12|M<<6|N:(T&7)<<18|M<<12|N<<6|i[c++]&63,65536>T?$+=String.fromCharCode(T):(T-=65536,$+=String.fromCharCode(55296|T>>10,56320|T&1023))}}else $+=String.fromCharCode(T)}return $},qe=(i,c)=>(i>>>=0)?yr(o(),i,c):"";function jt(i){if(x)return H(1,1,i);fe=i,ot()||(le.Hb(),a.onExit&&a.onExit(i),Ce=!0),w(i,new yt(i))}var Kt=i=>{if(fe=i,x)throw br(i),"unwind";jt(i)},le={ab:[],Ya:[],mb:[],Qa:{},gb:function(){x?le.vb():le.ub()},ub:function(){Ze.unshift(()=>{Gt(),le.Bb(()=>hr())})},vb:function(){le.receiveObjectTransfer=le.Db,le.threadInitTLS=le.lb,le.setExitStatus=le.kb,J=!1},kb:function(i){fe=i},Sb:["$terminateWorker"],Hb:function(){for(var i of le.Ya)Bt(i);for(i of le.ab)Bt(i);le.ab=[],le.Ya=[],le.Qa=[]},Eb:function(i){var c=i.Xa;delete le.Qa[c],le.ab.push(i),le.Ya.splice(le.Ya.indexOf(i),1),i.Xa=0,dn(c)},Db:function(){},lb:function(){le.mb.forEach(i=>i())},Cb:i=>new Promise(c=>{i.onmessage=M=>{M=M.data;var N=M.cmd;if(M.targetThread&&M.targetThread!=Er()){var ie=le.Qa[M.Rb];ie?ie.postMessage(M,M.transferList):q(\'Internal error! Worker sent a message "\'+N+\'" to target pthread \'+M.targetThread+", but that thread no longer exists!")}else N==="checkMailbox"?At():N==="spawnThread"?qt(M):N==="cleanupThread"?Mt(M.thread):N==="killThread"?(M=M.thread,N=le.Qa[M],delete le.Qa[M],Bt(N),dn(M),le.Ya.splice(le.Ya.indexOf(N),1),N.Xa=0):N==="cancelThread"?le.Qa[M.thread].postMessage({cmd:"cancel"}):N==="loaded"?(i.loaded=!0,c(i)):N==="alert"?alert("Thread "+M.threadId+": "+M.text):M.target==="setimmediate"?i.postMessage(M):N==="callHandler"?a[M.handler](...M.args):N&&q("worker sent an unknown command "+N)},i.onerror=M=>{throw q("worker sent an error! "+M.filename+":"+M.lineno+": "+M.message),M},I&&(i.on("message",function(M){i.onmessage({data:M})}),i.on("error",function(M){i.onerror(M)}));var f=[],$=["onExit","onAbort","print","printErr"],T;for(T of $)a.hasOwnProperty(T)&&f.push(T);i.postMessage({cmd:"load",handlers:f,urlOrBlob:a.mainScriptUrlOrBlob||e,wasmMemory:we,wasmModule:ye})}),Bb:function(i){i()},qb:function(){var i=B("ort-wasm-simd-threaded.worker.js");i=new Worker(i),le.ab.push(i)},tb:function(){return le.ab.length==0&&(le.qb(),le.Cb(le.ab[0])),le.ab.pop()}};a.PThread=le;var ht=i=>{for(;0<i.length;)i.shift()(a)};a.establishStackSpace=function(){var i=Er(),c=n()[i+52>>2>>>0];i=n()[i+56>>2>>>0],co(c,c-i),Or(c)};function br(i){if(x)return H(2,0,i);Kt(i)}a.invokeEntryPoint=function(i,c){i=po.apply(null,[i,c]),ot()?le.kb(i):cn(i)};function at(i){this.fb=i-24,this.pb=function(c){s()[this.fb+4>>2>>>0]=c},this.ob=function(c){s()[this.fb+8>>2>>>0]=c},this.gb=function(c,f){this.nb(),this.pb(c),this.ob(f)},this.nb=function(){s()[this.fb+16>>2>>>0]=0}}var Je=0,wr=0;function _t(i,c,f,$){return x?H(3,1,i,c,f,$):Yt(i,c,f,$)}function Yt(i,c,f,$){if(i>>>=0,c>>>=0,f>>>=0,$>>>=0,typeof SharedArrayBuffer>"u")return q("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var T=[];return x&&T.length===0?_t(i,c,f,$):(i={Gb:f,Xa:i,rb:$,Mb:T},x?(i.Ob="spawnThread",postMessage(i,T),0):qt(i))}function Zt(i,c,f){return x?H(4,1,i,c,f):0}function vr(i,c){if(x)return H(5,1,i,c)}var It=i=>{for(var c=0,f=0;f<i.length;++f){var $=i.charCodeAt(f);127>=$?c++:2047>=$?c+=2:55296<=$&&57343>=$?(c+=4,++f):c+=3}return c},$r=(i,c,f,$)=>{if(f>>>=0,!(0<$))return 0;var T=f;$=f+$-1;for(var M=0;M<i.length;++M){var N=i.charCodeAt(M);if(55296<=N&&57343>=N){var ie=i.charCodeAt(++M);N=65536+((N&1023)<<10)|ie&1023}if(127>=N){if(f>=$)break;c[f++>>>0]=N}else{if(2047>=N){if(f+1>=$)break;c[f++>>>0]=192|N>>6}else{if(65535>=N){if(f+2>=$)break;c[f++>>>0]=224|N>>12}else{if(f+3>=$)break;c[f++>>>0]=240|N>>18,c[f++>>>0]=128|N>>12&63}c[f++>>>0]=128|N>>6&63}c[f++>>>0]=128|N&63}}return c[f>>>0]=0,f-T},Sr=(i,c,f)=>$r(i,o(),c,f);function xr(i,c){if(x)return H(6,1,i,c)}function Cr(i,c,f){if(x)return H(7,1,i,c,f)}function _r(i,c,f){return x?H(8,1,i,c,f):0}function Ir(i,c){if(x)return H(9,1,i,c)}function zt(i,c,f){if(x)return H(10,1,i,c,f)}function Xt(i,c,f,$){if(x)return H(11,1,i,c,f,$)}function Qt(i,c,f,$){if(x)return H(12,1,i,c,f,$)}function Jt(i,c,f,$){if(x)return H(13,1,i,c,f,$)}function er(i){if(x)return H(14,1,i)}function tr(i,c){if(x)return H(15,1,i,c)}function rr(i,c,f){if(x)return H(16,1,i,c,f)}var nr=i=>{if(!Ce)try{if(i(),!ot())try{x?cn(fe):Kt(fe)}catch(c){c instanceof yt||c=="unwind"||w(1,c)}}catch(c){c instanceof yt||c=="unwind"||w(1,c)}};function Vt(i){i>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(n(),i>>2,i).value.then(At),i+=128,Atomics.store(n(),i>>2,1))}a.__emscripten_thread_mailbox_await=Vt;function At(){var i=Er();i&&(Vt(i),nr(()=>uo()))}a.checkMailbox=At;var bt=i=>i%4===0&&(i%100!==0||i%400===0),Tt=[0,31,60,91,121,152,182,213,244,274,305,335],or=[0,31,59,90,120,151,181,212,243,273,304,334];function l(i,c,f,$,T,M,N,ie){return x?H(17,1,i,c,f,$,T,M,N,ie):-52}function m(i,c,f,$,T,M,N){if(x)return H(18,1,i,c,f,$,T,M,N)}var b=i=>{var c=It(i)+1,f=ln(c);return f&&Sr(i,f,c),f},C=[],O=(i,c)=>{C.length=0;var f;for(c>>=2;f=o()[i++>>>0];)c+=f!=105&c,C.push(f==105?n()[c>>>0]:d()[c++>>>1]),++c;return C},F=i=>{var c=pn();return i=i(),Or(c),i};function H(i,c){var f=arguments.length-2,$=arguments;return F(()=>{for(var T=mn(8*f),M=T>>3,N=0;N<f;N++){var ie=$[2+N];d()[M+N>>>0]=ie}return so(i,f,T,c)})}var de=[],X={},ae=()=>{if(!te){var i={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"},c;for(c in X)X[c]===void 0?delete i[c]:i[c]=X[c];var f=[];for(c in i)f.push(`${c}=${i[c]}`);te=f}return te},te;function ge(i,c){if(x)return H(19,1,i,c);i>>>=0,c>>>=0;var f=0;return ae().forEach(function($,T){var M=c+f;for(T=s()[i+4*T>>2>>>0]=M,M=0;M<$.length;++M)r()[T++>>0>>>0]=$.charCodeAt(M);r()[T>>0>>>0]=0,f+=$.length+1}),0}function Se(i,c){if(x)return H(20,1,i,c);i>>>=0,c>>>=0;var f=ae();s()[i>>2>>>0]=f.length;var $=0;return f.forEach(function(T){$+=T.length+1}),s()[c>>2>>>0]=$,0}function k(i){return x?H(21,1,i):52}function se(i,c,f,$){return x?H(22,1,i,c,f,$):52}function ve(i,c,f,$,T){return x?H(23,1,i,c,f,$,T):70}var gt=[null,[],[]];function ar(i,c,f,$){if(x)return H(24,1,i,c,f,$);c>>>=0,f>>>=0,$>>>=0;for(var T=0,M=0;M<f;M++){var N=s()[c>>2>>>0],ie=s()[c+4>>2>>>0];c+=8;for(var re=0;re<ie;re++){var oe=o()[N+re>>>0],ue=gt[i];oe===0||oe===10?((i===1?R:q)(yr(ue,0)),ue.length=0):ue.push(oe)}T+=ie}return s()[$>>2>>>0]=T,0}var Jn=[31,29,31,30,31,30,31,31,30,31,30,31],eo=[31,28,31,30,31,30,31,31,30,31,30,31];function Tu(i){var c=Array(It(i)+1);return $r(i,c,0,c.length),c}var Eu=(i,c)=>{r().set(i,c>>>0)};function to(i,c,f,$){function T(P,me,_e){for(P=typeof P=="number"?P.toString():P||"";P.length<me;)P=_e[0]+P;return P}function M(P,me){return T(P,me,"0")}function N(P,me){function _e(bo){return 0>bo?-1:0<bo?1:0}var Et;return(Et=_e(P.getFullYear()-me.getFullYear()))===0&&(Et=_e(P.getMonth()-me.getMonth()))===0&&(Et=_e(P.getDate()-me.getDate())),Et}function ie(P){switch(P.getDay()){case 0:return new Date(P.getFullYear()-1,11,29);case 1:return P;case 2:return new Date(P.getFullYear(),0,3);case 3:return new Date(P.getFullYear(),0,2);case 4:return new Date(P.getFullYear(),0,1);case 5:return new Date(P.getFullYear()-1,11,31);case 6:return new Date(P.getFullYear()-1,11,30)}}function re(P){var me=P.Za;for(P=new Date(new Date(P.$a+1900,0,1).getTime());0<me;){var _e=P.getMonth(),Et=(bt(P.getFullYear())?Jn:eo)[_e];if(me>Et-P.getDate())me-=Et-P.getDate()+1,P.setDate(1),11>_e?P.setMonth(_e+1):(P.setMonth(0),P.setFullYear(P.getFullYear()+1));else{P.setDate(P.getDate()+me);break}}return _e=new Date(P.getFullYear()+1,0,4),me=ie(new Date(P.getFullYear(),0,4)),_e=ie(_e),0>=N(me,P)?0>=N(_e,P)?P.getFullYear()+1:P.getFullYear():P.getFullYear()-1}i>>>=0,c>>>=0,f>>>=0,$>>>=0;var oe=n()[$+40>>2>>>0];$={Kb:n()[$>>2>>>0],Jb:n()[$+4>>2>>>0],cb:n()[$+8>>2>>>0],ib:n()[$+12>>2>>>0],eb:n()[$+16>>2>>>0],$a:n()[$+20>>2>>>0],Wa:n()[$+24>>2>>>0],Za:n()[$+28>>2>>>0],Tb:n()[$+32>>2>>>0],Ib:n()[$+36>>2>>>0],Lb:oe?qe(oe):""},f=qe(f),oe={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ue in oe)f=f.replace(new RegExp(ue,"g"),oe[ue]);var xe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ie="January February March April May June July August September October November December".split(" ");oe={"%a":P=>xe[P.Wa].substring(0,3),"%A":P=>xe[P.Wa],"%b":P=>Ie[P.eb].substring(0,3),"%B":P=>Ie[P.eb],"%C":P=>M((P.$a+1900)/100|0,2),"%d":P=>M(P.ib,2),"%e":P=>T(P.ib,2," "),"%g":P=>re(P).toString().substring(2),"%G":P=>re(P),"%H":P=>M(P.cb,2),"%I":P=>(P=P.cb,P==0?P=12:12<P&&(P-=12),M(P,2)),"%j":P=>{for(var me=0,_e=0;_e<=P.eb-1;me+=(bt(P.$a+1900)?Jn:eo)[_e++]);return M(P.ib+me,3)},"%m":P=>M(P.eb+1,2),"%M":P=>M(P.Jb,2),"%n":()=>`\n`,"%p":P=>0<=P.cb&&12>P.cb?"AM":"PM","%S":P=>M(P.Kb,2),"%t":()=>"	","%u":P=>P.Wa||7,"%U":P=>M(Math.floor((P.Za+7-P.Wa)/7),2),"%V":P=>{var me=Math.floor((P.Za+7-(P.Wa+6)%7)/7);if(2>=(P.Wa+371-P.Za-2)%7&&me++,me)me==53&&(_e=(P.Wa+371-P.Za)%7,_e==4||_e==3&&bt(P.$a)||(me=1));else{me=52;var _e=(P.Wa+7-P.Za-1)%7;(_e==4||_e==5&&bt(P.$a%400-1))&&me++}return M(me,2)},"%w":P=>P.Wa,"%W":P=>M(Math.floor((P.Za+7-(P.Wa+6)%7)/7),2),"%y":P=>(P.$a+1900).toString().substring(2),"%Y":P=>P.$a+1900,"%z":P=>{P=P.Ib;var me=0<=P;return P=Math.abs(P)/60,(me?"+":"-")+("0000"+(P/60*100+P%60)).slice(-4)},"%Z":P=>P.Lb,"%%":()=>"%"},f=f.replace(/%%/g,"\\0\\0");for(ue in oe)f.includes(ue)&&(f=f.replace(new RegExp(ue,"g"),oe[ue]($)));return f=f.replace(/\\0\\0/g,"%"),ue=Tu(f),ue.length>c?0:(Eu(ue,i),ue.length-1)}function Ar(i){try{i()}catch(c){tt(c)}}function Ou(i){var c={},f;for(f in i)(function($){var T=i[$];c[$]=typeof T=="function"?function(){Tr.push($);try{return T.apply(null,arguments)}finally{Ce||(Tr.pop()===$||tt(),it&&wt===1&&Tr.length===0&&(wt=0,Ke+=1,Ar(fo),typeof Fibers<"u"&&Fibers.Ub()))}}:T})(f);return c}var wt=0,it=null,ro=0,Tr=[],no={},oo={},ku=0,un=null,Pu=[];function Ru(){return new Promise((i,c)=>{un={resolve:i,reject:c}})}function Bu(){var i=ln(65548),c=i+12;s()[i>>2>>>0]=c,s()[i+4>>2>>>0]=c+65536,c=Tr[0];var f=no[c];return f===void 0&&(f=ku++,no[c]=f,oo[f]=c),c=f,n()[i+8>>2>>>0]=c,i}function Mu(){var i=n()[it+8>>2>>>0];return i=Z[oo[i]],--Ke,i()}function Du(i){if(!Ce){if(wt===0){var c=!1,f=!1;i(($=0)=>{if(!Ce&&(ro=$,c=!0,f)){wt=2,Ar(()=>ho(it)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),$=!1;try{var T=Mu()}catch(ie){T=ie,$=!0}var M=!1;if(!it){var N=un;N&&(un=null,($?N.reject:N.resolve)(T),M=!0)}if($&&!M)throw T}}),f=!0,c||(wt=1,it=Bu(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),Ar(()=>mo(it)))}else wt===2?(wt=0,Ar(go),ao(it),it=null,Pu.forEach($=>nr($))):tt(`invalid state: ${wt}`);return ro}}function zu(i){return Du(c=>{i().then(c)})}le.gb();var Vu=[null,jt,br,_t,Zt,vr,xr,Cr,_r,Ir,zt,Xt,Qt,Jt,er,tr,rr,l,m,ge,Se,k,se,ve,ar],Wu={r:function(i,c,f){return zu(async()=>{await a.xb(i,c,f)})},b:function(i,c,f){throw i>>>=0,new at(i).gb(c>>>0,f>>>0),Je=i,wr++,Je},O:function(i){io(i>>>0,!S,1,!y,131072,!1),le.lb()},l:function(i){i>>>=0,x?postMessage({cmd:"cleanupThread",thread:i}):Mt(i)},I:Yt,i:Zt,U:vr,E:xr,G:Cr,V:_r,S:Ir,K:zt,R:Xt,p:Qt,F:Jt,C:er,T:tr,D:rr,q:()=>!0,A:function(i,c){i>>>=0,i==c>>>0?setTimeout(()=>At()):x?postMessage({targetThread:i,cmd:"checkMailbox"}):(i=le.Qa[i])&&i.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:Vt,X:function(i){I&&le.Qa[i>>>0].ref()},u:function(i,c,f){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,f>>>=0,i=new Date(1e3*i),n()[f>>2>>>0]=i.getUTCSeconds(),n()[f+4>>2>>>0]=i.getUTCMinutes(),n()[f+8>>2>>>0]=i.getUTCHours(),n()[f+12>>2>>>0]=i.getUTCDate(),n()[f+16>>2>>>0]=i.getUTCMonth(),n()[f+20>>2>>>0]=i.getUTCFullYear()-1900,n()[f+24>>2>>>0]=i.getUTCDay(),i=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,n()[f+28>>2>>>0]=i},v:function(i,c,f){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,f>>>=0,i=new Date(1e3*i),n()[f>>2>>>0]=i.getSeconds(),n()[f+4>>2>>>0]=i.getMinutes(),n()[f+8>>2>>>0]=i.getHours(),n()[f+12>>2>>>0]=i.getDate(),n()[f+16>>2>>>0]=i.getMonth(),n()[f+20>>2>>>0]=i.getFullYear()-1900,n()[f+24>>2>>>0]=i.getDay(),c=(bt(i.getFullYear())?Tt:or)[i.getMonth()]+i.getDate()-1|0,n()[f+28>>2>>>0]=c,n()[f+36>>2>>>0]=-(60*i.getTimezoneOffset()),c=new Date(i.getFullYear(),6,1).getTimezoneOffset();var $=new Date(i.getFullYear(),0,1).getTimezoneOffset();i=(c!=$&&i.getTimezoneOffset()==Math.min($,c))|0,n()[f+32>>2>>>0]=i},w:function(i){i>>>=0;var c=new Date(n()[i+20>>2>>>0]+1900,n()[i+16>>2>>>0],n()[i+12>>2>>>0],n()[i+8>>2>>>0],n()[i+4>>2>>>0],n()[i>>2>>>0],0),f=n()[i+32>>2>>>0],$=c.getTimezoneOffset(),T=new Date(c.getFullYear(),6,1).getTimezoneOffset(),M=new Date(c.getFullYear(),0,1).getTimezoneOffset(),N=Math.min(M,T);return 0>f?n()[i+32>>2>>>0]=+(T!=M&&N==$):0<f!=(N==$)&&(T=Math.max(M,T),c.setTime(c.getTime()+6e4*((0<f?N:T)-$))),n()[i+24>>2>>>0]=c.getDay(),f=(bt(c.getFullYear())?Tt:or)[c.getMonth()]+c.getDate()-1|0,n()[i+28>>2>>>0]=f,n()[i>>2>>>0]=c.getSeconds(),n()[i+4>>2>>>0]=c.getMinutes(),n()[i+8>>2>>>0]=c.getHours(),n()[i+12>>2>>>0]=c.getDate(),n()[i+16>>2>>>0]=c.getMonth(),n()[i+20>>2>>>0]=c.getYear(),i=c.getTime()/1e3,lo((ft=i,1<=+Math.abs(ft)?0<ft?+Math.floor(ft/4294967296)>>>0:~~+Math.ceil((ft-+(~~ft>>>0))/4294967296)>>>0:0)),i>>>0},s:l,t:m,z:function(i,c,f){function $(oe){return(oe=oe.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?oe[1]:"GMT"}i>>>=0,c>>>=0,f>>>=0;var T=new Date().getFullYear(),M=new Date(T,0,1),N=new Date(T,6,1);T=M.getTimezoneOffset();var ie=N.getTimezoneOffset(),re=Math.max(T,ie);s()[i>>2>>>0]=60*re,n()[c>>2>>>0]=+(T!=ie),i=$(M),c=$(N),i=b(i),c=b(c),ie<T?(s()[f>>2>>>0]=i,s()[f+4>>2>>>0]=c):(s()[f>>2>>>0]=c,s()[f+4>>2>>>0]=i)},d:()=>{tt("")},c:function(i,c,f){return i>>>=0,c=O(c>>>0,f>>>0),Rt[i].apply(null,c)},k:function(i,c,f){return i>>>=0,c=O(c>>>0,f>>>0),Rt[i].apply(null,c)},m:function(){},j:function(){return Date.now()},W:()=>{throw Ke+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return I?(_o(),Wt(Co)).cpus().length:navigator.hardwareConcurrency},L:function(i,c,f,$){for(le.Pb=c>>>0,de.length=f,c=$>>>0>>3,$=0;$<f;$++)de[$]=d()[c+$>>>0];return(0>i?Rt[-i-1]:Vu[i]).apply(null,de)},y:function(i){i>>>=0;var c=o().length;if(i<=c||4294901760<i)return!1;for(var f=1;4>=f;f*=2){var $=c*(1+.2/f);$=Math.min($,i+100663296);var T=Math;$=Math.max(i,$);e:{T=T.min.call(T,4294901760,$+(65536-$%65536)%65536)-we.buffer.byteLength+65535>>>16;try{we.grow(T),he();var M=1;break e}catch{}M=void 0}if(M)return!0}return!1},P:ge,Q:Se,H:Kt,h:k,o:se,x:ve,n:ar,a:we||a.wasmMemory,J:to,e:function(i,c,f,$){return to(i>>>0,c>>>0,f>>>0,$>>>0)}};(function(){function i(f,$){return f=f.exports,f=Ou(f),Z=f=Uu(f),le.mb.push(Z.Da),Me.unshift(Z.Y),ye=$,hr(),f}var c={a:Wu};if(Gt(),a.instantiateWasm)try{return a.instantiateWasm(c,i)}catch(f){q("Module.instantiateWasm callback failed with error: "+f),h(f)}return gr(c,function(f){i(f.instance,f.module)}).catch(h),{}})(),a._OrtInit=(i,c)=>(a._OrtInit=Z.Z)(i,c),a._OrtGetLastError=(i,c)=>(a._OrtGetLastError=Z._)(i,c),a._OrtCreateSessionOptions=(i,c,f,$,T,M,N,ie,re,oe)=>(a._OrtCreateSessionOptions=Z.$)(i,c,f,$,T,M,N,ie,re,oe),a._OrtAppendExecutionProvider=(i,c)=>(a._OrtAppendExecutionProvider=Z.aa)(i,c),a._OrtAddFreeDimensionOverride=(i,c,f)=>(a._OrtAddFreeDimensionOverride=Z.ba)(i,c,f),a._OrtAddSessionConfigEntry=(i,c,f)=>(a._OrtAddSessionConfigEntry=Z.ca)(i,c,f),a._OrtReleaseSessionOptions=i=>(a._OrtReleaseSessionOptions=Z.da)(i),a._OrtCreateSession=(i,c,f)=>(a._OrtCreateSession=Z.ea)(i,c,f),a._OrtReleaseSession=i=>(a._OrtReleaseSession=Z.fa)(i),a._OrtGetInputOutputCount=(i,c,f)=>(a._OrtGetInputOutputCount=Z.ga)(i,c,f),a._OrtGetInputName=(i,c)=>(a._OrtGetInputName=Z.ha)(i,c),a._OrtGetOutputName=(i,c)=>(a._OrtGetOutputName=Z.ia)(i,c),a._OrtFree=i=>(a._OrtFree=Z.ja)(i),a._OrtCreateTensor=(i,c,f,$,T,M)=>(a._OrtCreateTensor=Z.ka)(i,c,f,$,T,M),a._OrtGetTensorData=(i,c,f,$,T)=>(a._OrtGetTensorData=Z.la)(i,c,f,$,T),a._OrtReleaseTensor=i=>(a._OrtReleaseTensor=Z.ma)(i),a._OrtCreateRunOptions=(i,c,f,$)=>(a._OrtCreateRunOptions=Z.na)(i,c,f,$),a._OrtAddRunConfigEntry=(i,c,f)=>(a._OrtAddRunConfigEntry=Z.oa)(i,c,f),a._OrtReleaseRunOptions=i=>(a._OrtReleaseRunOptions=Z.pa)(i),a._OrtCreateBinding=i=>(a._OrtCreateBinding=Z.qa)(i),a._OrtBindInput=(i,c,f)=>(a._OrtBindInput=Z.ra)(i,c,f),a._OrtBindOutput=(i,c,f,$)=>(a._OrtBindOutput=Z.sa)(i,c,f,$),a._OrtClearBoundOutputs=i=>(a._OrtClearBoundOutputs=Z.ta)(i),a._OrtReleaseBinding=i=>(a._OrtReleaseBinding=Z.ua)(i),a._OrtRunWithBinding=(i,c,f,$,T)=>(a._OrtRunWithBinding=Z.va)(i,c,f,$,T),a._OrtRun=(i,c,f,$,T,M,N,ie)=>(a._OrtRun=Z.wa)(i,c,f,$,T,M,N,ie),a._OrtEndProfiling=i=>(a._OrtEndProfiling=Z.xa)(i),a._JsepOutput=(i,c,f)=>(a._JsepOutput=Z.ya)(i,c,f),a._JsepGetNodeName=i=>(a._JsepGetNodeName=Z.za)(i);var Er=a._pthread_self=()=>(Er=a._pthread_self=Z.Aa)(),ln=a._malloc=i=>(ln=a._malloc=Z.Ba)(i),ao=a._free=i=>(ao=a._free=Z.Ca)(i);a.__emscripten_tls_init=()=>(a.__emscripten_tls_init=Z.Da)();var io=a.__emscripten_thread_init=(i,c,f,$,T,M)=>(io=a.__emscripten_thread_init=Z.Fa)(i,c,f,$,T,M);a.__emscripten_thread_crashed=()=>(a.__emscripten_thread_crashed=Z.Ga)();var so=(i,c,f,$)=>(so=Z.Ha)(i,c,f,$),dn=i=>(dn=Z.Ia)(i),cn=a.__emscripten_thread_exit=i=>(cn=a.__emscripten_thread_exit=Z.Ja)(i),uo=a.__emscripten_check_mailbox=()=>(uo=a.__emscripten_check_mailbox=Z.Ka)(),lo=i=>(lo=Z.La)(i),co=(i,c)=>(co=Z.Ma)(i,c),pn=()=>(pn=Z.Na)(),Or=i=>(Or=Z.Oa)(i),mn=i=>(mn=Z.Pa)(i),po=a.dynCall_ii=(i,c)=>(po=a.dynCall_ii=Z.Ra)(i,c),mo=i=>(mo=Z.Sa)(i),fo=()=>(fo=Z.Ta)(),ho=i=>(ho=Z.Ua)(i),go=()=>(go=Z.Va)();a.___start_em_js=925254,a.___stop_em_js=925415;function Uu(i){i=Object.assign({},i);var c=$=>()=>$()>>>0,f=$=>T=>$(T)>>>0;return i.__errno_location=c(i.__errno_location),i.pthread_self=c(i.pthread_self),i.malloc=f(i.malloc),i.stackSave=c(i.stackSave),i.stackAlloc=f(i.stackAlloc),i}a.keepRuntimeAlive=ot,a.wasmMemory=we,a.stackAlloc=mn,a.stackSave=pn,a.stackRestore=Or,a.UTF8ToString=qe,a.stringToUTF8=Sr,a.lengthBytesUTF8=It,a.ExitStatus=yt,a.PThread=le;var kr;Ct=function i(){kr||yo(),kr||(Ct=i)};function yo(){function i(){if(!kr&&(kr=!0,a.calledRun=!0,!Ce)&&(x||ht(Me),p(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),!x)){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;){var c=a.postRun.shift();Ge.unshift(c)}ht(Ge)}}if(!(0<Qe))if(x)p(a),x||ht(Me),startWorker(a);else{if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)Ze.unshift(a.preRun.shift());ht(Ze),0<Qe||(a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),i()},1)):i())}}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return yo(),t.ready}})();typeof Ao=="object"&&typeof vn=="object"?vn.exports=Io:typeof define=="function"&&define.amd&&define([],()=>Io)});var Eo=ir((Gc,Ku)=>{Ku.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\\n\'});var xn,Ot,ur,Br,lr,Mo,Cn,Ue=Y(()=>{"use strict";xn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Ot=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},ur=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Br=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},lr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Mo=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",Cn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var nl,ol,Do,zo,Vo,al,Re,vt=Y(()=>{"use strict";Ue();nl=["V","I","W","E","F"],ol=(e,t)=>{console.log(`[${nl[e]},${new Date().toISOString()}]${t}`)},Vo=(e,t)=>{Do=e,zo=t},al=(e,t)=>{let r=lr(e),o=lr(Do);r>=o&&ol(r,typeof t=="function"?t():t)},Re=(...e)=>{zo&&al(...e)}});var Wo,Uo=Y(()=>{"use strict";Ue();Wo=(e,t)=>new(Br(t))(e)});var Mr=Y(()=>{"use strict"});var Dr,il,No,In,_n,Go,Lo=Y(()=>{"use strict";vt();Mr();Dr=e=>Math.ceil(e/16)*16,il=1,No=()=>il++,In=async(e,t,r,o)=>{let n=Dr(r),s=e.device.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=e.getCommandEncoder();e.endComputePass(),u.copyBufferToBuffer(t,0,s,0,n),e.flush(),await s.mapAsync(GPUMapMode.READ);let d=s.getMappedRange();if(o){let a=o();return a.set(new Uint8Array(d,0,r)),a}else return new Uint8Array(d.slice(0,r))}finally{s.destroy()}},_n=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let o=r.buffer,n=r.byteOffset,s=r.byteLength,u=Dr(s),d=this.storageCache.get(t);if(!d)throw new Error("gpu data for uploading does not exist");if(d.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${d.originalSize}, data size=${s}`);let a=this.backend.device.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),p=a.getMappedRange();new Uint8Array(p).set(new Uint8Array(o,n,s)),a.unmap();let h=this.backend.getCommandEncoder();this.backend.endComputePass(),h.copyBufferToBuffer(a,0,d.gpuData.buffer,0,u),Re("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(a)}memcpy(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("source gpu data for memcpy does not exist");let n=this.storageCache.get(r);if(!n)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==n.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=Dr(o.originalSize),u=this.backend.getCommandEncoder();this.backend.endComputePass(),u.copyBufferToBuffer(o.gpuData.buffer,0,n.gpuData.buffer,0,s)}registerExternalBuffer(t,r,o){let n;if(o){if(n=this.externalBuffers.get(o),n===void 0)throw new Error("previous buffer is not registered");if(t===o)return Re("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, buffer is the same, skip.`),n;this.externalBuffers.delete(o)}else n=No();return this.storageCache.set(n,{gpuData:{id:n,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,n),Re("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, registered.`),n}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Re("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=Dr(t),n,s=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,u=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||u){let a=s?this.freeBuffers:this.freeUniformBuffers,p=a.get(o);p||(p=[],a.set(o,p)),p.length>0?n=p.pop():n=this.backend.device.createBuffer({size:o,usage:r})}else n=this.backend.device.createBuffer({size:o,usage:r});let d={id:No(),type:0,buffer:n};return this.storageCache.set(d.id,{gpuData:d,originalSize:t}),Re("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${d.id}`),d}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Re("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("data does not exist");await In(this.backend,o.gpuData.buffer,o.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},Go=(...e)=>new _n(...e)});var An,ee,ke=Y(()=>{"use strict";An=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},ee=e=>new An(e)});var Tn,st,D,kt,zr,Vr,Wr,$e=Y(()=>{"use strict";Tn=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},st=class{static calcShape(t,r,o=!1){let n=t.length,s=r.length;if(n===0)return r;if(s===0)return t;let u=Math.max(t.length,r.length),d=new Array(u);if(o){if(n<2||s<2)return;let a=Tn.calcMatMulShape([t[n-2],t[n-1]],[r[s-2],r[s-1]]);if(a===void 0)return;[d[u-2],d[u-1]]=a}for(let a=o?3:1;a<=u;a++){let p=n-a<0?1:t[n-a],h=s-a<0?1:r[s-a];if(p!==h&&p>1&&h>1)return;d[u-a]=Math.max(p,h)}return d}static isValidBroadcast(t,r){let o=t.length,n=r.length;if(o>n)return!1;for(let s=1;s<=o;s++)if(t[o-s]!==1&&t[o-s]!==r[n-s])return!1;return!0}},D=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,o){let n=1;for(let s=r;s<o;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");n*=t[s]}return n}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let o=new Array(r);o[r-1]=1,o[r-2]=t[r-1];for(let n=r-3;n>=0;--n)o[n]=o[n+1]*t[n+1];return o}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(o=>this.normalizeAxis(o,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(o=>t[o]):t.slice().reverse()}static padShape(t,r){let o=t.length;return t.map((n,s)=>n+r[s]+r[s+o])}static areEqual(t,r){return t.length!==r.length?!1:t.every((o,n)=>o===r[n])}},kt=class e{static adjustPoolAttributes(t,r,o,n,s,u){if(!t&&o.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let d=0;d<r.length-2;d++)d>=o.length?o.push(r[d+2]):o[d]=r[d+2];for(let d=0;d<o.length;d++)if(d<n.length){if(n[d]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let d=0;d<o.length;d++)if(d<s.length){if(s[d]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let d=0;d<o.length*2;d++)if(d<u.length){if(u[d]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let d=0;d<o.length;d++){if(o[d]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[d]>=o[d]||u[d+o.length]>=o[d])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,o,n,s,u,d){if(d){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<t.length-2;a++)e.adjustPadAndReturnShape(t[a+(u?1:2)],r[a],o[a],n[a],s,a,a+t.length-2,d)}}static computePoolOutputShape(t,r,o,n,s,u,d){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let a=[r[0],r[1]];return e.computeShapeHelper(t,r,a,o,n,s,u,d),a}static computeConvOutputShape(t,r,o,n,s,u,d){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let a=[t[0],r[0]];return e.computeShapeHelper(!1,t,a,o,n,s,u,d),a}static computeShapeHelper(t,r,o,n,s,u,d,a){if(t)for(let p=0;p<r.length-2;p++)o.push(1);else for(let p=0;p<r.length-2;p++)o.push(e.adjustPadAndReturnShape(r[p+2],n[p],s[p],u[p],d,p,p+r.length-2,a))}static adjustPadAndReturnShape(t,r,o,n,s,u,d,a){let p=o*(n-1)+1;if(a&&a!=="NOTSET")switch(a){case"VALID":return s[u]=0,s[d]=0,Math.floor((t-p)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let v=((t+r-1)/r-1)*r+n-t;return s[u]=Math.floor(a==="SAME_LOWER"?(v+1)/2:v/2),s[d]=v-s[u],Math.floor((t+v-n)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[u]+s[d]-p)/r+1)}},zr=class{static getShapeOfGemmResult(t,r,o,n,s){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let u,d,a;r?(u=t[1],d=t[0]):(u=t[0],d=t[1]);let p=-1;if(n?(a=o[0],p=1):(a=o[1],p=0),o[p]!==d)throw new Error("dimension mismatch");if(u<=0||a<=0||d<=0)throw new Error("invalid shape specified");if(s&&!st.isValidBroadcast(s,[u,a]))throw new Error("gemm: invalid bias shape for broadcast");return[u,a,d]}},Vr=-34028234663852886e22,Wr=34028234663852886e22});var sl,On,Oe,$t,j,ze,je,rt,Xe,Ae,kn,W,K,Ur,En,Fo,Ut,Pe,be=Y(()=>{"use strict";Ue();$e();sl=64,On=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Oe=(e,t=1)=>{let r=On(e,t);return typeof r=="string"?r:r[0]},$t=(e,t=1)=>{let r=On(e,t);return typeof r=="string"?r:r[1]},j=e=>e.length===0?[]:[{type:"uint32",data:e},{type:"uint32",data:D.computeStrides(e)}],ze=e=>e%4===0?4:e%2===0?2:1,je=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,rt=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,Xe=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,Ae=(e,t,r)=>e.startsWith("uniforms.")&&r>4?typeof t=="string"?`${e}[(${t}) / 4][(${t}) % 4]`:`${e}[${Math.floor(t/4)}][${t%4}]`:r>1?`${e}[${t}]`:e,kn=(e,t,r,o,n)=>{let s=typeof r=="number",u=s?r:r.length,d=[...new Array(u).keys()],a=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,p=On(t,n),h=typeof p=="string"?p:p[1],v=typeof p=="string"?p:p[0],g={indices:a,value:h,storage:v,tensor:t},w=L=>typeof L=="string"?L:`${L}u`,y={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},S=s?"uniforms.":"",I=`${S}${e}_shape`,x=`${S}${e}_strides`,_="";for(let L=0;L<u-1;L++)_+=`\n    let dim${L} = current / ${Ae(x,L,u)};\n    let rest${L} = current % ${Ae(x,L,u)};\n    indices[${L}] = dim${L};\n    current = rest${L};\n    `;_+=`indices[${u-1}] = current;`;let B=u<2?"":`\n  fn o2i_${e}(offset: u32) -> ${g.indices} {\n    var indices: ${g.indices};\n    var current = offset;\n    ${_}\n    return indices;\n  }`,E=L=>(y.offsetToIndices=!0,u<2?L:`o2i_${e}(${L})`),z=[];if(u>=2)for(let L=u-1;L>=0;L--)z.push(`${Ae(x,L,u)} * (indices[${L}])`);let A=u<2?"":`\n  fn i2o_${e}(indices: ${g.indices}) -> u32 {\n    return ${z.join("+")};\n  }`,U=L=>(y.indicesToOffset=!0,u<2?L:`i2o_${e}(${L})`),V=(...L)=>u===0?"0u":`${g.indices}(${L.map(w).join(",")})`,G=(L,ne)=>u<2?`${L}`:`${Ae(L,ne,u)}`,Q=(L,ne,he)=>u<2?`${L}=${he};`:`${Ae(L,ne,u)}=${he};`,R={},q=(L,ne)=>{y.broadcastedIndicesToOffset=!0;let he=`${ne.name}broadcastedIndicesTo${e}Offset`;if(he in R)return`${he}(${L})`;let Fe=[];for(let Ze=u-1;Ze>=0;Ze--){let Me=ne.indicesGet("outputIndices",Ze+ne.rank-u);Fe.push(`${G(x,Ze)} * (${Me} % ${G(I,Ze)})`)}return R[he]=`fn ${he}(outputIndices: ${ne.type.indices}) -> u32 {\n             return ${Fe.length>0?Fe.join("+"):"0u"};\n           }`,`${he}(${L})`},pe=(L,ne)=>(()=>{if(g.storage===g.value)return`${e}[${L}]=${ne};`;if(g.storage==="vec2<u32>"&&g.value==="i32")return`${e}[${L}]=vec2<u32>(u32(${ne}), select(0u, 0xFFFFFFFFu, ${ne} < 0));`;if(g.storage==="vec2<u32>"&&g.value==="u32")return`${e}[${L}]=vec2<u32>(u32(${ne}), 0u);`;if(g.storage==="u32"&&g.value==="vec4<bool>")return`${e}[${L}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${ne}));`;throw new Error(`not supported combination of storage type ${g.storage} and value type ${g.value} yet`)})(),J=L=>(()=>{if(g.storage===g.value)return`${e}[${L}]`;if(g.storage==="vec2<u32>"&&g.value==="i32")return`i32(${e}[${L}].x)`;if(g.storage==="vec2<u32>"&&g.value==="u32")return`u32(${e}[${L}].x)`;if(g.storage==="u32"&&g.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${L}] & 0xFFu), bool(${e}[${L}] & 0xFF00u), bool(${e}[${L}] & 0xFF0000u), bool(${e}[${L}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${g.storage} and value type ${g.value} yet`)})(),we=u<2?"":`\n  fn get_${e}ByIndices(indices: ${g.indices}) -> ${h} {\n    return ${J(`i2o_${e}(indices)`)};\n  }`,Z=u<2?"":(()=>{let L=d.map(he=>`d${he}: u32`).join(", "),ne=d.map(he=>`d${he}`).join(", ");return`\n  fn get_${e}(${L}) -> ${h} {\n    return get_${e}ByIndices(${V(ne)});\n  }`})(),ye=(...L)=>{if(L.length!==u)throw new Error(`indices length must be ${u}`);let ne=L.map(w).join(",");return u===0?J("0u"):u===1?J(ne[0]):(y.get=!0,y.getByIndices=!0,y.indicesToOffset=!0,`get_${e}(${ne})`)},Ce=L=>u<2?J(L):(y.getByIndices=!0,y.indicesToOffset=!0,`get_${e}ByIndices(${L})`),fe=u<2?"":`\n  fn set_${e}ByIndices(indices: ${g.indices}, value: ${h}) {\n    ${pe(`i2o_${e}(indices)`,"value")}\n  }`,ce=u<2?"":(()=>{let L=d.map(he=>`d${he}: u32`).join(", "),ne=d.map(he=>`d${he}`).join(", ");return`\n  fn set_${e}(${L}, value: ${h}) {\n    set_${e}ByIndices(${V(ne)}, value);\n  }`})();return{impl:()=>{let L=[];return s||(L.push(`const ${I} = ${g.indices}(${r.join(",")});`),L.push(`const ${x} = ${g.indices}(${D.computeStrides(r).join(",")});`)),y.offsetToIndices&&L.push(B),y.indicesToOffset&&L.push(A),y.broadcastedIndicesToOffset&&Object.values(R).forEach(ne=>L.push(ne)),y.set&&L.push(ce),y.setByIndices&&L.push(fe),y.get&&L.push(Z),y.getByIndices&&L.push(we),L.join(`\n`)},type:g,offsetToIndices:E,indicesToOffset:U,broadcastedIndicesToOffset:q,indices:V,indicesGet:G,indicesSet:Q,set:(...L)=>{if(L.length!==u+1)throw new Error(`indices length must be ${u}`);let ne=L[u];if(typeof ne!="string")throw new Error("value must be string");let he=L.slice(0,u).map(w).join(",");return u===0?pe("0u",ne):u===1?pe(he[0],ne):(y.set=!0,y.setByIndices=!0,y.indicesToOffset=!0,`set_${e}(${he}, ${ne})`)},setByOffset:pe,setByIndices:(L,ne)=>u<2?pe(L,ne):(y.setByIndices=!0,y.indicesToOffset=!0,`set_${e}ByIndices(${L}, ${ne});`),get:ye,getByOffset:J,getByIndices:Ce,usage:o,name:e,strides:x,shape:I,rank:u}},W=(e,t,r,o=1)=>kn(e,t,r,"input",o),K=(e,t,r,o=1)=>kn(e,t,r,"output",o),Ur=(e,t,r,o=1)=>kn(e,t,r,"internal",o),En=class{constructor(t){this.normalizedDispatchGroup=t;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=sl){let r=typeof t=="number"?t:t[0],o=typeof t=="number"?1:t[1],n=typeof t=="number"?1:t[2],s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,u=s?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,d=s?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${r*o*n}u + local_index;`;return`@compute @workgroup_size(${r}, ${o}, ${n})\n  fn main(${u}) {\n    ${d}\n  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:"u32",length:t.rank}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:"u32",length:t.rank}))}declareVariable(t,r){if(t.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(t),this.appendVariableUniforms(t);let o=t.usage==="input"?"read":"read_write",n=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${o}> ${t.name}: array<${n}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerInternalVariable(t){if(t.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(r=>this.registerInternalVariable(r)),this}registerUniform(t,r,o=1){return this.uniforms.push({name:t,type:r,length:o}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:o,length:n}of this.uniforms)if(n&&n>4)t.push(`${r}:array<vec4<${o}>, ${Math.ceil(n/4)}>`);else{let s=n==null||n===1?o:`vec${n}<${o}>`;t.push(`${r}:${s}`)}return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`\n`)+this.internalVariables.map(t=>t.impl()).join(`\n`)}},Fo=e=>new En(e),Ut=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;n++){let s=r-1-n,u=e[s]||1;(t[t.length-1-n]||1)>1&&u===1&&o.unshift(s)}return o},Pe=e=>!0});var ul,qo,ll,dl,et,jo,Ko,Nt=Y(()=>{"use strict";$e();ke();be();ul=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},qo=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,ll=(e,t)=>D.sortBasedOnPerm(e,qo(e.length,t)),dl=(e,t,r,o)=>{let n=[];n.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let s=0;s<t;++s)n.push(r.indicesSet("a",e[s],`i[${s}]`));return n.push("return a;}"),n.join(`\n`)},et=(e,t)=>{let r=e.dataType,o=e.dims.length,n=qo(o,t),s=Pe(o),u=ll(e.dims,n),d=s?u.length:u,a=s?o:e.dims,p=K("output",r,d),h=W("a",r,a),v=g=>`\n  ${g.registerUniform("output_size","u32").declareVariables(h,p)}\n\n  ${dl(n,o,h,p)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${p.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${p.setByOffset("global_idx",h.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:s?["rank"]:["dims"]},getRunData:g=>{let w=D.size(u);return{outputs:[{dims:u,dataType:g[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:s?[{type:"uint32",data:w},...j(g[0].dims),...j(u)]:[{type:"uint32",data:w}]}},getShaderSource:v}},jo=(e,t)=>{ul(e.inputs),e.compute(et(e.inputs[0],t.perm))},Ko=e=>ee({perm:e.perm})});var cl,pl,ml,fl,hl,gl,yl,bl,wl,vl,ut,Yo,Zo,Xo,Qo,Jo,ea,ta,ra,na,oa,aa=Y(()=>{"use strict";$e();be();Nr();Nt();cl={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},pl={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},ml={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},fl={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},hl=(e,t)=>{let r=[];for(let o=t-e;o<t;++o)r.push(o);return r},gl=(e,t)=>{let r=[],o=e.length;for(let s=0;s<o;s++)t.indexOf(s)===-1&&r.push(e[s]);let n=t.map(s=>e[s]);return[r,n]},yl=(e,t)=>{let r=e.length+t.length,o=[],n=0;for(let s=0;s<r;s++)t.indexOf(s)===-1?o.push(e[n++]):o.push(1);return o},bl=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},wl=(e,t)=>{let r=[];if(!bl(e,t)){for(let o=0;o<t;++o)e.indexOf(o)===-1&&r.push(o);e.forEach(o=>r.push(o))}return r},vl=(e,t,r,o,n,s,u)=>{let d=r[0].dims,a=D.size(s),p=D.size(u),h=W("_A",r[0].dataType,d),v=K("output",n,s),g=32,w=`\n          var<workgroup> aBestValues : array<${v.type.storage}, ${g}>;\n       `;return{name:e,shaderCache:t,getShaderSource:S=>`\n        ${S.registerUniform("reduceSize","u32").declareVariables(h,v)}\n        ${w}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${S.mainStart(g)}\n          let local_idx = local_id.x;\n\n          let outputIndex = global_idx / ${g};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${v.type.storage}(${ml[o]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${g}) {\n           let candidate = ${v.type.storage}(${h.getByOffset("offset + k")});\n           bestValue = ${cl[o]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${g}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${pl[o]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${v.setByOffset("outputIndex",`${o==="mean"?`bestValue / ${v.type.storage}(uniforms.reduceSize)`:`${fl[o]}`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:s,dataType:n}],dispatchGroup:{x:a},programUniforms:[{type:"uint32",data:p}]})}},ut=(e,t,r,o)=>{let n=e.inputs.length===1?r:Pn(e.inputs,r),s=n.axes;s.length===0&&!n.noopWithEmptyAxes&&(s=e.inputs[0].dims.map((w,y)=>y));let u=D.normalizeAxes(s,e.inputs[0].dims.length),d=u,a=e.inputs[0],p=wl(d,e.inputs[0].dims.length);p.length>0&&(a=e.compute(et(e.inputs[0],p),{inputs:[0],outputs:[-1]})[0],d=hl(d.length,a.dims.length));let[h,v]=gl(a.dims,d),g=h;n.keepDims&&(g=yl(h,u)),e.compute(vl(t,{hint:n.cacheKey,inputDependencies:["type"]},[a],o,e.inputs[0].dataType,g,v),{inputs:[a]})},Yo=(e,t)=>{ut(e,"ReduceMeanShared",t,"mean")},Zo=(e,t)=>{ut(e,"ReduceL1Shared",t,"l1")},Xo=(e,t)=>{ut(e,"ReduceL2Shared",t,"l2")},Qo=(e,t)=>{ut(e,"ReduceLogSumExpShared",t,"logSumExp")},Jo=(e,t)=>{ut(e,"ReduceMaxShared",t,"max")},ea=(e,t)=>{ut(e,"ReduceMinShared",t,"min")},ta=(e,t)=>{ut(e,"ReduceProdShared",t,"prod")},ra=(e,t)=>{ut(e,"ReduceSumShared",t,"sum")},na=(e,t)=>{ut(e,"ReduceSumSquareShared",t,"sumSquare")},oa=(e,t)=>{ut(e,"ReduceLogSumShared",t,"logSum")}});var lt,$l,Hr,Pn,dt,Sl,xl,Cl,_l,Il,Al,Tl,El,Ol,kl,ct,ia,sa,ua,la,da,ca,pa,ma,fa,ha,Nr=Y(()=>{"use strict";$e();ke();be();aa();lt=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},$l=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],Hr=(e,t,r,o,n,s,u=!1,d=!1)=>{let a=[],p=r[0].dims,h=p.length,v=D.normalizeAxes(n,h),g=!d&&v.length===0;p.forEach((I,x)=>{g||v.indexOf(x)>=0?u&&a.push(1):a.push(I)});let w=a.length,y=D.size(a);return{name:e,shaderCache:t,getShaderSource:I=>{let x=[],_=W("_A",r[0].dataType,h),B=K("output",s,w),E=o(_,B,v),z=E[2];for(let A=0,U=0;A<h;A++)g||v.indexOf(A)>=0?(u&&U++,z=`for(var j${A}: u32 = 0; j${A} < ${p[A]}; j${A}++) {\n                  ${E[2].includes("last_index")?`let last_index = j${A};`:""}\n                  ${_.indicesSet("input_indices",A,`j${A}`)}\n                  ${z}\n                }`):(x.push(`${_.indicesSet("input_indices",A,B.indicesGet("output_indices",U))};`),U++);return`\n\n        ${I.registerUniform("output_size","u32").declareVariables(_,B)}\n\n        ${I.mainStart()}\n          ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var input_indices: ${_.type.indices};\n          let output_indices = ${B.offsetToIndices("global_idx")};\n\n          ${x.join(`\n`)}\n          ${E[0]}       // init ops for reduce max/min\n          ${E[1]}\n          ${z}\n          ${E[3]}\n          ${E.length===4?B.setByOffset("global_idx","value"):E.slice(4).join(`\n`)}\n        }`},getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:"uint32",data:y},...j(p),...j(a)]})}},Pn=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),ee({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},dt=(e,t,r,o)=>{let n=e.inputs,s=n.length===1?r:Pn(n,r);e.compute(Hr(t,{hint:s.cacheKey,inputDependencies:["rank"]},[n[0]],s.noopWithEmptyAxes&&s.axes.length===0?$l:o,s.axes,n[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},Sl=(e,t)=>{lt(e.inputs),dt(e,"ReduceLogSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,"value = log(value);"])},xl=(e,t)=>{lt(e.inputs),dt(e,"ReduceL1",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += abs(${o.getByIndices("input_indices")});`,""])},Cl=(e,t)=>{lt(e.inputs),dt(e,"ReduceL2",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},_l=(e,t)=>{lt(e.inputs),dt(e,"ReduceLogSumExp",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += exp(${o.getByIndices("input_indices")});`,"value = log(value);"])},Il=(e,t)=>{lt(e.inputs),dt(e,"ReduceMax",t,(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(o.indicesSet("input_indices",d,0));return[`${u.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = max(value, ${o.getByIndices("input_indices")});`,""]})},Al=(e,t)=>{lt(e.inputs),dt(e,"ReduceMean",t,(o,n,s)=>{let u=1;for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&(u*=e.inputs[0].dims[d]);return["var sum = f32(0);","",`sum += f32(${o.getByIndices("input_indices")});`,`let value = ${n.type.value}(sum / ${u});`]})},Tl=(e,t)=>{lt(e.inputs),dt(e,"ReduceMin",t,(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(`input_indices[${d}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = min(value, ${o.getByIndices("input_indices")});`,""]})},El=(e,t)=>{lt(e.inputs),dt(e,"ReduceProd",t,(o,n)=>[`var value = ${n.type.storage}(1);`,"",`value *= ${o.getByIndices("input_indices")};`,""])},Ol=(e,t)=>{lt(e.inputs),dt(e,"ReduceSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,""])},kl=(e,t)=>{lt(e.inputs),dt(e,"ReduceSumSquare",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += t * t;`,""])},ct=(e,t,r)=>{if(t.length===0)return r;let o=1,n=1;for(let s=0;s<t.length;s++)t.indexOf(s)===-1?o*=e[s]:n*=e[s];return n<32&&o>1024},ia=(e,t)=>{ct(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Al(e,t):Yo(e,t)},sa=(e,t)=>{ct(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?xl(e,t):Zo(e,t)},ua=(e,t)=>{ct(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Cl(e,t):Xo(e,t)},la=(e,t)=>{ct(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?_l(e,t):Qo(e,t)},da=(e,t)=>{ct(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Il(e,t):Jo(e,t)},ca=(e,t)=>{ct(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Tl(e,t):ea(e,t)},pa=(e,t)=>{ct(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?El(e,t):ta(e,t)},ma=(e,t)=>{ct(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ol(e,t):ra(e,t)},fa=(e,t)=>{ct(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?kl(e,t):na(e,t)},ha=(e,t)=>{ct(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Sl(e,t):oa(e,t)}});var ga,ya,ba,Rn,wa=Y(()=>{"use strict";Ue();ke();Nr();ga=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},ya=(e,t)=>{ga(e.inputs);let r=(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(`input_indices[${d}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${o.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${o.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]};e.compute(Hr("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},ba=(e,t)=>{ga(e.inputs);let r=(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(`input_indices[${d}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${o.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${o.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]};e.compute(Hr("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},Rn=e=>ee(e)});var Pl,va,Rl,Bl,Ml,Gr,Dl,$a,Bn=Y(()=>{"use strict";ke();Mr();be();Pl=(e,t)=>{let r=e[0],o=e[1],n=e[2],s=e[3],u=e[4],d=e[5];if(u&&d)throw new Error("Attention cannot have both past and relative_position_bias");if(r.dims.length!==3)throw new Error(\'Input "input" must have 3 dimensions\');let a=r.dims[0],p=r.dims[1],h=r.dims[2];if(n.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimensions\');if(o.dims.length!==2)throw new Error(\'Input "weights" is expected to have 2 dimensions\');if(o.dims[0]!==h)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(n.dims[0]!==o.dims[1])throw new Error(\'Input "bias" dimension 0 should have same length as dimension 1 of input "weights"\');let v=n.dims[0]/3,g=v,w=g;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let B of t.qkvHiddenSizes)if(B%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");v=t.qkvHiddenSizes[0],g=t.qkvHiddenSizes[1],w=t.qkvHiddenSizes[2]}let y=p;if(v!==g)throw new Error("qkv_hidden_sizes first element should be same as the second");if(n.dims[0]!==v+g+w)throw new Error(\'Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes\');let S=0;if(u){if(g!==w)throw new Error(\'Input "past" expect k_hidden_size == v_hidden_size\');if(u.dims.length!==5)throw new Error(\'Input "past" must have 5 dimensions\');if(u.dims[0]!==2)throw new Error(\'Input "past" first dimension must be 2\');if(u.dims[1]!==a)throw new Error(\'Input "past" second dimension must be batch_size\');if(u.dims[2]!==t.numHeads)throw new Error(\'Input "past" third dimension must be num_heads\');if(u.dims[4]!==g/t.numHeads)throw new Error(\'Input "past" fifth dimension must be k_hidden_size / num_heads\');t.pastPresentShareBuffer||(S=u.dims[3])}let I=y+S,x=-1,_=0;if(s)throw new Error("Mask not supported");if(u)throw new Error("past is not supported");if(d)throw new Error("relativePositionBias is not supported");return{batchSize:a,sequenceLength:p,pastSequenceLength:S,kvSequenceLength:y,totalSequenceLength:I,maxSequenceLength:x,inputHiddenSize:h,hiddenSize:v,vHiddenSize:w,headSize:Math.floor(v/t.numHeads),vHeadSize:Math.floor(w/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:_,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},va=e=>ee({...e}),Rl=(e,t,r,o)=>{let n=ze(o),s=K("x",t.dataType,t.dims,n),u="threadMaxVector";n===2?u="max(threadMaxVector.x, threadMaxVector.y)":n===4&&(u="max(max(threadMaxVector.x, threadMaxVector.y), max(threadMaxVector.z, threadMaxVector.w))");let d=Oe(t.dataType),a=64,p=o/n;p<a?a=1:p/8<64&&(a=Math.ceil(p/8));let h=Math.ceil(o/n/a),v=g=>`\n  const dInv: ${d} = 1 / ${o};\n  const dComp = ${o/n};\n  var<workgroup> wgMax: array<f32, ${a}>;\n  var<workgroup> wgSum: array<f32, ${a}>;\n\n  ${g.declareVariables(s)}\n  @compute @workgroup_size(${a}, 1, 1)\n  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_index) local_index : u32) {\n    let localOffset = local_index * ${h};\n    let offset: u32 = workgroup_id.x * dComp + localOffset;\n\n    var threadMaxVector = ${je("f32",n,"-3.402823e+38f")};\n    for (var i: u32 = 0; i < ${h} && i + localOffset < dComp; i++) {\n      threadMaxVector = max(${rt(d,n,"x[offset + i]")}, threadMaxVector);\n    }\n    wgMax[local_index] = ${u};\n    workgroupBarrier();\n\n    var maxValue = -3.402823e+38f;\n    for (var i = 0u; i < ${a}; i++) {\n      maxValue = max(wgMax[i], maxValue);\n    }\n\n    var sumVector = ${je("f32",n,"0")};\n    for (var i: u32 = 0; i < ${h} && i + localOffset < dComp; i++) {\n      sumVector += exp(${rt(d,n,"x[offset + i]")} - maxValue);\n    }\n    wgSum[local_index] = ${Xe("sumVector",n)};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${a}; i++) {\n      sum += wgSum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < ${h} && i + localOffset < dComp; i++) {\n        x[offset + i] = ${je(d,n,"dInv")};\n      }\n    } else {\n      for (var i: u32 = 0; i < ${h} && i + localOffset < dComp; i++) {\n        let f32input = ${rt(d,n,"x[offset + i]")};\n        x[offset + i] = ${s.type.value}(exp(f32input - maxValue) / sum);\n      }\n    }\n  }`;e.compute({name:"AttentionProbsSoftmax",shaderCache:{hint:`${o}`},getShaderSource:v,getRunData:()=>({outputs:[],dispatchGroup:{x:r}})},{inputs:[t],outputs:[]})},Bl=(e,t,r,o,n,s)=>{let u=[n.batchSize,n.numHeads,n.sequenceLength,n.kvSequenceLength+n.pastSequenceLength],d=s.scale===0?1/Math.sqrt(n.headSize):s.scale,a=Oe(t.dataType),p=ze(n.headSize),h=W("q",t.dataType,t.dims,p),v=W("key",r.dataType,r.dims,p),g=K("output",t.dataType,u),w=n.headSize/p,y=n.sequenceLength,S=n.totalSequenceLength,I=w,x=12,_={x:Math.ceil(n.totalSequenceLength/x),y:Math.ceil(n.sequenceLength/x),z:n.batchSize*n.numHeads},B=[t,r],E=A=>`\n  const M: u32 = ${y}u;\n  const N: u32 = ${S}u;\n  const K: u32 = ${I}u;\n  const alpha: ${a} = ${d};\n  const beta: ${a} = 1.0;\n  const TILE_SIZE = ${x}u;\n\n  var<workgroup> tileQ: array<${h.type.storage}, ${x*x}>;\n  var<workgroup> tileK: array<${h.type.storage}, ${x*x}>;\n\n  ${A.declareVariables(h,v,g)}\n\n  @compute @workgroup_size(${x}, ${x}, 1)\n  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,\n   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {\n   let global_idx = (workgroup_id.z * ${_.x*_.y}u +\n          workgroup_id.y * ${_.x}u + workgroup_id.x) * ${x*x}u + local_index;\n\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let lm = m + local_id.y;\n    let ln = n + local_id.x;\n\n    let qOffset = ${n.sequenceLength*w} * headIdx + m * K;\n    let kOffset = ${n.kvSequenceLength*w} * headIdx + n * K;\n\n    var value = ${je(a,p)};\n    for (var w: u32 = 0u; w < K; w += TILE_SIZE) {\n      if (m + local_id.y < M && w + local_id.x < K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * K + w + local_id.x];\n      }\n      if (n + local_id.y < N && w + local_id.x < K) {\n        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * K + w + local_id.x];\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {\n        value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = headIdx * M * N;\n    if (lm < M && ln < N) {\n      let outputIdx = headOffset + lm * N + ln;\n      output[outputIdx] = ${Xe("value",p)} * alpha;\n    }\n  }`,z=e.compute({name:"AttentionProbs",shaderCache:{hint:JSON.stringify(n)},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType,gpuDataType:0}],dispatchGroup:_}),getShaderSource:E},{inputs:B,outputs:[-1]})[0];return Rl(e,z,n.batchSize*n.numHeads*n.sequenceLength,n.totalSequenceLength),z},Ml=(e,t,r,o)=>{let n=[o.batchSize,o.sequenceLength,o.vHiddenSize],s=W("probs",t.dataType,t.dims),u=W("v",r.dataType,r.dims),d=K("output",t.dataType,n),a=Oe(t.dataType),p=12,h={x:Math.ceil(o.vHeadSize/p),y:Math.ceil(o.sequenceLength/p),z:o.batchSize*o.numHeads},v=g=>`\n  const M: u32 = ${o.sequenceLength}u;\n  const N: u32 = ${o.vHeadSize}u;\n  const K: u32 = ${o.totalSequenceLength}u;\n  const numHeads: u32 = ${o.numHeads}u;\n  const TILE_SIZE = ${p}u;\n\n  var<workgroup> tileQ: array<${s.type.storage}, ${p*p}>;\n  var<workgroup> tileK: array<${s.type.storage}, ${p*p}>;\n\n  ${g.declareVariables(s,u,d)}\n\n  @compute @workgroup_size(${p}, ${p}, 1)\n  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,\n   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {\n   let global_idx = (workgroup_id.z * ${h.x*h.y}u +\n          workgroup_id.y * ${h.x}u + workgroup_id.x) * ${p*p}u + local_index;\n\n   let headIdx = workgroup_id.z;\n   let m = workgroup_id.y * TILE_SIZE + local_id.y;\n   let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n   let offsetA = headIdx * (M * K) + m * K;\n   let offsetB = headIdx * (N * K) + n;\n\n   var value = ${a}(0);\n   for (var w: u32 = 0u; w < K; w += TILE_SIZE) {\n     if (m < M && w + local_id.x < K) {\n       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n     }\n     if (n < N && w + local_id.y < K) {\n       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * N];\n     }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   let batchIdx = workgroup_id.z / ${o.numHeads};\n   let currentBatchHeadNumber = workgroup_id.z % ${o.numHeads};\n   let headOffset = (batchIdx * M * ${o.numHeads} + currentBatchHeadNumber) * ${o.vHeadSize};\n   if (m < M && n < N) {\n     let outputIdx = batchIdx * ${o.sequenceLength*o.vHiddenSize} + m * ${o.vHiddenSize}\n       + currentBatchHeadNumber * ${o.vHeadSize} + n;\n     output[outputIdx] = value;\n   }\n  }`;return e.compute({name:"AttentionScore",shaderCache:{hint:JSON.stringify(o)},getRunData:()=>({outputs:[{dims:n,dataType:t.dataType,gpuDataType:0}],dispatchGroup:h}),getShaderSource:v},{inputs:[t,r],outputs:[0]})[0]},Gr=(e,t,r,o,n,s,u,d,a,p,h)=>{let v=Bl(e,t,r,a,p,h);Ml(e,v,o,p)},Dl=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],o=Oe(e.inputs[0].dataType),n=t.sequenceLength,s=t.inputHiddenSize,u=t.headSize,d=12,a={x:Math.ceil(t.headSize/d),y:Math.ceil(t.sequenceLength/d),z:t.batchSize*t.numHeads},p=()=>`\n  const M: u32 = ${n}u;\n  const K: u32 = ${s}u;\n  const N: u32 = ${u}u;\n  const numHeads: u32 = ${t.numHeads};\n  const ldb = ${t.hiddenSize+t.hiddenSize+t.vHiddenSize}u;\n  const TILE_SIZE = ${d}u;\n\n  var<workgroup> tileInput: array<${o}, ${d*d}>;\n  var<workgroup> tileWeightQ: array<${o}, ${d*d}>;\n  var<workgroup> tileWeightK: array<${o}, ${d*d}>;\n  var<workgroup> tileWeightV: array<${o}, ${d*d}>;\n\n  @group(0) @binding(0) var<storage, read> input: array<${o}>;\n  @group(0) @binding(1) var<storage, read> weight: array<${o}>;\n  @group(0) @binding(2) var<storage, read> bias: array<${o}>;\n  @group(0) @binding(3) var<storage, read_write> outputQ: array<${o}>;\n  @group(0) @binding(4) var<storage, read_write> outputK: array<${o}>;\n  @group(0) @binding(5) var<storage, read_write> outputV: array<${o}>;\n\n  @compute @workgroup_size(${d}, ${d}, 1)\n  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,\n   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {\n   let global_idx = (workgroup_id.z * ${a.x*a.y}u +\n          workgroup_id.y * ${a.x}u + workgroup_id.x) * ${d*d}u + local_index;\n\n    let batchIndex = workgroup_id.z / ${t.numHeads};\n    let headNumber = workgroup_id.z % ${t.numHeads};\n    let m = workgroup_id.y * TILE_SIZE + local_id.y;\n    let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n    let inputOffset = batchIndex * (M * K) + m * K;\n    let biasOffsetQ = headNumber * ${t.headSize};\n    let biasOffsetK = ${t.hiddenSize} + biasOffsetQ;\n    let biasOffsetV = ${t.hiddenSize} + biasOffsetK;\n\n    var valueQ = ${o}(0);\n    var valueK = ${o}(0);\n    var valueV = ${o}(0);\n    for (var w: u32 = 0u; w < K; w += TILE_SIZE) {\n      if (m < M && w + local_id.x < K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < N && w + local_id.y < K) {\n        let offset = n + (w + local_id.y) * ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * N + n) % ${t.headSize};\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * M * N;\n    if (m < M && n < N) {\n      let outputIdx = offset + m * N + n;\n      outputQ[outputIdx] = valueQ;\n      outputK[outputIdx] = valueK;\n      outputV[outputIdx] = valueV;\n    }\n  }`,h=[e.inputs[0],e.inputs[1],e.inputs[2]];return e.compute({name:"AttentionPrepare",shaderCache:{hint:JSON.stringify(t)},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:a}),getShaderSource:p},{inputs:h,outputs:[-1,-1,-1]})},$a=(e,t)=>{let r=Pl(e.inputs,t),[o,n,s]=Dl(e,r);return Gr(e,o,n,s,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t)}});var Lr=Y(()=>{"use strict"});var Sa=Y(()=>{"use strict";Lr()});var xa,Ca=Y(()=>{"use strict";xa="1.17.0"});var _a,Mn,Ia=Y(()=>{"use strict";Ca();_a="warning",Mn={wasm:{},webgl:{},webgpu:{},versions:{common:xa},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);_a=e}},get logLevel(){return _a}};Object.defineProperty(Mn,"logLevel",{enumerable:!0})});var Ht,Aa=Y(()=>{"use strict";Ia();Ht=Mn});var Ta=Y(()=>{"use strict"});var Ea=Y(()=>{"use strict";Fr()});var ka=Y(()=>{"use strict"});var Pa=Y(()=>{"use strict";Fr()});var Fr=Y(()=>{"use strict";Ta();Ea();ka();Pa()});var qr=Y(()=>{"use strict";Fr()});var Ra=Y(()=>{"use strict";Lr();qr()});var Ba=Y(()=>{"use strict";Ra()});var Ma=Y(()=>{"use strict"});var Da=Y(()=>{"use strict";Lr();qr()});var za=Y(()=>{"use strict";Da()});var jr=Y(()=>{"use strict";Sa();Aa();Ba();qr();Ma();za()});var Wl,Ul,Nl,Va,Wa=Y(()=>{"use strict";jr();$e();ke();be();Wl=(e,t)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let r=(o,n,s)=>{let u=n.length;if(u!==o.length)throw new Error(`${s}: num dimensions != ${u}`);n.forEach((d,a)=>{if(d!==o[a])throw new Error(`${s}: dim[${a}] do not match`)})};if(e[0].dims.length>1){let o=t.format==="NHWC"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);r(e[1].dims,o,"Invalid input scale"),r(e[2].dims,o,"Invalid input B"),r(e[3].dims,o,"Invalid input mean"),r(e[4].dims,o,"Invalid input var")}else r(e[1].dims,[1],"Invalid input scale"),r(e[2].dims,[1],"Invalid input B"),r(e[3].dims,[1],"Invalid input mean"),r(e[4].dims,[1],"Invalid input var")},Ul=(e,t)=>{let{epsilon:r,spatial:o,format:n}=t,s=e[0].dims,u=o?ze(s[s.length-1]):1,d=n==="NHWC"&&s.length>1?u:1,a=D.size(s)/u,p=Pe(s.length)&&o,h=p?s.length:s,v=W("x",e[0].dataType,e[0].dims,u),g=W("scale",e[1].dataType,e[1].dims,d),w=W("bias",e[2].dataType,e[2].dims,d),y=W("inputMean",e[3].dataType,e[3].dims,d),S=W("inputVar",e[4].dataType,e[4].dims,d),I=K("y",e[0].dataType,h,u),x=()=>{let B="";if(o)B=`let cOffset = ${s.length===1?"0u":n==="NHWC"?`outputIndices[${s.length-1}] / ${u}`:"outputIndices[1]"};`;else if(n==="NCHW")B=`\n            ${I.indicesSet("outputIndices","0","0")}\n            let cOffset = ${I.indicesToOffset("outputIndices")};`;else{B=`var cIndices = ${g.type.indices}(0);\n                       cIndices[0] = outputIndices[${s.length-1}];`;for(let E=1;E<g.rank;E++)B+=`cIndices[${E}] = outputIndices[${E}];`;B+=`let cOffset = ${g.indicesToOffset("cIndices")};`}return B},_=B=>`\n  const epsilon = ${r};\n  ${B.registerUniform("outputSize","u32").declareVariables(v,g,w,y,S,I)}\n  ${B.mainStart()}\n  ${B.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${I.offsetToIndices(`global_idx * ${u}`)};\n    ${x()}\n    let scale = ${g.getByOffset("cOffset")};\n    let bias = ${w.getByOffset("cOffset")};\n    let inputMean = ${y.getByOffset("cOffset")};\n    let inputVar = ${S.getByOffset("cOffset")};\n    let x = ${v.getByOffset("global_idx")};\n    let value = (x - inputMean) / sqrt(inputVar + epsilon) * scale + bias;\n    ${I.setByOffset("global_idx","value")}\n  }`;return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${o}_${u}`,inputDependencies:p?["rank","type","type","type","type"]:void 0},getShaderSource:_,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p?[{type:"uint32",data:a},...j(s)]:[{type:"uint32",data:a}]})}},Nl=e=>ee(e),Va=(e,t)=>{let{inputs:r,outputCount:o}=e,n=Nl({...t,outputCount:o});if(Ht.webgpu.validateInputContent&&Wl(r,n),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(Ul(r,n))}});var Hl,Gl,Ua,Na=Y(()=>{"use strict";$e();be();Hl=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Gl=e=>{let t=e[0].dims,r=e[0].dims[2],o=D.size(t)/4,n=e[0].dataType,s=W("input",n,t,4),u=W("bias",n,[r],4),d=W("residual",n,t,4),a=K("output",n,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:h=>`\n  const channels = ${r}u / 4;\n  ${h.declareVariables(s,u,d,a)}\n\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let value = ${s.getByOffset("global_idx")}\n      + ${u.getByOffset("global_idx % channels")} + ${d.getByOffset("global_idx")};\n    ${a.setByOffset("global_idx","value")}\n  }`}},Ua=e=>{Hl(e.inputs),e.compute(Gl(e.inputs))}});var Ll,Te,Ha,Ga,La,Fa,qa,ja,Ka,Ya,Za,Fl,Xa,Qa,Ja,ei,Kr,ti,Yr,ri,ni,oi,ai,ii,si,ui,li,di,ci,pi,mi,fi,hi,gi,yi,bi,Dn=Y(()=>{"use strict";Ue();$e();ke();be();Ll=(e,t,r,o,n,s)=>{let u=Math.ceil(t/4),d="";typeof n=="string"?d=`${n}(a)`:d=n("a");let a=W("inputData",r,[u],4),p=K("outputData",o,[u],4);return`\n      ${e.registerUniform("vec_size","u32").declareVariables(a,p)}\n\n  ${s??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${a.getByOffset("global_idx")};\n    ${p.setByOffset("global_idx",d)}\n  }`},Te=(e,t,r,o,n,s=e.dataType)=>({name:t,shaderCache:{hint:n,inputDependencies:["type"]},getShaderSource:u=>Ll(u,D.size(e.dims),e.dataType,s,r,o),getRunData:u=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(D.size(u[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(D.size(e.dims)/4)}]})}),Ha=e=>{e.compute(Te(e.inputs[0],"Abs","abs"))},Ga=e=>{e.compute(Te(e.inputs[0],"Acos","acos"))},La=e=>{e.compute(Te(e.inputs[0],"Acosh","acosh"))},Fa=e=>{e.compute(Te(e.inputs[0],"Asin","asin"))},qa=e=>{e.compute(Te(e.inputs[0],"Asinh","asinh"))},ja=e=>{e.compute(Te(e.inputs[0],"Atan","atan"))},Ka=e=>{e.compute(Te(e.inputs[0],"Atanh","atanh"))},Ya=e=>ee(e),Za=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(Te(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},Fl=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:Vr,r=e.length>=3?e[2].getFloat32Array()[0]:Wr;return ee({min:t,max:r})},Xa=(e,t)=>{let r=e.inputs.length===1?t:Fl(e.inputs),o=$t(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Clip",n=>`clamp(${n}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${o}> = vec4(${o}(${r.min}));\n    const clip_max_: vec4<${o}> = vec4(${o}(${r.max}));\n`,r.cacheKey),{inputs:[0]})},Qa=e=>{e.compute(Te(e.inputs[0],"Ceil","ceil"))},Ja=e=>{e.compute(Te(e.inputs[0],"Cos","cos"))},ei=e=>{e.compute(Te(e.inputs[0],"Cosh","cosh"))},Kr=e=>ee(e),ti=(e,t)=>{let r=$t(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Elu",o=>`elu_vf32(${o})`,`\n  const elu_alpha_ = ${r}(${t.alpha});\n\n  fn elu_f32(a: ${r}) -> ${r} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Yr=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,ri=e=>{let t=$t(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,Yr(`vec4<${t}>`,t)))},ni=e=>{e.compute(Te(e.inputs[0],"Exp","exp"))},oi=e=>{e.compute(Te(e.inputs[0],"Floor","floor"))},ai=e=>{let t=$t(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Yr(`vec4<${t}>`,t)))},ii=(e,t)=>{let r=$t(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"LeakyRelu",o=>`select(leaky_relu_alpha_ * ${o}, ${o}, ${o} >= vec4<${r}>(0.0))`,`const leaky_relu_alpha_ = ${r}(${t.alpha});`,t.cacheKey))},si=e=>{e.compute(Te(e.inputs[0],"Not",t=>`!${t}`))},ui=e=>{e.compute(Te(e.inputs[0],"Neg",t=>`-${t}`))},li=e=>{e.compute(Te(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},di=e=>{let t=$t(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Relu",r=>`select(vec4<${t}>(0.0), ${r}, ${r} > vec4<${t}>(0.0))`))},ci=e=>{e.compute(Te(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},pi=e=>{e.compute(Te(e.inputs[0],"Sin","sin"))},mi=e=>{e.compute(Te(e.inputs[0],"Sinh","sinh"))},fi=e=>{e.compute(Te(e.inputs[0],"Sqrt","sqrt"))},hi=e=>{e.compute(Te(e.inputs[0],"Tan","tan"))},gi=e=>{e.compute(Te(e.inputs[0],"Tanh","tanh"))},yi=(e,t)=>{let r=$t(e.inputs[0].dataType);return e.compute(Te(e.inputs[0],"ThresholdedRelu",o=>`select(vec4<${r}>(0.0), ${o}, ${o} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`,t.cacheKey)),0},bi=e=>{e.compute(Te(e.inputs[0],"Log","log"))}});var jl,Kl,wi,vi=Y(()=>{"use strict";$e();be();Dn();jl=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Kl=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=W("input",e[0].dataType,e[0].dims,4),o=W("bias",e[0].dataType,[e[0].dims[2]],4),n=K("output",e[0].dataType,t,4),s=D.size(t)/4,u=Oe(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:a=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${a.declareVariables(r,o,n)}\n\n  ${Yr(`vec4<${u}>`,u)}\n\n  ${a.mainStart()}\n    ${a.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${n.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},wi=e=>{jl(e.inputs),e.compute(Kl(e.inputs))}});var Yl,Zl,pt,$i,Si,xi,Ci,_i,Ii,Ai,Ti,Ei,Oi,ki=Y(()=>{"use strict";Ue();$e();be();Yl=(e,t,r,o,n,s,u,d,a,p,h,v,g)=>{let w,y;typeof d=="string"?w=y=(A,U)=>`${d}((${A}),(${U}))`:typeof d=="function"?w=y=d:(w=d.scalar,y=d.vector);let S=v?t.length:t,I=v?r.length:r,x=v?o.length:o,_=K("outputData",h,x,4),B=W("aData",a,S,4),E=W("bData",p,I,4),z;if(n)if(s){let A=D.size(t)===1,U=D.size(r)===1,V=t.length>0&&t[t.length-1]%4===0,G=r.length>0&&r[r.length-1]%4===0;A||U?z=_.setByOffset("global_idx",y(A?`${B.type.value}(${B.getByOffset("0")}.x)`:B.getByOffset("global_idx"),U?`${E.type.value}(${E.getByOffset("0")}.x)`:E.getByOffset("global_idx"))):z=`\n            let outputIndices = ${_.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${B.broadcastedIndicesToOffset("outputIndices",_)};\n            let offsetB = ${E.broadcastedIndicesToOffset("outputIndices",_)};\n            ${_.setByOffset("global_idx",y(u||V?B.getByOffset("offsetA / 4u"):`${B.type.value}(${B.getByOffset("offsetA / 4u")}[offsetA % 4u])`,u||G?E.getByOffset("offsetB / 4u"):`${E.type.value}(${E.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else z=_.setByOffset("global_idx",y(B.getByOffset("global_idx"),E.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let A=(U,V,G="")=>{let Q=`aData[indexA${V}][componentA${V}]`,R=`bData[indexB${V}][componentB${V}]`;return`\n            let outputIndices${V} = ${_.offsetToIndices(`global_idx * 4u + ${V}u`)};\n            let offsetA${V} = ${B.broadcastedIndicesToOffset(`outputIndices${V}`,_)};\n            let offsetB${V} = ${E.broadcastedIndicesToOffset(`outputIndices${V}`,_)};\n            let indexA${V} = offsetA${V} / 4u;\n            let indexB${V} = offsetB${V} / 4u;\n            let componentA${V} = offsetA${V} % 4u;\n            let componentB${V} = offsetB${V} % 4u;\n            ${U}[${V}] = ${G}(${w(Q,R)});\n          `};h===9?z=`\n            var data = vec4<u32>(0);\n            ${A("data",0,"u32")}\n            ${A("data",1,"u32")}\n            ${A("data",2,"u32")}\n            ${A("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:z=`\n            ${A("outputData[global_idx]",0)}\n            ${A("outputData[global_idx]",1)}\n            ${A("outputData[global_idx]",2)}\n            ${A("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(B,E,_)}\n\n        ${g??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${z}\n      }`},Zl=(e,t,r,o,n,s,u=r.dataType)=>{let d=!D.areEqual(r.dims,o.dims),a=r.dims,p=D.size(r.dims),h=!1,v=!1,g=[d];if(d){let y=st.calcShape(r.dims,o.dims,!1);if(!y)throw new Error("Can\'t perform binary op on the given tensors");a=y,p=D.size(a);let S=D.size(r.dims)===1,I=D.size(o.dims)===1,x=r.dims.length>0&&r.dims[r.dims.length-1]%4===0,_=o.dims.length>0&&o.dims[o.dims.length-1]%4===0;g.push(S),g.push(I),g.push(x),g.push(_);let B=1;for(let E=1;E<a.length;E++){let z=r.dims[r.dims.length-E]??1,A=o.dims[o.dims.length-E]??1;if(z===A)B*=z;else break}B%4===0?(v=!0,h=!0):(S||I||x||_)&&(h=!0)}else h=!0;g.push(h);let w=Pe(r.dims.length)&&Pe(o.dims.length)&&Pe(a.length);return{name:e,shaderCache:{hint:t+g.map(y=>y.toString()).join("_"),inputDependencies:w?["rank","rank"]:["dims","dims"]},getShaderSource:y=>Yl(y,r.dims,o.dims,a,h,d,v,n,r.dataType,o.dataType,u,w,s),getRunData:()=>({outputs:[{dims:a,dataType:u}],dispatchGroup:{x:Math.ceil(p/64/4)},programUniforms:w?[{type:"uint32",data:Math.ceil(D.size(a)/4)},...j(r.dims),...j(o.dims),...j(a)]:[{type:"uint32",data:Math.ceil(D.size(a)/4)}]})}},pt=(e,t,r,o,n,s)=>{e.compute(Zl(t,n??"",e.inputs[0],e.inputs[1],r,o,s))},$i=e=>{pt(e,"Add",(t,r)=>`${t}+${r}`)},Si=e=>{pt(e,"Div",(t,r)=>`${t}/${r}`)},xi=e=>{pt(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Ci=e=>{pt(e,"Mul",(t,r)=>`${t}*${r}`)},_i=e=>{let t=W("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;pt(e,"Pow",{scalar:(o,n)=>`pow_custom(${o},${n})`,vector:(o,n)=>`pow_vector_custom(${o},${n})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Ii=e=>{pt(e,"Sub",(t,r)=>`${t}-${r}`)},Ai=e=>{pt(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},Ti=e=>{pt(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Ei=e=>{pt(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Oi=e=>{pt(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var Ql,Jl,ed,td,Pi,Ri,Bi=Y(()=>{"use strict";$e();ke();be();Ql=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let o of e){if(o.dataType!==t)throw new Error("input tensors should be one type");if(o.dims.length!==r)throw new Error("input tensors should have the same shape")}},Jl=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,ed=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;++n){let s=t.setByOffset("global_idx",e[n].getByIndices("indices"));r===1?o.push(s):n===0?o.push(`if (inputIndex == ${n}u) { ${s} }`):n===r-1?o.push(`else { ${s} }`):o.push(`else if (inputIndex == ${n}) { ${s} }`)}return o.join(`\n`)},td=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let o=t<0?r.length+t:t,n=r.slice(0);for(let E=1;E<e.length;E++){let z=e[E].dims.slice();for(let A=0;A<r.length;A++)if(A===o)n[o]+=z[A];else if(r[A]!==z[A])throw new Error("non concat dimensions must match")}let s=D.size(n),u=new Array(e.length),d=new Array(e.length),a=e[0].dataType,p=0,h=[],v=[],g=[],w=[{type:"uint32",data:s}];for(let E=0;E<e.length;++E)p+=e[E].dims[o],u[E]=p,g.push(Pe(e[E].dims.length)),v.push(g[E]?e[E].dims.length:e[E].dims),d[E]=W(`input${E}`,a,v[E]),h.push(g[E]?"rank":"dims"),w.push({type:"uint32",data:u[E]});for(let E=0;E<e.length;++E)g[E]&&w.push(...j(e[E].dims));let y=Pe(n.length);y&&w.push(...j(n));let S=y?n.length:n,I=K("output",a,S),x=I.indicesGet("indices",o),_=Array.from(Array(u.length).keys()).map(E=>`uniforms.sizeInConcatAxis${E}`).join(","),B=E=>`\n\n  ${(()=>{E.registerUniform("outputSize","u32");for(let z=0;z<e.length;z++)E.registerUniform(`sizeInConcatAxis${z}`,"u32");return E.declareVariables(...d,I)})()}\n\n  ${Jl(u.length,_)}\n\n  ${E.mainStart()}\n    ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${I.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${x});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${u.length}u>(${_});\n      ${x} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${ed(d,I)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:w}),getShaderSource:B}},Pi=(e,t)=>{Ql(e.inputs),e.compute(td(e.inputs,t.axis))},Ri=e=>ee({axis:e.axis})});var nt,Zr,St=Y(()=>{"use strict";$e();nt=(e,t)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:`value = max(value, ${t}(0.0));`};case"Sigmoid":return{activationFunction:"",applyActivation:`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`};case"Clip":return{activationFunction:`const clip_min_=${t}(${e.clipMin});const clip_max_=${t}(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Zr=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,o]=e?.activation_params||[Vr,Wr];return{activation:t,clipMax:o,clipMin:r,activationCacheKey:`${t}:${r},${o}`}}return{activation:t,activationCacheKey:t}}});var Le,Xr,Qr=Y(()=>{"use strict";Le=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Xr=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `});var Jr,zn=Y(()=>{"use strict";Jr=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`});var rd,nd,dr,Mi,od,cr,ad,en,pr=Y(()=>{"use strict";$e();be();St();Qr();rd=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,nd=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,dr=(e,t,r="f32",o,n=!1,s=32,u=!1,d=32)=>{let a=t[1]*e[1],p=t[0]*e[0],h=n?a:s,v=n?s:a,g=h/t[0],w=s/t[1];if(!((n&&g===4&&e[1]===4||!n&&(g===3||g===4))&&h%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${n} is true, innerElementSize ${g} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${g} must be 3 or 4.\n  tileAWidth ${h} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${g}<${r}>, ${h/g}>, ${v}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${p/e[0]}>, ${s}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${g};\nconst tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${u?"0":"i32(globalId.z)"};\n  ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${a};\n\n  let numTiles = ${u?`${Math.ceil(d/s)}`:"(uniforms.dimInner - 1) / tileInner + 1"};\n  var kStart = ${u?`i32(globalId.z) * ${d}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${w};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${rd(n,o)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${o?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${g===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${nd(n,g)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Mi=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,od=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",cr=(e,t,r="f32",o,n=!1,s=32,u=!1,d=32,a=!1)=>{let p=e[1]*t[1],h=e[0]*t[0],v=n?p:s,g=n?s:p;if(!(g%t[1]===0&&v%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${g} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${v} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let w=g/t[1],y=v/t[0],S=s/t[1],I=a?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${p};\n    let globalColStart = i32(workgroupId.x) * ${h};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${g}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${v}; inputCol = inputCol + ${t[0]}) {\n          ${Mi(n,o)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${o?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${p};\n\nlet tileRowA = i32(localId.y) * ${w};\nlet tileColA = i32(localId.x) * ${y};\nlet tileRowB = i32(localId.y) * ${S};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${y}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Mi(n,o)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${S}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${o?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${od(n)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${v}>, ${g}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${h}>, ${s}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${u?"0":"i32(globalId.z)"};\n    ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${u?`${Math.ceil(d/s)}`:"(uniforms.dimInner - 1) / tileInner + 1"};\n    var kStart = ${u?`i32(globalId.z) * ${d}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${I}\n  }\n`},ad=(e,t,r,o,n,s=!1)=>{let[u,d,a]=n,[p,h,v,g]=o,w=Ut(u,a),y=Ut(d,a),S=Oe(o[0].type.tensor),I=()=>{let B=h.rank,E=p.rank,z=`var aIndices: ${h.type.indices};`;for(let A=B-2-1,U=E-1;A>=0;A--,U--)z+=`\naIndices[${A}] = ${E>1?`batchIndices[${U}]`:"batchIndices"};`;return w.forEach(A=>{z+=`\naIndices[${A}] = 0;`}),z+=`\naIndices[${B-2}] = u32(row);\n                   aIndices[${B-1}] = u32(colIn);`,z},x=()=>{let B=v.rank,E=p.rank,z=`var bIndices: ${v.type.indices};`;for(let A=B-2-1,U=E-1;A>=0;A--,U--)z+=`\nbIndices[${A}] = ${E>1?`batchIndices[${U}]`:"batchIndices"};`;return y.forEach(A=>{z+=`\nbIndices[${A}] = 0;`}),z+=`\nbIndices[${B-2}] = u32(row);\n                   bIndices[${B-1}] = u32(colIn);`,z};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${Le(e,S)} {\n      var value = ${Le(e,S)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dimAOuter && col < uniforms.dimInner)\n      {\n        ${I()}\n        value = ${h.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${Le(e,S)} {\n      var value = ${Le(e,S)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dimInner && col < uniforms.dimBOuter)\n      {\n        ${x()}\n        value = ${v.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Le(e,S)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${s?"bias[colIn]":`${Le(e,S)}(bias[row])`};`:""}\n        ${r}\n        ${g.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},en=(e,t,r,o,n=!1)=>{let s=e[0].dims,u=e[1].dims,d=s.slice(0,-2),a=u.slice(0,-2),p=o?o.slice(0,-2):r.slice(0,-2),h=Pe(p.length),v=h?p.length:p,g=Ur("batchDims",e[0].dataType,v,1),w=D.size(p),y=s[s.length-2],S=s[s.length-1],I=u[u.length-1],x=S%4===0&&I%4===0,_=y<=8?[4,1,1]:[4,4,1],B=[8,8,1],E=[Math.ceil(I/B[0]/_[0]),Math.ceil(y/B[1]/_[1]),Math.ceil(w/B[2]/_[2])],z=Oe(e[0].dataType),A=x?4:1,U=[...d,y,S/A],V=Pe(U.length),G=V?U.length:U,Q=[...a,S,I/A],R=Pe(Q.length),q=R?Q.length:Q,pe=[w,y,I/A],J=W("a",e[0].dataType,G,A),we=W("b",e[1].dataType,q,A),Z=K("result",e[0].dataType,pe.length,A),ye=[J,we],Ce=[{type:"int32",data:y},{type:"int32",data:I},{type:"int32",data:S}];h&&Ce.push(...j(p)),V&&Ce.push(...j(U)),R&&Ce.push(...j(Q));let fe=[];fe.push(V?"rank":"dims"),fe.push(R?"rank":"dims");let ce=e.length>2,{activationFunction:Ne,applyActivation:Be}=nt(t,Z.type.value),He=ad(A,ce,Be,[g,J,we,Z],[d,a,p],n);if(ce){let ne=n?A:1;ye.push(W("bias",e[2].dataType,e[2].dims.length,ne)),Ce.push(...j(e[2].dims)),fe.push("rank")}Ce.push(...j(pe));let L=ne=>`\n  ${ne.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").registerInternalVariables(g).declareVariables(...ye,Z)}\n  ${Ne}\n  ${He}\n  ${x?dr(_,B,z,g):cr(_,B,z,g)}\n                   `;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey+`${_}${x}${n}`,inputDependencies:fe},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:E[0],y:E[1],z:E[2]},programUniforms:Ce}),getShaderSource:L}}});var id,Di,zi=Y(()=>{"use strict";vt();be();St();Qr();zn();pr();id=(e,t,r,o,n=!1,s,u=4,d=4,a=4,p="f32")=>{let h=R=>{switch(R){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${p}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${R} is not supported.`)}},v=R=>{switch(R){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${R} is not supported.`)}},g=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,w=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,y=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",S=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",I=e?"row":"col",x=e?"col":"row",_=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n    let outRow = ${I} / outWidth;\n    let outCol = ${I} % outWidth;\n\n    let WRow = ${x} / (filterDims[1] * inChannels);\n    let WCol = ${x} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${x} % inChannels;\n    var resData = ${Le(u,p)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${S}) {\n      ${g}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${h(u)}\n    }\n    return resData;`,B=e?t&&o?`\n    let col = colIn * ${u};\n    ${_}`:`\n    let col = colIn * ${u};\n    if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n      ${_}\n    }\n    return ${Le(u,p)}(0.0);`:o&&r?`\n    let col = colIn * ${u};\n    ${_}`:`\n    let col = colIn * ${u};\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n      ${_}\n    }\n    return ${Le(u,p)}(0.0);`,E=`${v(d)}`,z=Le(a,p),A=e?Le(u,p):Le(d,p),U=e?Le(d,p):Le(u,p),{activationFunction:V,applyActivation:G}=nt(s,z);return`\n    ${V}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${A} {\n      ${e?B:E}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${U} {\n      ${e?E:B}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${z}) {\n      let col = colIn * ${a};\n      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${w}\n      ${Xr(n)}\n      ${G}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Di=(e,t,r,o,n,s,u,d)=>{let a=t.format==="NHWC",p=a?e[0].dims[3]:e[0].dims[1],h=r[0],v=a?r[2]:r[3],g=a?r[1]:r[2],w=a?r[3]:r[1],y=a&&(p%4===0||p%3===0)&&w%4===0,S=a?w:v*g,I=a?v*g:w,x=[8,8,1],_=o<=8?[4,1,1]:[4,4,1],B=[Math.ceil(S/x[0]/_[0]),Math.ceil(I/x[1]/_[1]),Math.ceil(h/x[2]/_[2])];Re("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${B}`);let E=y?a&&p%4!==0?3:4:1,z=x[1]*_[1],A=x[0]*_[0],U=Math.max(x[0]*E,x[1]),V=o%z===0,G=n%A===0,Q=s%U===0,R=y?[E,4,4]:[1,1,1],q=Oe(e[0].dataType),pe=y?4:1,J=[{type:"int32",data:o},{type:"int32",data:n},{type:"int32",data:s}],we=W("x",e[0].dataType,e[0].dims.length,E===3?1:E),Z=W("w",e[1].dataType,e[1].dims.length,pe),ye=[we,Z];J.push(...j(e[0].dims)),J.push(...j(e[1].dims));let Ce=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${y?`vec4<${q}>`:q}) {\n        result[flatIndex] = ${y?`vec4<${q}>`:q}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${y?`vec4<${q}>`:q}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${y?"/ 4":""}, value);\n      }`;if(u){let ce=W("bias",e[2].dataType,e[2].dims.length,pe);ye.push(ce),J.push(...j(e[2].dims)),Ce+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${y?`vec4<${q}>`:q} {\n          return bias[coords.${a?"w":"y"}${y?"/ 4":""}];\n        }`}let fe=K("result",e[0].dataType,r.length,pe);return J.push(...j(r)),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:B[0],y:B[1],z:B[2]},programUniforms:J}),getShaderSource:ce=>`\n        ${Jr("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${ce.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...ye,fe)}\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        ${Ce}\n        ${id(a,V,G,Q,u,t,R[0],R[1],R[2],q)}\n            ${y?dr(_,x,q,void 0,!a,U):cr(_,x,q,void 0,!a,U,!1,void 0,d)}`}}});var Vn,Vi,Wi=Y(()=>{"use strict";$e();be();Wn();St();Vn=(e,t,r)=>{let o=e.length>2,n=o?"value += b[output_channel];":"",s=e[0].dims,u=e[1].dims,d=u[0]/t.group,a=t.format==="NHWC",p=tn(s,u,t.dilations,t.pads,t.strides,a),h=D.size(p),v=K("output",e[0].dataType,p),{activationFunction:g,applyActivation:w}=nt(t,v.type.value),y=W("x",e[0].dataType,s),S=W("w",e[1].dataType,u),I=[y,S];o&&I.push(W("b",e[2].dataType,e[2].dims));let x=_=>`\n  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);\n  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);\n\n  ${_.declareVariables(...I,v)}\n\n  ${g}\n\n  ${_.mainStart()}\n    ${_.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n\n    let outputIndices = ${v.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${a?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${a?1:2}], outputIndices[${a?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${d}u;\n\n    var value: ${v.type.value} = ${v.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${u[1]}u; wInChannel++) {\n      let input_channel = group_id * ${u[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${u[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${s[a?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${u[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${s[a?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${a?y.get("batch","xHeight","xWidth","input_channel"):y.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${S.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${n}\n    ${w}\n    ${v.setByOffset("global_idx","value")}\n  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(p):p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)}}),getShaderSource:x}},Vi=(e,t,r)=>{let o=e.length>2,n=ze(r[3]),s=ze(r[2]),u=D.size(r)/n/s,d=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/n],a=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/n],p=h=>{let v=K("output",e[0].dataType,[r[0],r[1],r[2],r[3]/n],n),{activationFunction:g,applyActivation:w}=nt(t,v.type.value),y=W("x",e[0].dataType,d,n),S=W("w",e[1].dataType,a,n),I=[y,S];o&&I.push(W("b",e[2].dataType,e[2].dims,n));let x=o?"value += b[output_channel];":"",_=(s-1)*t.strides[1]+a[1];return`\n  const strides: vec2<i32> = vec2(${t.strides[0]}, ${t.strides[1]});\n  const pads: vec2<i32> = vec2(${t.pads[0]}, ${t.pads[1]});\n  ${h.declareVariables(...I,v)}\n  ${g}\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n    let width0 = ${r[3]}u / ${n}u;\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = ${r[2]}u / ${s}u;\n    let col = (index1 % width1) * ${s}u;\n    index1 = index1 / width1;\n    let row = index1 % ${r[1]}u;\n    let batch = index1 / ${r[1]}u;\n\n    let xRCCorner = vec2<i32>(i32(row), i32(col)) * strides - pads;\n\n    var xVals: array<${y.type.value}, ${_}>;\n    var values: array<${v.type.value}, ${s}>;\n    let input_channel = output_channel;\n      for (var wHeight: u32 = 0u; wHeight < ${a[0]}u; wHeight++) {\n        let xHeight = xRCCorner.x + i32(wHeight);\n        if (xHeight >= 0 || xHeight < ${d[1]}) {\n          for (var i = 0; i < ${_}; i++) {\n            let xWidth = xRCCorner.y + i;\n            if (xWidth >= 0 && xWidth < ${d[2]}) {\n              xVals[i] = ${y.get("batch","u32(xHeight)","u32(xWidth)","input_channel")};\n            } else {\n              xVals[i] = ${y.type.value}(0);\n            }\n          }\n          for (var wWidth: u32 = 0u; wWidth < ${a[1]}u; wWidth++) {\n            let wVal = ${S.get("wHeight","wWidth","0","output_channel")};\n            for (var i = 0u; i < ${s}u; i++) {\n              values[i] = fma(xVals[i * ${t.strides[1]}u + wWidth], wVal, values[i]);\n            }\n          }\n        }\n      }\n\n    for (var i = 0u; i < ${s}u; i++) {\n        var value = values[i];\n        ${x}\n        ${w}\n        ${v.set("batch","row","col + i","output_channel","value")};\n    }\n  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:p}}});var Un,sd,Ui,Nn=Y(()=>{"use strict";$e();pr();be();St();Un=(e,t,r,o,n=!1)=>{let s=e[0].dims,u=e[1].dims,d=s[s.length-2],a=u[u.length-1],p=s[s.length-1],h=ze(a),v=ze(p),g=ze(d),w=D.size(r)/h/g,y=e.length>2,S=o?o.slice(0,-2):r.slice(0,-2),x=[D.size(S),d,a],_=[{type:"uint32",data:w},{type:"uint32",data:d},{type:"uint32",data:a},{type:"uint32",data:p},...j(S),...j(s),...j(u)];y&&_.push(...j(e[2].dims)),_.push(...j(x));let B=E=>{let z=Ur("batch_dims",e[0].dataType,S.length),A=W("a",e[0].dataType,s.length,v),U=W("b",e[1].dataType,u.length,h),V=K("output",e[0].dataType,x.length,h),{activationFunction:G,applyActivation:Q}=nt(t,V.type.value),R=[A,U],q="";if(y){let fe=n?h:1;R.push(W("bias",e[2].dataType,e[2].dims.length,fe)),q=`${n?`value += bias[col / ${fe}];`:`value += ${V.type.value}(bias[row + i]);`}`}let pe=s.slice(0,-2),J=u.slice(0,-2),we=Ut(pe,S),Z=Ut(J,S),ye=(fe,ce)=>{let Ne=fe.rank,Be=fe.name;if(Ne===2)return`var ${Be}_indices = ${fe.type.indices}(0u, 0u);`;let He=z.rank,L=`var ${Be}_indices: ${fe.type.indices};`;for(let ne=Ne-2-1,he=He-1;ne>=0;ne--,he--)L+=`\n${Be}_indices[${ne}] = ${He>1?`batch_indices[${he}]`:"batch_indices"};`;return ce.forEach(ne=>{L+=`\n${Be}_indices[${ne}] = 0;`}),L+=`${Be}_indices[${Ne-2}] = 0u;\n                     ${Be}_indices[${Ne-1}] = 0u;`,L},Ce=()=>{let fe=`var a_data: ${A.type.value};`;for(let ce=0;ce<v;ce++)fe+=`\n              let b_data${ce} = b[(b_offset + (k + ${ce}) * uniforms.N + col) / ${h}];`;for(let ce=0;ce<g;ce++){fe+=`a_data = a[(a_offset + (row + ${ce}) * uniforms.K + k) / ${v}];`;for(let Ne=0;Ne<v;Ne++)fe+=`\n            values[${ce}] = fma(${U.type.value}(a_data${v===1?"":`[${Ne}]`}), b_data${Ne}, values[${ce}]);\n`}return fe};return`\n  ${E.registerUniform("outputSize","u32").registerUniform("M","u32").registerUniform("N","u32").registerUniform("K","u32").registerInternalVariables(z).declareVariables(...R,V)}\n  ${G}\n  ${E.mainStart()}\n    ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    let col = (global_idx % (uniforms.N / ${h})) * ${h};\n    var index1 = global_idx / (uniforms.N / ${h});\n    let stride1 = uniforms.M / ${g};\n    let row = (index1 % stride1) * ${g};\n    let batch = index1 / stride1;\n\n    ${r.length===2?"":`let batch_indices = ${z.offsetToIndices("batch")};`}\n    ${ye(A,we)}\n    let a_offset = ${A.indicesToOffset("a_indices")};\n    ${ye(U,Z)}\n    let b_offset = ${U.indicesToOffset("b_indices")};\n    var values: array<${V.type.value}, ${g}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${v}) {\n      ${Ce()}\n    }\n    for (var i = 0u; i < ${g}u; i++) {\n      var value = values[i];\n      ${q}\n      ${Q}\n      let cur_indices = ${V.type.indices}(batch, row + i, col);\n      let offset = ${V.indicesToOffset("cur_indices")};\n      ${V.setByOffset(`offset / ${h}`,"value")};\n    }\n  }\n  `};return{name:"MatMulNaive",shaderCache:{hint:`${t.activationCacheKey}_${h}_${v}_${g}_${n}`,inputDependencies:y?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:_}),getShaderSource:B}},sd=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Ui=e=>{sd(e.inputs);let t=st.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");let r=t[t.length-1],o=e.inputs[0].dims[e.inputs[0].dims.length-1];r<8&&o<8?e.compute(Un(e.inputs,{activation:"",activationCacheKey:""},t)):e.compute(en(e.inputs,{activation:"",activationCacheKey:""},t))}});var tn,Hn,ud,Ni,Gn,ld,dd,Ln,Wn=Y(()=>{"use strict";$e();ke();zi();pr();Wi();St();Nn();Nt();tn=(e,t,r,o,n,s)=>{let u=e[0],d=e.slice(s?1:2,s?3:4),a=d.length,p=t[0],v=t.slice(2).map((y,S)=>y+(y-1)*(r[S]-1)),w=d.map((y,S)=>y+o[S]+o[S+a]).map((y,S)=>Math.floor((y-v[S]+n[S])/n[S]));return w.splice(0,0,u),w.splice(s?3:1,0,p),w},Hn=[2,3,1,0],ud=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[1]*t.group;if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Ni=(e,t)=>{let r=e.kernelShape.slice();for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let o=e.pads.slice();kt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,o,e.format==="NHWC",e.autoPad);let n=Object.assign({},e);return Object.assign(n,{kernelShape:r,pads:o,cacheKey:e.cacheKey}),n},Gn=e=>{let t=Zr(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],n=e.dilations,s=e.group,u=e.kernel_shape,d=e.pads,a=e.strides,p=e.w_is_const();return ee({autoPad:o,format:r,dilations:n,group:s,kernelShape:u,pads:d,strides:a,wIsConst:p,...t})},ld=(e,t,r)=>{let o=Ni(r,t),n=r.format==="NHWC";if(r.group!==1){if(n&&t[1].dims[0]===r.group&&t[1].dims[1]===1&&r.dilations[0]===1&&r.dilations[1]===1){let A=tn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,n),U=e.kernelCustomData.wT??e.compute(et(t[1],Hn),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=U);let V=[t[0],U];t.length===3&&V.push(t[2]),e.compute(Vi(V,o,A),{inputs:V})}else e.compute(Vn(t,o));return}let s=t.length===3,u=t[0].dims[n?1:2],d=t[0].dims[n?2:3],a=t[0].dims[n?3:1],p=t[1].dims[2],h=t[1].dims[3],v=tn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,n),g=v[n?1:2],w=v[n?2:3],y=v[n?3:1],S=n&&p===u&&h===d&&r.pads[0]===0&&r.pads[1]===0;if(S||p===1&&h===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let A=v[0],U,V,G,Q=[];if(n){let pe=e.kernelCustomData.wT??e.compute(et(t[1],Hn),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=pe),S){let J=u*d*a;U=t[0].reshape([1,A,J]),V=pe.reshape([1,J,y]),G=[1,A,y]}else U=t[0].reshape([A,u*d,a]),V=pe.reshape([1,a,y]),G=[A,g*w,y];Q.push(U),Q.push(V)}else U=t[0].reshape([A,a,u*d]),V=t[1].reshape([1,y,a]),G=[A,y,g*w],Q.push(V),Q.push(U);s&&Q.push(t[2]);let R=G[2],q=Q[0].dims[Q[0].dims.length-1];R<8&&q<8?e.compute(Un(Q,o,v,G,n),{inputs:Q}):e.compute(en(Q,o,v,G,n),{inputs:Q});return}let I=!0,x=e.kernelCustomData.wT??e.compute(et(t[1],Hn),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=x);let _=[t[0],x];s&&_.push(t[2]);let B=n?g*w:y,E=n?y:g*w,z=p*h*a;e.compute(Di(_,o,v,B,E,z,s,I),{inputs:_})},dd=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let n=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),u=[1].concat(t.dilations),d=[1].concat(t.kernelShape),a=Ni({...t,pads:n,strides:s,dilations:u,kernelShape:d},o);e.compute(Vn(o,a,p=>r?[p[0],p[2],p[3]]:[]))},Ln=(e,t)=>{ud(e.inputs,t),e.inputs[0].dims.length===3?dd(e,t):ld(e,e.inputs,t)}});var cd,Hi,Gi=Y(()=>{"use strict";vt();be();St();Qr();zn();pr();cd=(e,t=!1,r,o=4)=>{let n=Le(o,"f32"),s=_=>{switch(_){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];\n            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];\n            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];\n            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${_} is not supported.`)}},u=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,d=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,a=e?"outBackprop[1]":"outBackprop[2]",p=e?"outBackprop[2]":"outBackprop[3]",h=e?"row":"col",v=e?"col":"row",g=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      let outRow = ${h} / outWidth;\n      let outCol = ${h} % outWidth;\n\n      let WRow = ${v} / (filterDims[1] * inChannels);\n      let WCol = ${v} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${a}) || fract(xR) > 0.0) {\n        return ${n}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${p}) || fract(xC) > 0.0) {\n        return ${n}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${v} % inChannels;\n      ${u}\n      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${o}];`,w=e?`\n      let col = colIn * ${o};\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${g}\n      }\n      return ${n}(0.0);`:`\n      let col = colIn * ${o};\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${g}\n      }\n      return ${n}(0.0);`,y=`\n      let col = colIn * ${o};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < uniforms.dimInner && col < uniforms.dimBOuter":"row < uniforms.dimInner && col < uniforms.dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${s(o)}\n      }\n      return ${n}(0.0);\n      `,{activationFunction:S,applyActivation:I}=nt(r,n);return`\n      ${S}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${n} {\n    ${e?w:y}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${n} {\n    ${e?y:w}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${n}) {\n    let col = colIn * ${o};\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${d}\n      ${Xr(t)}\n      ${I}\n      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${o}] = value;\n    }\n  }`},Hi=(e,t,r,o,n,s,u,d)=>{let a=t.format==="NHWC",p=a?e[0].dims[3]:e[0].dims[1],h=r[0],v=a?r[2]:r[3],g=a?r[1]:r[2],w=a?r[3]:r[1],y=a?p%4===0&&w%4===0:v%4===0&&w%4===0,S=a?w:v*g,I=a?v*g:w,x=y?[8,8,1]:[S<=4||I<=4?4:16,S>4&&I<=4?4:16,1],_=y?[4,4,1]:[S<=4?1:4,S>4&&I<=4?1:4,1],B=[Math.ceil(S/x[0]/_[0]),Math.ceil(I/x[1]/_[1]),Math.ceil(h/x[2]/_[2])];Re("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${B}`);let E=y?4:1,z=Math.max(x[0]*E,x[1]),A=y?4:1,U=[{type:"int32",data:o},{type:"int32",data:n},{type:"int32",data:s}],V=W("x",e[0].dataType,e[0].dims.length,A),G=W("w",e[1].dataType,e[1].dims.length,1),Q=K("result",e[0].dataType,r.length,A),R=[V,G];U.push(...j(e[0].dims)),U.push(...j(e[1].dims));let q="";if(u){let pe=W("bias",e[2].dataType,e[2].dims.length,A);R.push(pe),U.push(...j(e[2].dims)),q+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${y?"vec4<f32>":"f32"} {\n          return bias[coords.${a?"w":"y"}${y?"/ 4":""}];\n        }`}return U.push(...j(r)),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:B[0],y:B[1],z:B[2]},programUniforms:U}),getShaderSource:pe=>`\n        ${Jr("uniforms.result_strides")}\n        ${pe.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...R,Q)};\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[a?1:2]}, ${t.kernelShape[a?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${t.dilations[0]<=1?0:(t.kernelShape[a?1:2]-1)*(t.dilations[0]-1)},\n              ${t.dilations[1]<=1?0:(t.kernelShape[a?2:3]-1)*(t.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${o};\n        const dimBOuter : i32 = ${n};\n        const dimInner : i32 = ${s};\n        ${q}\n        ${cd(a,u,t,E)}\n        ${y?dr(_,x,"f32",void 0,!a,z):cr(_,x,"f32",void 0,!a,z,!1,void 0,d)}`}}});var pd,Fn,Li=Y(()=>{"use strict";vt();$e();be();pd=(e,t,r,o,n,s,u=!1,d)=>{let a=r.format==="NHWC",p=a?1:2,h=a?2:3,v=a?3:1,g=D.size(o),w=u?2:1,y=r.group,S=t[1].dims,I=S[0]/y,x=S[1],_=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${d}>`:d}) {\n    result[flatIndex] = ${u?`vec4<${d}>`:d}(value);\n  }`;n&&(_+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${d}>`:d} {\n      return bias[coords.${a?"w":"y"}${u?"/ 4":""}];\n    }`);let B=u?4:1,E=W("W",t[1].dataType,t[1].dims,B),z=W("Dy",t[0].dataType,t[0].dims,B),A=[z,E];n&&A.push(W("bias",t[2].dataType,[o[v]],B));let U=K("result",t[0].dataType,o,B),V=`{\n        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${s?"global_id.y":"workgroup_id.y"} * ${w};\n        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${d}>, ${w}>;\n        for (var i = 0; i < ${w}; i++) {\n          dotProd[i] = vec4<${d}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${d}(dyCorner.x) + ${d}(wR)) / ${d}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${d}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${d}(dyCorner.y) + ${d}(wC)) / ${d}(strides.y);\n            let dyC2 = (${d}(dyCorner.y) + 1.0 + ${d}(wC)) / ${d}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${d}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${d}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${z.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${z.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${d}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${v}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${z.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${z.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${w}; i = i + 1) {\n          let value = dotProd[i] + ${n?"bias[c+i]":"0.0"};\n          ${U.set("batch","r","c + i","d1","value")};\n        }\n      }`,G=`\n          let outputIndices = ${U.offsetToIndices("global_idx")};\n          let batch = ${U.indicesGet("outputIndices",0)};\n          let d1 = ${U.indicesGet("outputIndices",v)};\n          let r = ${U.indicesGet("outputIndices",p)};\n          let c = ${U.indicesGet("outputIndices",h)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${x};\n          let wOutChannel = d1 - groupId * ${x};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${d}(dyRCorner) + ${d}(wR)) / ${d}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${d}(outBackprop[${p}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${d}(dyCCorner) + ${d}(wC)) / ${d}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${d}(outBackprop[${h}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${I};\n              for (var d2: u32 = 0; d2 < ${I}; d2 = d2 + 1) {\n                let xValue = ${a?z.get("batch","idyR","idyC","inputChannel"):z.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${E.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${n?"bias[d1]":"0.0"};\n          ${U.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(...A,U)}\n  ${_}\n  const outShape : vec4<u32> = vec4<u32>(${o.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[a?1:2]}, ${r.kernelShape[a?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${r.dilations[0]<=1?0:(r.kernelShape[a?1:2]-1)*(r.dilations[0]-1)},\n          ${r.dilations[1]<=1?0:(r.kernelShape[a?2:3]-1)*(r.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(g)};\n  ${u?V:G}}`},Fn=(e,t,r)=>{let o=e.length>2,n=t.outputShape,s=D.size(n),u=[Math.ceil(s/64),1,1];Re("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${u}`);let d=Oe(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:u[0],y:u[1],z:u[2]},outputs:[{dims:r?r(n):n,dataType:e[0].dataType}]}),getShaderSource:a=>pd(a,e,t,n,o,u[1]===1&&u[2]===1,!1,d)}}});var md,fd,hd,Fi,qi,gd,yd,bd,wd,ji,Ki=Y(()=>{"use strict";ke();Gi();Li();St();Nt();md=(e,t,r,o,n,s)=>(e-1)*t+r+(o-1)*n+1-s,fd=(e,t,r,o,n)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[o]=s,r[n]=e-s):t==="SAME_LOWER"&&(r[o]=e-s,r[n]=s)},hd=(e,t,r,o,n,s,u,d,a,p)=>{let h=e.length-2,v=p.length===0;if(a.length===0)for(let y=0;y<h;++y)a.push(0);let g=e[0],w=t[d?3:1]*n;for(let y=0,S=e.length-h-(d?1:0);y<h;++y,++S){let I=e[S],x=v?I*u[y]:p[y],_=md(I,u[y],s[y],t[S],r[y],x);fd(_,o,s,y,y+h),v&&p.push(u[y]*(I-1)+a[y]+(t[S]-1)*r[y]+1-s[y]-s[y+h])}p.splice(0,0,g),p.splice(d?3:1,0,w)},Fi=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((g,w)=>g*w,1)===0){r.length=0;for(let g=2;g<t[1].dims.length;++g)r.push(t[1].dims[g])}let o=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(o?3:1,0,t[1].dims[1]);let n=e.pads.slice(),s=e.outputShape.slice(),u=e.outputPadding.slice(),d=t[0].dims,a=e.dilations.slice();if(a.reduce((g,w)=>g+w,0)===0){let g=t[0].dims.length-2;a=new Array(g).fill(1)}let p=e.strides.slice();if(p.reduce((g,w)=>g+w,0)===0){let g=t[0].dims.length-2;p=new Array(g).fill(1)}hd(d,r,a,e.autoPad,e.group,n,p,o,u,s);let h=Object.assign({},e),v=e.cacheKey+[r.join("n,"),n.join(","),p.join(","),u.join(","),s.join(","),a.join(",")].join("_");return Object.assign(h,{kernelShape:r,pads:n,outputPadding:u,outputShape:s,dilations:a,strides:p,cacheKey:v}),h},qi=e=>{let t=Zr(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],n=e.dilations,s=e.group,u=e.kernelShape,d=e.pads,a=e.strides,p=e.wIsConst(),h=e.outputPadding,v=e.outputShape;return ee({autoPad:o,format:r,dilations:n,group:s,kernelShape:u,outputPadding:h,outputShape:v,pads:d,strides:a,wIsConst:p,...t})},gd=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[0];if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==n))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((h,v)=>h+v,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((h,v)=>h+v,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((h,v)=>h+v,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((h,v)=>h+v,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},yd=[2,3,1,0],bd=(e,t,r)=>{let o=Fi(r,t),n=r.format==="NHWC",s=o.outputShape,u=s[n?3:1],d=t[0].dims[n?3:1];if(o.group!==1||u===1&&d===1){e.compute(Fn(t,o));return}let a=s[n?1:2],p=s[n?2:3],h=t[1].dims[2],v=t[1].dims[3],g=n?a*p:u,w=n?u:a*p,y=h*v*d,S=!0,I=e.kernelCustomData.wT??e.compute(et(t[1],yd),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let x=[t[0],I],_=t.length===3;_&&(!n&&t[2].dims.length===1?x.push(t[2].reshape([t[2].dims[0],1,1])):x.push(t[2])),e.compute(Hi(x,o,s,g,w,y,_,S),{inputs:x})},wd=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];o.length===3&&o.push(e.inputs[2]);let n=t.kernelShape;(n.length===0||n[0]===0)&&(n=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let u=t.strides;(u.length===0||u[0]===0)&&(u=[1]);let d=t.pads;d.length===0&&(d=[0,0]),d=[0,d[0],0,d[1]],u=[1].concat(u),s=[1].concat(s),n=[1].concat(n);let a=Fi({...t,pads:d,strides:u,dilations:s,kernelShape:n},o);e.compute(Fn(o,a,p=>r?[p[0],p[2],p[3]]:[p[0],p[1],p[3]]))},ji=(e,t)=>{gd(e.inputs,t),e.inputs[0].dims.length===3?wd(e,t):bd(e,e.inputs,t)}});var vd,Yi,Zi,Xi=Y(()=>{"use strict";Ue();$e();ke();be();vd=(e,t,r,o)=>{let n=D.size(t),s=t.length,u=W("input",e,s),d=K("output",e,s),a=r.dataType===6?r.getInt32Array()[0]:Number(r.getBigInt64Array()[0]),p=D.normalizeAxis(a,s),h=v=>{let g=` i32(${u.indicesGet("inputIndices","uniforms.axis")}) `,w=Ae("uniforms.input_shape","uniforms.axis",s),y=o.reverse?g+(o.exclusive?" + 1":""):"0",S=o.reverse?w:g+(o.exclusive?"":" + 1");return`\n                ${v.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(u,d)}\n                ${v.mainStart()}\n                  ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n                  var inputIndices = ${d.offsetToIndices("global_idx")};\n                  var sum = ${d.type.value}(0);\n                  let first : i32 = ${y};\n                  let last : i32 = ${S};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${u.indicesSet("inputIndices","uniforms.axis","u32(i)")};\n                    sum = sum + ${u.getByIndices("inputIndices")};\n                  }\n                  ${d.setByOffset("global_idx","sum")};\n                }`};return{name:"CumSum",shaderCache:{hint:o.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:[{type:"uint32",data:n},{type:"int32",data:p},...j(t),...j(t)]}),getShaderSource:h}},Yi=(e,t)=>{let r=e.inputs[0].dims,o=e.inputs[0].dataType,n=e.inputs[1];e.compute(vd(o,r,n,t),{inputs:[0]})},Zi=e=>{let t=e.exclusive===1,r=e.reverse===1;return ee({exclusive:t,reverse:r})}});var qn,rn,Qi,$d,Sd,jn,Kn,Ji,xd,es,ts,rs=Y(()=>{"use strict";$e();ke();be();qn="[a-zA-Z]|\\\\.\\\\.\\\\.",rn="("+qn+")+",Qi="^"+rn+"$",$d="("+rn+",)*"+rn,Sd="^"+$d+"$",jn=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let o=this.symbolToIndices.get(t);o===void 0?o=[r]:o.push(r),this.symbolToIndices.set(t,o)}},Kn=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,n]=r.includes("->")?r.split("->",2):[r,""];if(!o.match(RegExp(Sd)))throw new Error("Invalid LHS term");if(o.split(",").forEach((d,a)=>{let p=t[a].dims.slice();if(!d.match(RegExp(Qi)))throw new Error("Invalid LHS term");let h=this.processTerm(d,!0,p,a);this.lhs.push(h)}),n==="")n+=[...this.symbolToInfo.entries()].filter(([d,a])=>a.count===1||d==="...").map(([d])=>d).join("");else if(!n.match(RegExp(rn)))throw new Error("Invalid RHS");n.match(RegExp(qn,"g"))?.forEach(d=>{if(d==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let a=this.symbolToInfo.get(d);if(a===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(a.dimValue)}}),this.rhs=this.processTerm(n,!1,this.outputDims)}addSymbol(t,r,o){let n=this.symbolToInfo.get(t);if(n!==void 0){if(n.dimValue!==r&&n.count!==1)throw new Error("Dimension mismatch");n.count++,n.inputIndices.push(o)}else n={count:1,dimValue:r,inputIndices:[o]};this.symbolToInfo.set(t,n)}processTerm(t,r,o,n=-1){let s=o.length,u=!1,d=[],a=0;if(!t.match(RegExp(Qi))&&!r&&t!=="")throw new Error("Invalid LHS term");let p=t.match(RegExp(qn,"g")),h=new jn(n);return p?.forEach((v,g)=>{if(v==="..."){if(u)throw new Error("Only one ellipsis is allowed per input term");u=!0;let w=s-p.length+1;if(w<0)throw new Error("Ellipsis out of bounds");if(d=o.slice(a,a+w),this.hasEllipsis){if(this.ellipsisDims.length!==d.length||this.ellipsisDims.toString()!==d.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=d;else throw new Error("Ellipsis must be specified in the LHS");for(let y=0;y<d.length;y++){let S=String.fromCharCode("0".charCodeAt(0)+y);h.addSymbol(S,g+y),this.addSymbol(S,o[a++],n)}}else h.addSymbol(v,g+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(v,o[a++],n)}),h}},Ji=e=>e+"_max",xd=(e,t,r,o,n)=>{let u=t.map((w,y)=>e[y]?w.length:w).map((w,y)=>W(`input${y}`,r,w)),d=D.size(n),a=Pe(n.length),p=a?n.length:n,h=K("output",r,p),v=[...o.symbolToInfo.keys()].filter(w=>!o.rhs.symbolToIndices.has(w)),g=w=>{let y=[],S="var prod = 1.0;",I="var sum = 0.0;",x="sum += prod;",_=[],B=[],E=[],z=[],A=o.symbolToInfo.size===o.rhs.symbolToIndices.size;o.symbolToInfo.forEach((V,G)=>{if(o.rhs.symbolToIndices.has(G)){let Q=o.rhs.symbolToIndices.get(G)?.[0];Q!==void 0&&o.lhs.forEach((R,q)=>{if(V.inputIndices.includes(q)){let pe=R.symbolToIndices.get(G);if(pe===void 0)throw new Error("Invalid symbol error");pe.forEach(J=>{y.push(`${u[q].indicesSet(`input${q}Indices`,J,h.indicesGet("outputIndices",Q))}`)})}})}else o.lhs.forEach((Q,R)=>{if(V.inputIndices.includes(R)){let q=Q.symbolToIndices.get(G);if(q===void 0)throw new Error("Invalid symbol error");q.forEach(pe=>{_.push(`${u[R].indicesSet(`input${R}Indices`,pe,`${G}`)}`)}),z.push(`prod *= ${u[R].getByIndices(`input${R}Indices`)};`)}}),B.push(`for(var ${G}: u32 = 0; ${G} < uniforms.${Ji(G)}; ${G}++) {`),E.push("}")});let U=A?[...y,`let sum = ${u.map((V,G)=>V.getByIndices(`input${G}Indices`)).join(" * ")};`]:[...y,I,...B,..._,S,...z,x,...E];return`\n            ${w.registerUniforms(v.map(V=>({name:`${Ji(V)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...u,h)}\n\n            ${w.mainStart()}\n            ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${h.offsetToIndices("global_idx")};\n            ${u.map((V,G)=>`var input${G}Indices: ${u[G].type.indices};`).join(`\n`)}\n            ${U.join(`\n`)};\n            ${h.setByOffset("global_idx","sum")};\n          }`};return{name:"Einsum",shaderCache:{hint:o.equation,inputDependencies:e.map(w=>w?"rank":"dims")},getRunData:()=>{let w=v.filter(S=>o.symbolToInfo.has(S)).map(S=>({type:"uint32",data:o.symbolToInfo.get(S)?.dimValue||0}));w.push({type:"uint32",data:d});let y=t.filter((S,I)=>e[I]).map((S,I)=>[...j(S)]).reduce((S,I)=>S.concat(I),w);return a&&y.push(...j(n)),{outputs:[{dims:n,dataType:r}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:y}},getShaderSource:g}},es=(e,t)=>{let r=new Kn(e.inputs,t.equation),o=e.inputs.map((u,d)=>Pe(u.dims.length)),n=r.outputDims,s=e.inputs.map((u,d)=>u.dims);e.compute(xd(o,s,e.inputs[0].dataType,r,n))},ts=e=>{let t=e.equation.replace(/\\s+/g,"");return ee({equation:t})}});var Cd,ns,_d,Id,os,as=Y(()=>{"use strict";Ue();$e();be();Cd=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=r.length<t.length?0:r.length-t.length,n=t.length<r.length?0:t.length-r.length;for(;o<r.length&&n<t.length;++o,++n)if(r[o]!==t[n]&&r[o]!==1&&t[n]!==1)throw new Error("Expand requires shape to be broadcastable to input")},ns=(e,t)=>{let r=e.length-t.length,o=[];for(let n=0;n<r;++n)o.push(e[n]);for(let n=0;n<t.length;++n)o.push(t[n]===1?e[n+r]:t[n]);return o},_d=(e,t)=>e.length>t.length?ns(e,t):ns(t,e),Id=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=_d(t,r),n=e[0].dataType,s=n===9?4:1,u=D.size(o)/s,d=Pe(t.length),a=Pe(o.length),p=v=>{let g=d?t.length:t,w=a?o.length:o,y=W("input",n,g,s),S=K("output",n,w,s),I;if(n===9){let x=(_,B,E="")=>`\n          let outputIndices${B} = ${S.offsetToIndices(`outputOffset + ${B}u`)};\n          let offset${B} = ${y.broadcastedIndicesToOffset(`outputIndices${B}`,S)};\n          let index${B} = offset${B} / 4u;\n          let component${B} = offset${B} % 4u;\n          ${_}[${B}] = ${E}(${y.getByOffset(`index${B}`)}[component${B}]);\n        `;I=`\n        let outputOffset = global_idx * ${s};\n        var data = vec4<u32>(0);\n        ${x("data",0,"u32")}\n        ${x("data",1,"u32")}\n        ${x("data",2,"u32")}\n        ${x("data",3,"u32")}\n        ${S.setByOffset("global_idx","data")}\n      }`}else I=`\n        let outputIndices = ${S.offsetToIndices("global_idx")};\n        let inputOffset = ${y.broadcastedIndicesToOffset("outputIndices",S)};\n        ${S.setByOffset("global_idx",y.getByOffset("inputOffset"))}\n      }`;return`\n    ${v.registerUniform("vec_size","u32").declareVariables(y,S)}\n    ${v.mainStart()}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${I}`},h=[{type:"uint32",data:u}];return d&&h.push(...j(t)),a&&h.push(...j(o)),{name:"Expand",shaderCache:{hint:`${o.length}`,inputDependencies:[d?"rank":"dims"]},getShaderSource:p,getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:h})}},os=e=>{Cd(e.inputs),e.compute(Id(e.inputs),{inputs:[0]})}});var Ad,Td,is,ss,us=Y(()=>{"use strict";Ue();$e();ke();be();Ad=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},Td=(e,t)=>{let r=e[0].dims,o=e[1].dims,n=r.length,s=D.normalizeAxis(t.axis,n),u=r.slice(0);u.splice(s,1,...o);let d=r[s],a=e[0].dataType===9?4:1,p=D.size(u)/a,h=Pe(e[0].dims.length),v=h?e[0].dims.length:e[0].dims,g=Pe(e[1].dims.length),w=g?e[1].dims.length:e[1].dims,y=Pe(u.length),S=y?u.length:u,I=[{type:"uint32",data:p},{type:"int32",data:d},{type:"uint32",data:s}];h&&I.push(...j(e[0].dims)),g&&I.push(...j(e[1].dims)),y&&I.push(...j(u));let x=[];x.push(h?"rank":"dims"),x.push(g?"rank":"dims");let _=B=>{let E=W("data",e[0].dataType,v,a),z=W("inputIndices",e[1].dataType,w),A=K("output",e[0].dataType,S,a),U=G=>{let Q=o.length,R=`var indicesIndices${G}  = ${z.type.indices}(0);`;for(let q=0;q<Q;q++)R+=`${Q>1?`indicesIndices${G}[${q}]`:`indicesIndices${G}`} = ${u.length>1?`outputIndices${G}[uniforms.axis + ${q}]`:`outputIndices${G}`};`;R+=`\n          var idx${G} = ${z.getByIndices(`indicesIndices${G}`)};\n          if (idx${G} < 0) {\n            idx${G} = idx${G} + uniforms.axisDimLimit;\n          }\n          var dataIndices${G} = ${E.type.indices}(0);\n        `;for(let q=0,pe=0;q<n;q++)q===s?(R+=`${n>1?`dataIndices${G}[${q}]`:`dataIndices${G}`} = u32(idx${G});`,pe+=Q):(R+=`${n>1?`dataIndices${G}[${q}]`:`dataIndices${G}`} = ${u.length>1?`outputIndices${G}[${pe}]`:`outputIndices${G}`};`,pe++);return R},V;if(e[0].dataType===9){let G=(Q,R,q="")=>`\n          let outputIndices${R} = ${A.offsetToIndices(`outputOffset + ${R}u`)};\n          ${U(R)};\n          let offset${R} = ${E.indicesToOffset(`dataIndices${R}`)};\n          let index${R} = offset${R} / 4u;\n          let component${R} = offset${R} % 4u;\n          ${Q}[${R}] = ${q}(${E.getByOffset(`index${R}`)}[component${R}]);\n        `;V=`\n        let outputOffset = global_idx * ${a};\n        var value = vec4<u32>(0);\n        ${G("value",0,"u32")}\n        ${G("value",1,"u32")}\n        ${G("value",2,"u32")}\n        ${G("value",3,"u32")}\n        ${A.setByOffset("global_idx","value")}\n      `}else V=`\n      let outputIndices = ${A.offsetToIndices("global_idx")};\n      ${U("")};\n      let value = ${E.getByIndices("dataIndices")};\n      ${A.setByOffset("global_idx","value")};\n      `;return`\n      ${B.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(E,z,A)}\n      ${B.mainStart()}\n        ${B.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${V}\n      }`};return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:x},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:I}),getShaderSource:_}},is=e=>ee({axis:e.axis}),ss=(e,t)=>{let r=e.inputs;Ad(r),e.compute(Td(e.inputs,t))}});var Ed,Od,ls,ds,cs=Y(()=>{"use strict";$e();ke();be();Ed=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Od=(e,t)=>{let r=e[0].dims,o=e[0].dataType,n=r.length,s=e[1].dims,u=e[1].dataType,d=D.normalizeAxis(t.axis,n),a=r[d],p=s.slice(0),h=D.size(p),v=W("input",o,n),g=W("indicesInput",u,s.length),w=K("output",o,p.length),y=[{type:"uint32",data:h},{type:"int32",data:a},{type:"uint32",data:d}];return y.push(...j(r)),y.push(...j(s)),y.push(...j(p)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:y}),getShaderSource:x=>`\n      ${x.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(v,g,w)}\n      ${x.mainStart()}\n      ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n      let outputIndices = ${w.offsetToIndices("global_idx")};\n\n      var idx = ${g.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${v.type.indices}(outputIndices);\n      ${v.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\n      let value = ${v.getByIndices("inputIndices")};\n\n      ${w.setByOffset("global_idx","value")};\n  }`}},ls=e=>ee({axis:e.axis}),ds=(e,t)=>{let r=e.inputs;Ed(r),e.compute(Od(e.inputs,t))}});var kd,Pd,Rd,ps,ms,fs=Y(()=>{"use strict";$e();ke();be();kd=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Pd=(e,t,r)=>{if(r.length===0)return"0u";let o=r.length===1&&e!==1||r.length===2&&r[0]!==e,n=r[r.length-1]!==t,s="0u";return o||(s+=`+ m * ${r[r.length-1]}u`),n||(s+="+n"),s},Rd=(e,t)=>{let r=e[0].dims.slice(),o=e[1].dims.slice(),[n,s,u]=zr.getShapeOfGemmResult(r,t.transA,o,t.transB,e.length===3?e[2].dims:void 0),d=[n,s];if(!d)throw new Error("Can\'t use gemm on the given tensors");let a=D.size(d),p="";t.transA&&t.transB?p="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?p="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?p="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(p="value += a[m * K + k] * b[k * N + n];");let h=Oe(e[0].dataType),v=t.alpha===1?"":"value *= alpha;",g=e.length===3?`value += beta * c[${Pd(n,s,e[2].dims)}];`:"",w=[`@group(0) @binding(0) var<storage, read> a : array<${h}>;`,`@group(0) @binding(1) var<storage, read> b : array<${h}>;`];e.length===3&&w.push(`@group(0) @binding(2) var<storage, read> c : array<${h}>;`);let y=S=>`\n  const M: u32 = ${n}u;\n  const N: u32 = ${s}u;\n  const K: u32 = ${u}u;\n  const alpha = ${h}(${t.alpha});\n  const beta = ${h}(${t.beta});\n\n  ${w.join(`\n`)}\n  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${h}>;\n\n  ${S.mainStart()}\n    ${S.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${h}(0);\n    for (var k: u32 = 0u; k<${u}u; k++) {\n      ${p}\n    }\n\n    ${v}\n    ${g}\n    output[global_id.x] = value;\n\n  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:y}},ps=(e,t)=>{kd(e.inputs),e.compute(Rd(e.inputs,t))},ms=e=>ee(e)});var Bd,Md,Dd,zd,hs,gs,ys=Y(()=>{"use strict";Ue();$e();ke();be();Bd={name:"InstanceNormalization"},Md=(e,t)=>{let r=e[0].dims,o=r,n=2,s=D.sizeToDimension(r,n),u=D.sizeFromDimension(r,n),d=ze(u),a=u/d,p=r[1],h=W("x",e[0].dataType,[r[0],r[1],a],d),v=W("scale",e[1].dataType,e[1].dims),g=W("bias",e[2].dataType,e[2].dims),w=K("output",e[0].dataType,[r[0],r[1],a],d),y=[h,v,g,w],S=h.type.value,I=d===1?"f32":`vec${d}<f32>`,x=64,_=B=>`\n\n  const C: u32 = ${p};\n  const normSize: u32 = ${u};\n  const epsilon: f32 = ${t.epsilon};\n  var<workgroup> meanShared : f32;\n  var<workgroup> squaredNormShared : f32;\n  var<workgroup> workgroupShared : array<${I}, ${x}>;\n  const workgroupSize = ${x}u;\n  ${B.declareVariables(...y)}\n  ${B.mainStart(x)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial = ${I}(0);\n    for (var h = localIndex; h < ${a}; h += workgroupSize) {\n      initial = initial + ${I}(${h.get("batch","channel","h")});\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = ${Xe("workgroupShared[0]",d)} / f32(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = ${I}(0);\n    for (var h = localIndex; h < ${a}; h += workgroupSize) {\n      let deviation =  ${I}(${h.get("batch","channel","h")}) - ${I}(meanShared);\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = ${Xe("workgroupShared[0]",d)};\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / f32(normSize) + epsilon);\n    let channelScale = invStdDev * f32(${v.getByOffset("channel")});\n    let channelShift = f32(${g.getByOffset("channel")}) - meanShared * channelScale;\n    for (var h = localIndex; h < ${a}; h += workgroupSize) {\n      let value = ${h.get("batch","channel","h")} * ${S}(${I}(channelScale)) + ${S}(${I}(channelShift));\n      ${w.set("batch","channel","h","value")};\n    }\n  }`;return{...Bd,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:s}}),getShaderSource:_}},Dd=(e,t,r,o,n,s,u,d)=>{let a=ze(u),p=W("input",t.dataType,t.dims,a),h=W("scale",r.dataType,r.dims,a),v=W("bias",o.dataType,o.dims,a),g=64,w=a===1?"vec2f":`mat2x${a}f`,y=a===1?"f32":`vec${a}f`,S=(z,A)=>`${w}(${z}, ${A})`,I=n*u/a,x=Math.ceil(s/g),_=z=>`\n  const H: u32 = ${s};\n  const C: u32 = ${u/a};\n  const imageSize: u32 = ${s*u/a};\n\n  ${z.declareVariables(p)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${w}>;\n\n  ${z.mainStart(g)}\n    let currentImageNumber = global_idx / ${g} / C;\n    let currentChannelNumber = (global_idx / ${g}) % C;\n    let wgId = global_idx % ${g};\n    let wgOffset = wgId * ${x};\n    if (wgOffset >= H) {\n        return;\n    }\n    let wgMax = min(wgOffset + ${x}, H);\n\n    let offset = currentImageNumber * imageSize + currentChannelNumber;\n    var sum = ${je("f32",a)};\n    var squaredSum = ${je("f32",a)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${y}(input[offset + i * C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${S("sum","squaredSum")};\n  }`,B=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:a,n,h:s,c:u})},getRunData:()=>({outputs:[{dims:[n,u,g,2],dataType:1}],dispatchGroup:{x:n*u/a}}),getShaderSource:_},{inputs:[t],outputs:[-1]})[0],E=z=>`\n  const H: u32 = ${s};\n  const C: u32 = ${u/a};\n  const imageSize: u32 = ${g*u/a};\n  const epsilon: f32 = ${d};\n\n  @group(0) @binding(0) var<storage, read> input : array<${w}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${h.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${v.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${w}>;\n\n  ${z.mainStart()}\n    ${z.guardAgainstOutOfBoundsWorkgroupSizes(I)}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    let offset = currentImageNumber * imageSize;\n    var sum = ${je("f32",a)};\n    var squaredSum = ${je("f32",a)};\n    for (var i: u32 = 0; i < ${g}; i++) {\n        let value = input[offset + i + currentChannelNumber * ${g}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(H);\n    squaredSum = squaredSum / f32(H);\n    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);\n    let channelScale = invStdDev * ${y}(scale[currentChannelNumber]);\n    let channelShift = ${y}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${S("channelScale","channelShift")};\n  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:a,n,h:s,c:u,epsilon:d})},getRunData:()=>({outputs:[{dims:[n,u,2],dataType:1}],dispatchGroup:{x:Math.ceil(I/64)}}),getShaderSource:E},{inputs:[B,r,o],outputs:[-1]})[0]},zd=(e,t,r)=>{let o=t[0].dims,n=o,s=o[0],u=o[o.length-1],d=D.sizeFromDimension(o,1)/u,a=ze(u),p=D.size(n)/a,h=W("input",t[0].dataType,t[0].dims,a),v=K("output",t[0].dataType,n,a),g=Oe(t[0].dataType),w=a===1?"vec2f":`mat2x${a}f`,y=a===1?g:`vec${a}<${g}>`,S=Dd(e,t[0],t[1],t[2],s,d,u,r.epsilon),I=x=>`\n  const H: u32 = ${d};\n  const C: u32 = ${u/a};\n\n  @group(0) @binding(0) var<storage, read> input : array<${h.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${w}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${v.type.storage}>;\n\n  ${x.mainStart()}\n    let currentImageNumber = global_idx / (C * H);\n    let currentChannelNumber = global_idx % C;\n\n    let scaleOffset = currentImageNumber * C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${y}(scale[0]), ${y}(scale[1]));\n  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${r.cacheKey}`},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:I},{inputs:[t[0],S]})},hs=e=>ee({epsilon:e.epsilon,format:e.format}),gs=(e,t)=>{t.format==="NHWC"?zd(e,e.inputs,t):e.compute(Md(e.inputs,t))}});var Vd,Wd,bs,ws,vs=Y(()=>{"use strict";Ue();$e();ke();be();Vd=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Wd=(e,t,r)=>{let o=e[0].dims,n=e[1],s=e[2],u=o,d=D.normalizeAxis(t.axis,o.length),a=D.sizeToDimension(o,d),p=D.sizeFromDimension(o,d),h=D.size(n.dims),v=s?D.size(s.dims):0;if(h!==p||s&&v!==p)throw new Error(`Size of X.shape()[axis:] == ${p}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${h} and bias size of ${v}`);let g=[];for(let E=0;E<o.length;++E)E<d?g.push(o[E]):g.push(1);let w=ze(p),y=Oe(e[0].dataType),S=[W("x",e[0].dataType,e[0].dims,w),W("scale",n.dataType,n.dims,w)];s&&S.push(W("bias",s.dataType,s.dims,w)),S.push(K("output",e[0].dataType,u,w));let I=r>1,x=r>2;I&&S.push(K("meanDataOutput",1,g)),x&&S.push(K("invStdOutput",1,g));let _=E=>`\n  const normSize: f32 = ${p};\n  const normSizeVectorized: u32 = ${p/w};\n  const epsilon: f32 = ${t.epsilon};\n\n  ${E.declareVariables(...S)}\n  ${E.mainStart()}\n    ${E.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let offset = global_idx * normSizeVectorized;\n    var meanVector = ${je("f32",w)};\n    var meanSquareVector = ${je("f32",w)};\n\n    for (var h: u32 = 0u; h < normSizeVectorized; h++) {\n      let value = ${rt(y,w,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${Xe("meanVector",w)} / normSize;\n    let meanSquare = sqrt(${Xe("meanSquareVector",w)} \n      / normSize - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSizeVectorized; j++) {\n      let f32input = ${rt(y,w,"x[j + offset]")};\n      let f32scale = ${rt(y,w,"scale[j]")};\n      output[j + offset] = ${S[0].type.value}((f32input - mean) / meanSquare * f32scale\n        ${s?`+ ${rt(y,w,"bias[j]")}`:""}\n      );\n    }\n\n    ${I?"meanDataOutput[global_idx] = mean":""};\n    ${x?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`,B=[{dims:u,dataType:e[0].dataType}];return I&&B.push({dims:g,dataType:1}),x&&B.push({dims:g,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:B,dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:_}},bs=e=>ee({axis:e.axis,epsilon:e.epsilon}),ws=(e,t)=>{Vd(e.inputs),e.compute(Wd(e.inputs,t,e.outputCount))}});var Ud,Ss,$s,Nd,Yn,xs,Cs=Y(()=>{"use strict";$e();ke();Mr();Bn();be();Nt();Ud=(e,t)=>{let r=e[0],o=e[1],n=e[2],s=e[3],u=e[4],d=e[5],a=e[6],p=e[7];if(r.dims.length!==3&&r.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let h=!1,v=r.dims[0],g=r.dims[1],w=r.dims.length===3?h?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],y=g,S=0,I=0,x=Math.floor(w/t.numHeads);if(a&&p){if(a.dims.length!==4)throw new Error(\'Input "past_key" is expected to have 4 dimensions\');if(p.dims.length!==4)throw new Error(\'Input "past_value" is expected to have 4 dimensions\');S=a.dims[2],I=a.dims[2]}else if(a||p)throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');let _;if(o){if(r.dims.length!==3)throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');if(o.dims.length<3||o.dims.length>5)throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');if(r.dims[0]!==o.dims[0])throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');if(o.dims.length===3){if(o.dims[2]!==r.dims[2])throw new Error(\'Input "query" and "key" shall have same dim 2 (hidden_size)\');_=2,y=o.dims[1]}else if(o.dims.length===5){if(o.dims[2]!==t.numHeads||o.dims[3]!==2||o.dims[4]!==x)throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');if(n)throw new Error(\'Expect "value" be none when "key" has packed kv format.\');_=5,y=o.dims[1]}else{if(o.dims[1]!==t.numHeads||o.dims[3]!==x)throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');_=0,y=o.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\'Input "query" is expected to have 3 or 5 dimensions when key is empty\');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');_=3}if(s){if(s.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimension\');if(n&&r.dims.length===5&&r.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let B=0;if(u){B=8;let V=u.dims;throw V.length===1?V[0]===v?B=1:V[0]===3*v+2&&(B=3):V.length===2&&V[0]===v&&V[1]===y&&(B=5),B===8?new Error(\'Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)\'):new Error("Mask not supported")}let E=!1,z=w;if(n){if(n.dims.length!==3&&n.dims.length!==4)throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');if(r.dims[0]!==n.dims[0])throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');if(n.dims.length===3){if(y!==n.dims[1])throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');z=n.dims[2]}else{if(y!==n.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)\');z=n.dims[1]*n.dims[3],E=!0}}let A=S+y,U=!1;if(u)throw new Error("Key padding mask is not supported");if(d)throw new Error("extraAddQk is not supported");if(a)throw new Error("pastKey is not supported");if(p)throw new Error("pastValue is not supported");return{batchSize:v,sequenceLength:g,pastSequenceLength:S,kvSequenceLength:y,totalSequenceLength:A,maxSequenceLength:I,inputHiddenSize:0,hiddenSize:w,vHiddenSize:z,headSize:x,vHeadSize:Math.floor(z/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:B,scale:t.scale,broadcastResPosBias:U,passPastInKv:E,qkvFormat:_}},Ss=e=>ee({...e}),$s=ee({perm:[0,2,1,3]}),Nd=(e,t,r,o,n,s,u)=>{let d=[o,n,s],a=D.size(d),p=Oe(t.dataType),h=v=>`\n  const biasOffset = ${u}u;\n  const hiddenSize = ${s}u;\n\n  @group(0) @binding(0) var<storage, read> qkv: array<${p}>;\n  @group(0) @binding(1) var<storage, read> bias: array<${p}>;\n  @group(0) @binding(2) var<storage, read_write> qkv_with_bias: array<${p}>;\n\n  ${v.mainStart()}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let biasOffsetIdx = (global_idx % hiddenSize) + biasOffset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[biasOffsetIdx];\n  }`;return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{hint:JSON.stringify({batchSize:o,sequenceLength:n,hiddenSize:s,biasOffset:u})},getRunData:()=>({outputs:[{dims:d,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:h},{inputs:[t,r],outputs:[-1]})[0]},Yn=(e,t,r,o,n,s,u,d)=>{let a=s;if(u){if(o===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return a=Nd(e,s,u,t,o,r*n,d),a=a.reshape([t,o,r,n]),e.compute(et(a,$s.perm),{inputs:[a],outputs:[-1]})[0]}else return s.dims.length===3&&(a=s.reshape([t,o,r,n])),e.compute(et(a,$s.perm),{inputs:[a],outputs:[-1]})[0]},xs=(e,t)=>{let r=Ud(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(e.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let o=e.inputs[1]&&e.inputs[2]&&e.inputs[1].dims.length===4&&e.inputs[2].dims.length===4,n=Yn(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,e.inputs[0],e.inputs[3],0);if(o)return Gr(e,n,e.inputs[1],e.inputs[2],e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t);let s=Yn(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,e.inputs[1],e.inputs[3],r.hiddenSize),u=Yn(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,e.inputs[2],e.inputs[3],2*r.hiddenSize);Gr(e,n,s,u,e.inputs[4],void 0,e.inputs[6],e.inputs[7],e.inputs[5],r,t)}});var Hd,Gd,Ld,Fd,qd,jd,Kd,Yd,Zd,_s,Is,As=Y(()=>{"use strict";Ue();$e();ke();be();Hd=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Gd=(e,t,r,o,n,s)=>{let u=t.length,d="";for(let a=u-1;a>=0;--a)d+=`\n            k = i32(${e.indicesGet("indices",a)}) - ${o[a]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${t[a]}) {\n              break;\n            }\n            offset += k * ${r[a]};\n        `;return`\n          value = ${n}(${s});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${d}\n            value = x[offset];\n          }\n      `},Ld=(e,t,r,o)=>{let n=t.length,s="";for(let u=n-1;u>=0;--u)s+=`\n                k = i32(${e.indicesGet("indices",u)}) - ${o[u]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(t[u]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${t[u]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${r[u]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${s}\n              value = x[offset];\n          `},Fd=(e,t,r,o)=>{let n=t.length,s="";for(let u=n-1;u>=0;--u)s+=`\n                k = i32(${e.indicesGet("indices",u)}) - ${o[u]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${t[u]}) {\n                  k = ${t[u]-1};\n                }\n                offset += k * ${r[u]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${s}\n              value = x[offset];\n          `},qd=(e,t,r,o)=>{let n=t.length,s="";for(let u=n-1;u>=0;--u)s+=`\n                k = i32(${e.indicesGet("indices",u)}) - ${o[u]};\n                if (k < 0)  {\n                  k += ${t[u]};\n                }\n                if (k >= ${t[u]}) {\n                  k -= ${t[u]};\n                }\n                offset += k * ${r[u]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${s}\n              value = x[offset];\n          `},jd=(e,t,r,o,n)=>{switch(o.mode){case 0:return Gd(e,t,r,o.pads,n,o.value);case 1:return Ld(e,t,r,o.pads);case 2:return Fd(e,t,r,o.pads);case 3:return qd(e,t,r,o.pads);default:throw new Error("Invalid mode")}},Kd=(e,t,r,o)=>{let n=t[0].dims,s=D.padShape(n.slice(),r.pads),u=D.size(s),d=D.computeStrides(n),a=K("output",t[0].dataType,s),p=W("x",t[0].dataType,n),h=jd(a,n,d,r,o);return`\n              ${e.declareVariables(p,a)}\n              ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n\n              let indices = ${a.offsetToIndices("global_idx")};\n\n              var value = ${o}(0);\n              ${h}\n              output[global_idx] = value;\n          }`},Yd=(e,t)=>{let r=D.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(D.size(r)/64)}}),getShaderSource:o=>Kd(o,e,t,"f32")}},Zd=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),o=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,n=e[0].dims.length,s=new Int32Array(2*n).fill(0);if(e.length>=4){let d=e[3].getBigInt64Array();for(let a=0;a<d.length;a++)s[Number(d[a])]=Number(r[a]),s[Number(d[a])+n]=Number(r[a+d.length])}else r.forEach((d,a)=>s[Number(a)]=Number(d));let u=[];return s.forEach(d=>u.push(d)),ee({mode:t.mode,value:o,pads:u})}else return t},_s=(e,t)=>{Hd(e.inputs);let r=Zd(e.inputs,t);e.compute(Yd(e.inputs,r),{inputs:[0]})},Is=e=>{let t=e.mode,r=e.value,o=e.pads;return ee({mode:t,value:r,pads:o})}});var nn,Ts,Es,Os,ks,Ps,Rs,Bs,Ms,Ds,zs,Vs,Ws,Us,Ns,Hs,Gs=Y(()=>{"use strict";jr();$e();ke();be();nn=e=>{if(Ht.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error("Pool ops requires 1 input.")},Ts=(e,t,r)=>{let o=t.format==="NHWC",n=e.dims.slice();o&&n.splice(1,0,n.pop());let s=Object.hasOwnProperty.call(t,"dilations"),u=t.kernelShape.slice(),d=t.strides.slice(),a=s?t.dilations.slice():[],p=t.pads.slice();kt.adjustPoolAttributes(r,n,u,d,a,p);let h=kt.computePoolOutputShape(r,n,d,a,u,p,t.autoPad),v=Object.assign({},t);s?Object.assign(v,{kernelShape:u,strides:d,pads:p,dilations:a,cacheKey:t.cacheKey}):Object.assign(v,{kernelShape:u,strides:d,pads:p,cacheKey:t.cacheKey});let g=h.slice();return g.push(g.splice(1,1)[0]),[v,o?g:h]},Es=(e,t)=>{let r=t.format==="NHWC",o=D.size(e),n=D.size(t.kernelShape),s=[{type:"uint32",data:o},{type:"uint32",data:n}],u=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let d=t.kernelShape[t.kernelShape.length-1],a=t.strides[t.strides.length-1],p=t.pads[t.pads.length/2-1],h=t.pads[t.pads.length-1],v=!!(p+h);s.push({type:"uint32",data:d},{type:"uint32",data:a},{type:"uint32",data:p},{type:"uint32",data:h}),u.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let g=!1;if(t.kernelShape.length===2){let w=t.kernelShape[t.kernelShape.length-2],y=t.strides[t.strides.length-2],S=t.pads[t.pads.length/2-2],I=t.pads[t.pads.length-2];g=!!(S+I),s.push({type:"uint32",data:w},{type:"uint32",data:y},{type:"uint32",data:S},{type:"uint32",data:I}),u.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[s,u,!0,v,g]}else{if(r)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let d=D.computeStrides(t.kernelShape);s.push({type:"uint32",data:d},{type:"uint32",data:t.pads},{type:"uint32",data:t.strides}),u.push({name:"kernelStrides",type:"u32",length:d.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let a=t.pads.reduce((p,h)=>p+h);return[s,u,!!a,!1,!1]}},Os=(e,t,r,o,n,s,u,d,a,p,h,v)=>{let g=n.format==="NHWC",w=t.type.value,y=K("output",t.type.tensor,o);if(n.kernelShape.length<=2){let S="",I="",x="",_=r-(g?2:1);if(h===!0?S=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${_}] < 0 || xIndices[${_}]\n                      >= uniforms.x_shape[${_}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`:S=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`,n.kernelShape.length===2){let E=r-(g?3:2);v===!0?I=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${E}] = indices[${E}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${E}] < 0 || xIndices[${E}] >= uniforms.x_shape[${E}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:I=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${E}] = indices[${E}] * uniforms.sh - uniforms.phStart + j;\n                `,x=`\n              }\n            `}return`\n            ${e.registerUniforms(a).declareVariables(t,y)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n              let indices = ${y.offsetToIndices("global_idx")};\n              var xIndices = ${y.offsetToIndices("global_idx")};\n\n              var value = ${w}(${d});\n              var pad = 0;\n              ${I}\n              ${S}\n              ${x}\n              ${u}\n\n              output[global_idx] = value;\n            }`}else{if(g)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let S=n.kernelShape.length,I=n.pads.length,x="";return p?x=`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${s}\n              }`:x=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${s}\n            `,`\n            ${e.registerUniforms(a).declareVariables(t,y)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n              let indices = ${y.offsetToIndices("global_idx")};\n              var xIndices = ${y.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${S}>;\n\n              var value = ${w}(${d});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${S-1}u; j++) {\n                  offsets[j] = offset / ${Ae("uniforms.kernelStrides","j",S)};\n                  offset -= offsets[j] * ${Ae("uniforms.kernelStrides","j",S)};\n                }\n                offsets[${S-1}] = offset;\n\n                isPad = false;\n                for (var j = ${r-S}u; j < ${r}u; j++) {\n                  xIndices[j] = indices[j] * ${Ae("uniforms.strides",`j - ${r-S}u`,S)}\n                    + offsets[j - ${r-S}u] - ${Ae("uniforms.pads","j - 2u",I)};\n                  ${x}\n              }\n              ${u}\n\n              output[global_idx] = value;\n            }`}},ks=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Ps=(e,t,r,o)=>{let[n,s]=Ts(t,o,r),u=W("x",t.dataType,t.dims.length),d=u.type.value,a="value += x_val;",p="";n.countIncludePad?p+=`value /= ${d}(uniforms.kernelSize);`:p+=`value /= ${d}(i32(uniforms.kernelSize) - pad);`;let[h,v,g,w,y]=Es(s,n);h.push(...j(t.dims)),h.push(...j(s));let S=["rank"];return{name:e,shaderCache:{hint:o.cacheKey+g+w+y+n.countIncludePad,inputDependencies:S},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(D.size(s)/64)},programUniforms:h}),getShaderSource:I=>Os(I,u,t.dims.length,s.length,n,a,p,0,v,g,w,y)}},Rs=e=>{let t=e.count_include_pad!==0,r=ks(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ee({countIncludePad:t,...r})},Bs=(e,t)=>{nn(e.inputs),e.compute(Ps("AveragePool",e.inputs[0],!1,t))},Ms={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Ds=e=>{let t=e.format;return{format:t,...Ms,cacheKey:t}},zs=(e,t)=>{nn(e.inputs),e.compute(Ps("GlobalAveragePool",e.inputs[0],!0,t))},Vs=(e,t,r,o)=>{let[n,s]=Ts(t,o,r),u=`\n      value = max(x_val, value);\n    `,d="",a=W("x",t.dataType,t.dims.length),p=["rank"],[h,v,g,w,y]=Es(s,n);return h.push(...j(t.dims)),h.push(...j(s)),{name:e,shaderCache:{hint:o.cacheKey+g,inputDependencies:p},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(D.size(s)/64)},programUniforms:h}),getShaderSource:S=>Os(S,a,t.dims.length,s.length,n,u,d,-1e5,v,g,w,y)}},Ws=(e,t)=>{nn(e.inputs),e.compute(Vs("MaxPool",e.inputs[0],!1,t))},Us=e=>{let t=e.storage_order,r=e.dilations,o=ks(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ee({storageOrder:t,dilations:r,...o})},Ns=e=>{let t=e.format;return{format:t,...Ms,cacheKey:t}},Hs=(e,t)=>{nn(e.inputs),e.compute(Vs("GlobalMaxPool",e.inputs[0],!0,t))}});var Qd,Jd,Ls,Fs=Y(()=>{"use strict";jr();Ue();be();Qd=(e,t,r)=>{let o=e===t,n=e<t&&r<0,s=e>t&&r>0;if(o||n||s)throw new Error("Range these inputs\' contents are invalid.")},Jd=(e,t,r,o)=>{let n=Math.abs(Math.ceil((t-e)/r)),s=[n],u=n,d=K("output",o,s),a=d.type.storage,p=h=>`\n        ${h.declareVariables(d)}\n        ${h.mainStart()}\n        ${h.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        output[global_idx] = ${a}(${e}) + ${a}(global_idx) * ${a}(${r});\n      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(h=>h.toString()).join("_")},getShaderSource:p,getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(u/64)}})}},Ls=e=>{let t=0,r=0,o=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],o=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],o=e.inputs[2].getFloat32Array()[0]),Ht.webgpu.validateInputContent&&Qd(t,r,o),e.compute(Jd(t,r,o,e.inputs[0].dataType),{inputs:[]})}});var ec,tc,rc,nc,oc,ac,ic,sc,uc,lc,dc,cc,pc,mc,fc,qs,js,Ks=Y(()=>{"use strict";$e();ke();be();ec=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},tc=(e,t,r)=>{t.every(n=>n>=0&&n<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let o=new Array(r).fill(1);return t.forEach((n,s)=>o[n]=e[s]),o},rc=(e,t,r,o,n,s)=>{let[u,d,a]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],p=e[0].dims.length;if(u>0&&e.length>u&&e[u].dims.length>0)e[u].getFloat32Array().forEach(h=>s.push(h));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(d>0&&e.length>d&&e[d].dims.length>0){if(e[d].getFloat32Array().forEach(h=>o.push(h)),o.length!==0&&o.length!==p&&r>=18&&o.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");ec(o,t),t.axes.length>0&&tc(o,t.axes,p).forEach((h,v)=>o[v]=h)}if(a>0&&e.length>a&&(e[a].getBigInt64Array().forEach(h=>n.push(Number(h))),n.length!==p||r>=18&&n.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(o.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(n.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof o<"u"&&typeof n<"u"&&o.length>0&&n.length>p)throw new Error("Resize requires only of scales or sizes to be specified")},nc=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: ${t}, xScale: ${t}, lengthResized: ${t},\n     lengthOriginal: ${t}, roiStart: ${t}, roiEnd: ${t}) -> ${t} { `+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return`if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * ${t}(lengthOriginal - 1);                   }`;case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`\n`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",oc=(e,t,r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",ac=(e,t,r)=>{let o=new Array(r).fill(0).concat(new Array(r).fill(1)),n=e.length===0?o:e.slice();return t.length>0?(t.forEach((s,u)=>{o[s]=n[u],o[u+r]=n[t.length+u]}),o):n},ic=(e,t,r,o)=>{let n=[];if(r.length>0)if(o.length>0){if(e.forEach(s=>n.push(s)),Math.max(...o)>e.length)throw new Error("axes is out of bound");o.forEach((s,u)=>n[s]=r[u])}else r.forEach(s=>n.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");n=e.map((s,u)=>Math.round(s*t[u]))}return n},sc=(e,t,r)=>{let o=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map(s=>t[s]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map(s=>t[s]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let n=e.slice();return r.axes.length>0?(r.axes.forEach(s=>t[s]=o),r.axes.forEach(s=>n[s]=Math.round(e[s]*t[s]))):(t.fill(o,0,t.length),n.forEach((s,u)=>n[u]=Math.round(s*t[u]))),n},uc=(e,t,r,o,n)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${r.length}> {\n      var original_indices: array<${e.type.value}, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${e.type.value}(${e.indicesGet("output_indices","i")});\n        var scale = ${Ae("uniforms.scales","i",o)};\n        var roi_low = ${Ae("uniforms.roi","i",n)};\n        var roi_hi = ${Ae("uniforms.roi",`i + ${t.length}`,n)};\n        if (scale == 1.0) {\n          original_indices[i] = output_index;\n        } else {\n          var input_shape_i = ${e.type.value}(${Ae("uniforms.input_shape","i",t.length)});\n          var output_shape_i = ${e.type.value}(${Ae("uniforms.output_shape","i",r.length)});\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,lc=(e,t,r,o,n,s,u)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${o.length}; i++) {\n        var output_index = ${t.type.value}(${t.indicesGet("output_indices","i")});\n        var input_index: u32;\n        var scale = ${Ae("uniforms.scales","i",n)};\n        if (scale == 1.0) {\n          input_index = u32(output_index);\n        } else {\n          var roi_low = ${Ae("uniforms.roi","i",s)};\n          var roi_hi = ${Ae("uniforms.roi",`i + ${r.length}`,s)};\n          var input_shape_i = ${t.type.value}(${Ae("uniforms.input_shape","i",r.length)});\n          var output_shape_i = ${t.type.value}(${Ae("uniforms.output_shape","i",o.length)});\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${u} || (original_idx >= 0 && original_idx < input_shape_i)) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > (input_shape_i - 1)) {\n              input_index = u32(input_shape_i) - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet("input_indices","i"," input_index")}\n      }\n      return input_indices;\n    }`,dc=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet("input_indices","i")};\n        if (input_index < 0 || input_index >= ${Ae("uniforms.input_shape","i",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,cc=(e,t,r,o,n,s)=>{let[u,d,a,p]=r.length===2?[-1,0,1,-1]:o[1]===1?[0,2,3,1]:[0,1,2,3],h=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${h} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",d,`max(0, min(row, ${r[d]} - 1))`)};\n      ${e.indicesSet("input_indices",a,`max(0, min(col, ${r[a]} - 1))`)};\n      if (${r.length} > 2) {\n        ${e.indicesSet("input_indices",p,"channel")};\n        ${e.indicesSet("input_indices",u,"batch")};\n      };\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${h} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${h} = originalIndices[${d}];\n      var col:${h} = originalIndices[${a}];\n      if (${n} && (row < 0 || row > (${r[d]} - 1) || col < 0 || col > ${r[a]} - 1)) {\n        return ${s};\n      }\n      row = max(0, min(row, ${r[d]} - 1));\n      col = max(0, min(col, ${r[a]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${r.length>2}) {\n        channel = u32(originalIndices[${p}]);\n        batch = u32(originalIndices[${u}]);\n      }\n      var x11: ${h} = getInputValue(batch, channel, row1, col1);\n      var x12: ${h} = getInputValue(batch, channel, row1, col2);\n      var x21: ${h} = getInputValue(batch, channel, row2, col1);\n      var x22: ${h} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${h} = row - ${h}(row1);\n      var dx2: ${h} = ${h}(row2) - row;\n      var dy1 = col - ${h}(col1);\n      var dy2 = ${h}(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},pc=(e,t,r,o,n,s,u,d,a,p)=>{let[h,v]=r.length===2?[0,1]:n[1]===1?[2,3]:[1,2],g=e.type.value,w=y=>{let S=y===h?"row":"col";return`\n      fn ${S}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${g} {\n        var output_index = ${t.indicesGet("output_indices",y)};\n        var originalIdx: ${g} = getOriginalCoordinateFromResizedCoordinate(${g}(output_index), ${n[y]},\n        ${g}(${o[y]}), ${g}(${r[y]}), ${s[y]}, ${s[y]} + ${r.length});\n        var fractOriginalIdx: ${g} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${d} && (originalIdx < 0 || originalIdx > (${r[y]} - 1))) {\n          return ${a};\n        }\n        var data: array<${g}, 4> = array<${g}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${S}: ${g} = originalIdx + ${g}(i);\n          if (${S} < 0 || ${S} >= ${r[y]}) {\n            if (${p}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${d}) {\n              return ${a};\n            } else {\n              ${S} = max(0, min(${S}, ${r[y]} - 1));\n            }\n          }\n          var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet("input_indices_copy",y,`u32(${S})`)};\n          data[i + 1] = ${y===h?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${w(h)};\n    ${w(v)};\n  fn getCubicInterpolationCoefs(s: ${g}) -> array<${g}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${g}, 4> = array<${g}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${g} = 1.0 - absS;\n    var twoMinusAbsS: ${g} = 2.0 - absS;\n    var onePlusAbsS: ${g} = 1.0 + absS;\n    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};\n    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${g}, 4>, coefs: array<${g}, 4>) -> ${g} {\n    var coefsSum: ${g} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${g} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},mc=(e,t,r,o,n,s)=>{let u=e.dims,d=ac(s,t.axes,u.length),a=ic(u,o,n,t.axes),p=o.slice();o.length===0&&(p=u.map((x,_)=>x===0?1:a[_]/x),t.keepAspectRatioPolicy!=="stretch"&&(a=sc(u,p,t)));let h=K("output",e.dataType,a.length),v=W("input",e.dataType,u.length),g=D.size(a),w=u.length===a.length&&u.every((x,_)=>x===a[_]),y=t.coordinateTransformMode==="tf_crop_and_resize",S=v.type.value,I=x=>`\n      ${w?"":`\n      ${nc(t.coordinateTransformMode,S)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${dc(v,u)};\n              ${oc(t.nearestMode,r,S)};\n              ${lc(v,h,u,a,p.length,d.length,y)};\n              `;case"linear":return`\n              ${uc(h,u,a,p.length,d.length)};\n              ${cc(v,h,u,p,y,t.extrapolationValue)};\n              `;case"cubic":return`\n            ${pc(v,h,u,a,p,d,t.cubicCoeffA,y,t.extrapolationValue,t.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${x.registerUniform("output_size","u32").registerUniform("scales","f32",p.length).registerUniform("roi","f32",d.length).declareVariables(v,h)}\n      ${x.mainStart()}\n        ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n        ${w?"output[global_idx] = input[global_idx];":`\n        let output_indices = ${h.offsetToIndices("global_idx")};\n        var input_indices: ${v.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${v.getByIndices("input_indices")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return"output[global_idx] = bilinearInterpolation(output_indices);";case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n        `}\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${p.length>0?p:""}|${n.length>0?n:""}|${d.length>0?d:""}|${w}`,inputDependencies:["rank"]},getShaderSource:I,getRunData:()=>({outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:[{type:"uint32",data:g},{type:"float32",data:p},{type:"float32",data:d},...j(u),...j(a)]})}},fc=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},qs=(e,t)=>{let r=[],o=[],n=[],s=fc(e);rc(e.inputs,t,s,r,o,n),e.compute(mc(e.inputs[0],t,s,r,o,n),{inputs:[0]})},js=e=>{let t=e.antialias,r=e.axes,o=e.coordinateTransformMode,n=e.cubicCoeffA,s=e.excludeOutside!==0,u=e.extrapolationValue,d=e.keepAspectRatioPolicy,a=e.mode,p=e.nearestMode===""?"simple":e.nearestMode;return ee({antialias:t,axes:r,coordinateTransformMode:o,cubicCoeffA:n,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:d,mode:a,nearestMode:p})}});var hc,gc,Ys,Zs,Xs=Y(()=>{"use strict";Ue();$e();ke();be();hc=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],o=e[2];if(t.dataType!==r.dataType||t.dataType!==o.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let n=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==n)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(o.dims.length!==1)throw new Error("Gamma must be 1D");if(o.dims[o.dims.length-1]!==n)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let u=e[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let u=e[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Bias must have the same hidden size as input")}},gc=(e,t,r,o)=>{let n=e[0].dims,s=D.size(n),u=n,d=s,a=n.slice(-1)[0],p=o?n.slice(0,-1).concat(1):[],h=e.length>3,v=e.length>4,g=o&&r>1,w=o&&r>2,y=r>3,S=ze(a),I=[W("x",e[0].dataType,e[0].dims,S),W("skip",e[1].dataType,e[1].dims,S),W("gamma",e[2].dataType,e[2].dims,S)];h&&I.push(W("beta",e[3].dataType,e[3].dims,S)),v&&I.push(W("bias",e[4].dataType,e[4].dims,S)),I.push(K("output",e[0].dataType,u,S)),g&&I.push(K("meanOutput",1,p)),w&&I.push(K("invStdOutput",1,p)),y&&I.push(K("inputSkipBiasSum",e[0].dataType,u,S));let x=Oe(e[0].dataType),_=E=>`\n      const hiddenSize: f32 = ${a};\n      const hiddenSizeVectorized: u32 = ${a/S};\n      const epsilon: f32 = ${t.epsilon};\n\n      ${E.declareVariables(...I)}\n\n      ${E.mainStart()}\n        ${E.guardAgainstOutOfBoundsWorkgroupSizes(d/a)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${je("f32",S)};\n        var squareSum = ${je("f32",S)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${v?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${y?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${rt(x,S,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${Xe("sum",S)} / hiddenSize;\n        let variance = sqrt(${Xe("squareSum",S)} / hiddenSize - mean * mean + epsilon);\n        ${g?"meanOutput[global_idx] = mean;":""}\n        ${w?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${x}(mean)) / ${x}(variance) * gamma[i]\n           + ${h?"beta[i]":"0.0"};\n        }\n      }`,B=[{dims:u,dataType:e[0].dataType}];return r>1&&B.push({dims:p,dataType:1}),r>2&&B.push({dims:p,dataType:1}),r>3&&B.push({dims:n,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:_,getRunData:()=>({outputs:B,dispatchGroup:{x:Math.ceil(d/a/64)}})}},Ys=(e,t)=>{hc(e.inputs);let o=[0];e.outputCount>1&&o.push(-3),e.outputCount>2&&o.push(-3),e.outputCount>3&&o.push(3),e.compute(gc(e.inputs,t,e.outputCount,!1),{outputs:o})},Zs=e=>{let t=e.epsilon;return ee({epsilon:t})}});var yc,on,bc,Qs,wc,vc,Js,eu,tu=Y(()=>{"use strict";Ue();$e();ke();be();yc=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,o)=>{if(e[o+1].dataType!==6&&e[o+1].dataType!==7)throw new Error(`Input ${o} must be an array of int32 or int64`)})},on=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(o=>r.push(Number(o)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(o=>r.push(Number(o)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},bc=(e,t)=>{if(e.length>1){let r=on(e,1),o=on(e,2),n=on(e,3);return n.length===0&&(n=[...Array(e[0].dims.length).keys()]),ee({starts:r,ends:o,axes:n})}else return t},Qs=(e,t,r,o,n)=>{let s=e;return e<0&&(s+=r[o[t]]),n[t]<0?Math.max(0,Math.min(s,r[o[t]]-1)):Math.max(0,Math.min(s,r[o[t]]))},wc=(e,t,r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            let input_shape_i = ${Ae("uniforms.input_shape","i",r.length)};\n            let steps_i = ${Ae("uniforms.steps","i",r.length)};\n            let signs_i = ${Ae("uniforms.signs","i",r.length)};\n            let starts_i = ${Ae("uniforms.starts","i",r.length)};\n            var output_index = ${t.indicesGet("output_indices","i")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet("input_indices","i","input_index")};\n          }\n          return input_indices;\n      }`,vc=(e,t)=>{let r=e[0].dims,o=D.size(r),n=t.axes.length>0?D.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=on(e,4);s.forEach(x=>x!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(n.length).fill(1));let u=t.starts.map((x,_)=>Qs(x,_,r,n,s)),d=t.ends.map((x,_)=>Qs(x,_,r,n,s));if(n.length!==u.length||n.length!==d.length)throw new Error("start, ends and axes should have the same number of elements");if(n.length!==r.length)for(let x=0;x<r.length;++x)n.includes(x)||(u.splice(x,0,0),d.splice(x,0,r[x]),s.splice(x,0,1));let a=s.map(x=>Math.sign(x));s.forEach((x,_,B)=>{if(x<0){let E=(d[_]-u[_])/x,z=u[_],A=z+E*s[_];u[_]=A,d[_]=z,B[_]=-x}});let p=r.slice(0);n.forEach((x,_)=>{p[x]=Math.ceil((d[x]-u[x])/s[x])});let h={dims:p,dataType:e[0].dataType},v=K("output",e[0].dataType,p.length),g=W("input",e[0].dataType,e[0].dims.length),w=D.size(p),y=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:u.length},{name:"signs",type:"i32",length:a.length},{name:"steps",type:"u32",length:s.length}],S=[{type:"uint32",data:w},{type:"uint32",data:u},{type:"int32",data:a},{type:"uint32",data:s},...j(e[0].dims),...j(p)],I=x=>`\n      ${x.registerUniforms(y).declareVariables(g,v)}\n        ${wc(g,v,r)}\n        ${x.mainStart()}\n          ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let output_indices = ${v.offsetToIndices("global_idx")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${v.setByOffset("global_idx",g.getByIndices("input_indices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${a.length}_${u.length}_${s.length}`,inputDependencies:["rank"]},getShaderSource:I,getRunData:()=>({outputs:[h],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:S})}},Js=(e,t)=>{yc(e.inputs,t);let r=bc(e.inputs,t);e.compute(vc(e.inputs,r),{inputs:[0]})},eu=e=>{let t=e.starts,r=e.ends,o=e.axes;return ee({starts:t,ends:r,axes:o})}});var $c,Sc,ru,nu,ou=Y(()=>{"use strict";$e();ke();be();$c=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},Sc=(e,t)=>{let r=e.dims,o=D.size(r),n=64,s=t.axis;if(s<0&&(s=r.length+s),s<r.length-1)throw new Error("softmax only supports last axis for now.");let u=r[s],d=o/u,a=ze(u),p=u/a,h=(I,x)=>x===4?`max(max(${I}.x, ${I}.y), max(${I}.z, ${I}.w))`:x===2?`max(${I}.x, ${I}.y)`:x===3?`max(max(${I}.x, ${I}.y), ${I}.z)`:I,v=W("x",e.dataType,e.dims,a),g=K("result",e.dataType,e.dims,a),w=v.type.value,y=Oe(e.dataType)==="f32"?`var threadMax = ${w}(-3.402823e+38f);`:`var threadMax = ${w}(-65504.0h);`,S=I=>`\n      var<workgroup> rowMaxShared : ${w};\n      var<workgroup> rowSumShared : ${w};\n      var<workgroup> threadShared : array<${w}, ${n}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${w} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${w}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${I.registerUniform("packedCols","i32").declareVariables(v,g)}\n      ${I.mainStart()}\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = ${n};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${y}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${w}(${h("threadShared[0]",a)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${w}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${w}(${Xe("threadShared[0]",a)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`;return{name:"Softmax",shaderCache:{hint:`${a}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:d},programUniforms:[{type:"uint32",data:p}]}),getShaderSource:S}},ru=(e,t)=>{$c(e.inputs),e.compute(Sc(e.inputs[0],t))},nu=e=>ee({axis:e.axis})});var xc,Cc,_c,Ic,Ac,au,iu,su=Y(()=>{"use strict";$e();ke();be();xc=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Cc=(e,t)=>{let r=[],o=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),o=r.length),ee({numOutputs:o,axis:t.axis,splitSizes:r})},_c=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${Ae("uniforms.size_in_split_axis","i",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Ic=e=>{let t=e.length,r=[];for(let o=0;o<t;++o){let n=e[o].setByIndices("indices","input[global_idx]");t===1?r.push(n):o===0?r.push(`if (output_number == ${o}u) { ${n} }`):o===t-1?r.push(`else { ${n} }`):r.push(`else if (output_number == ${o}) { ${n} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},Ac=(e,t)=>{let r=e[0].dims,o=D.size(r),n=e[0].dataType,s=D.normalizeAxis(t.axis,r.length),u=new Array(t.numOutputs),d=W("input",n,r),a=new Array(t.numOutputs),p=[],h=[],v=0,g=[{type:"uint32",data:o}];for(let y=0;y<t.numOutputs;y++){v+=t.splitSizes[y],a[y]=v;let S=r.slice();S[t.axis]=t.splitSizes[y],h.push(S),u[y]=K(`output${y}`,n,S),p.push({dims:h[y],dataType:e[0].dataType})}g.push({type:"uint32",data:a}),g.push(...j(r)),h.forEach(y=>g.push(...j(y)));let w=y=>`\n  ${y.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",a.length).declareVariables(d,...u)}\n  ${_c(a.length)}\n  ${Ic(u)}\n\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\n\n    var indices = ${d.offsetToIndices("global_idx")};\n    var index = ${d.indicesGet("indices",s)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${Ae("uniforms.size_in_split_axis","output_number - 1u",a.length)};\n      ${d.indicesSet("indices",s,"index")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:w,getRunData:()=>({outputs:p,dispatchGroup:{x:Math.ceil(o/64)},programUniforms:g})}},au=(e,t)=>{xc(e.inputs);let r=e.inputs.length===1?t:Cc(e.inputs,t);e.compute(Ac(e.inputs,r),{inputs:[0]})},iu=e=>{let t=e.axis,r=e.splitSizes,o=e.numOutputs<0?r.length:e.numOutputs;if(o!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ee({axis:t,numOutputs:o,splitSizes:r})}});var uu,Tc,Ec,Oc,lu,du=Y(()=>{"use strict";Ue();$e();be();uu=e=>Array.from(e.getBigInt64Array(),Number),Tc=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(uu(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Ec=(e,t)=>{let r=[];for(let o=0;o<e.length;++o)r.push(e[o]*t[o]);return r},Oc=e=>{let t=e[0].dims,r=uu(e[1]),o=Ec(t,r),n=D.size(o),s=e[0].dataType,u=W("input",s,t.length),d=K("output",s,o.length),a=p=>`\n      const inputShape = ${u.indices(...t)};\n      ${p.registerUniform("output_size","u32").declareVariables(u,d)}\n      ${p.mainStart()}\n      ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let output_indices = ${d.offsetToIndices("global_idx")};\n      var input_indices: ${u.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let input_dim_i = ${u.indicesGet("uniforms.input_shape","i")};\n        let input_dim_value = ${d.indicesGet("output_indices","i")}  % input_dim_i;\n\n        ${u.indicesSet("input_indices","i","input_dim_value")}\n      }\n      ${d.setByOffset("global_idx",u.getByIndices("input_indices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:[{type:"uint32",data:n},...j(e[0].dims),...j(o)]}),getShaderSource:a}},lu=e=>{Tc(e.inputs),e.compute(Oc(e.inputs),{inputs:[0]})}});var kc,Pc,cu,pu=Y(()=>{"use strict";Ue();$e();be();kc=(e,t,r,o,n)=>{let s=K("output_data",n,r.length,4),u=W("a_data",t[1].dataType,t[1].dims.length,4),d=W("b_data",t[2].dataType,t[2].dims.length,4),a=W("c_data",t[0].dataType,t[0].dims.length,4),p,h=(v,g,w)=>`select(${g}, ${v}, ${w})`;if(!o)p=s.setByOffset("global_idx",h(u.getByOffset("global_idx"),d.getByOffset("global_idx"),a.getByOffset("global_idx")));else{let v=(g,w,y="")=>{let S=`a_data[index_a${w}][component_a${w}]`,I=`b_data[index_b${w}][component_b${w}]`,x=`bool(c_data[index_c${w}] & ${4278190080>>>(3-w)*8}u)`;return`\n            let output_indices${w} = ${s.offsetToIndices(`global_idx * 4u + ${w}u`)};\n            let offset_a${w} = ${u.broadcastedIndicesToOffset(`output_indices${w}`,s)};\n            let offset_b${w} = ${d.broadcastedIndicesToOffset(`output_indices${w}`,s)};\n            let offset_c${w} = ${a.broadcastedIndicesToOffset(`output_indices${w}`,s)};\n            let index_a${w} = offset_a${w} / 4u;\n            let index_b${w} = offset_b${w} / 4u;\n            let index_c${w} = offset_c${w} / 4u;\n            let component_a${w} = offset_a${w} % 4u;\n            let component_b${w} = offset_b${w} % 4u;\n            ${g}[${w}] = ${y}(${h(S,I,x)});\n          `};n===9?p=`\n            var data = vec4<u32>(0);\n            ${v("data",0,"u32")}\n            ${v("data",1,"u32")}\n            ${v("data",2,"u32")}\n            ${v("data",3,"u32")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:p=`\n            ${v("output_data[global_idx]",0)}\n            ${v("output_data[global_idx]",1)}\n            ${v("output_data[global_idx]",2)}\n            ${v("output_data[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(a,u,d,s)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${p}\n      }`},Pc=e=>{let t=e[1].dims,r=e[2].dims,o=e[0].dims,n=e[1].dataType,s=!(D.areEqual(t,r)&&D.areEqual(r,o)),u=t,d=D.size(t),a=Math.ceil(d/4);if(s){let p=st.calcShape(st.calcShape(t,r,!1),o,!1);if(!p)throw new Error("Can\'t perform where op on the given tensors");u=p,d=D.size(u)}return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:p=>kc(p,e,u,s,n),getRunData:()=>({outputs:[{dims:u,dataType:n}],dispatchGroup:{x:Math.ceil(d/64/4)},programUniforms:[{type:"uint32",data:a},...j(o),...j(t),...j(r),...j(u)]})}},cu=e=>{e.compute(Pc(e.inputs))}});var mu,fu=Y(()=>{"use strict";wa();Bn();Wa();Na();vi();ki();Bi();Wn();Ki();Xi();rs();as();us();cs();fs();ys();vs();Nn();Cs();As();Gs();Fs();Nr();Ks();Xs();tu();ou();su();du();Nt();Dn();pu();mu=new Map([["Abs",[Ha]],["Acos",[Ga]],["Acosh",[La]],["Add",[$i]],["ArgMax",[ba,Rn]],["ArgMin",[ya,Rn]],["Asin",[Fa]],["Asinh",[qa]],["Atan",[ja]],["Atanh",[Ka]],["Attention",[$a,va]],["AveragePool",[Bs,Rs]],["BatchNormalization",[Va]],["BiasAdd",[Ua]],["BiasSplitGelu",[wi]],["Cast",[Za,Ya]],["Ceil",[Qa]],["Clip",[Xa]],["Concat",[Pi,Ri]],["Conv",[Ln,Gn]],["ConvTranspose",[ji,qi]],["Cos",[Ja]],["Cosh",[ei]],["CumSum",[Yi,Zi]],["Div",[Si]],["Einsum",[es,ts]],["Elu",[ti,Kr]],["Equal",[xi]],["Erf",[ri]],["Exp",[ni]],["Expand",[os]],["Floor",[oi]],["FusedConv",[Ln,Gn]],["Gather",[ss,is]],["GatherElements",[ds,ls]],["Gelu",[ai]],["Gemm",[ps,ms]],["GlobalAveragePool",[zs,Ds]],["GlobalMaxPool",[Hs,Ns]],["Greater",[Ai]],["GreaterOrEqual",[Ei]],["InstanceNormalization",[gs,hs]],["LayerNormalization",[ws,bs]],["LeakyRelu",[ii,Kr]],["Less",[Ti]],["LessOrEqual",[Oi]],["Log",[bi]],["MatMul",[Ui]],["MaxPool",[Ws,Us]],["Mul",[Ci]],["MultiHeadAttention",[xs,Ss]],["Neg",[ui]],["Not",[si]],["Pad",[_s,Is]],["Pow",[_i]],["Range",[Ls]],["Reciprocal",[li]],["ReduceMin",[ca]],["ReduceMean",[ia]],["ReduceMax",[da]],["ReduceSum",[ma]],["ReduceProd",[pa]],["ReduceL1",[sa]],["ReduceL2",[ua]],["ReduceLogSum",[ha]],["ReduceLogSumExp",[la]],["ReduceSumSquare",[fa]],["Relu",[di]],["Resize",[qs,js]],["Sigmoid",[ci]],["Sin",[pi]],["Sinh",[mi]],["Slice",[Js,eu]],["SkipLayerNormalization",[Ys,Zs]],["Split",[au,iu]],["Sqrt",[fi]],["Softmax",[ru,nu]],["Sub",[Ii]],["Tan",[hi]],["Tanh",[gi]],["ThresholdedRelu",[yi,Kr]],["Tile",[lu]],["Transpose",[jo,Ko]],["Where",[cu]]])});var an,hu=Y(()=>{"use strict";Ue();vt();be();an=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o,n,s,u,d){let a=this.backend.device,p=this.backend.getComputePassEncoder();p.setPipeline(t.computePipeline);let h=[];for(let g of n)h.push({binding:h.length,resource:{buffer:g.buffer}});for(let g of s)h.push({binding:h.length,resource:{buffer:g.buffer}});d&&h.push({binding:h.length,resource:d});let v=a.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:h,label:t.programInfo.name});if(p.setBindGroup(0,v),p.dispatchWorkgroups(...u),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let g=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,g.buffer,0,this.backend.querySetCount*8),this.backend.flush();let w=this.backend.currentKernelId,y=this.backend.kernels.get(w);g.buffer.mapAsync(GPUMapMode.READ).then(()=>{let S=new BigUint64Array(g.buffer.getMappedRange()),[I,x]=S,[_,B]=y;g.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=I);let E=Number(I-this.backend.queryTimeBase),z=Number(x-this.backend.queryTimeBase);if(!Number.isSafeInteger(E)||!Number.isSafeInteger(z))throw new RangeError("incorrect timestamp range");if(this.backend.gpuDataManager.release(g.id),this.backend.env.webgpu.profiling?.ondata)this.backend.env.webgpu.profiling.ondata({version:1,inputsMetadata:r.map(A=>({dims:A.dims,dataType:Ot(A.dataType)})),outputsMetadata:o.map(A=>({dims:A.dims,dataType:Ot(A.dataType)})),kernelId:w,kernelType:_,kernelName:B,startTime:E,endTime:z});else{let A="";r.forEach((V,G)=>{A+=`input[${G}]: [${V.dims}] | ${Ot(V.dataType)}, `});let U="";o.forEach((V,G)=>{U+=`output[${G}]: [${V.dims}] | ${Ot(V.dataType)}, `}),console.log(`[profiling] kernel "${w}|${B}|${t.programInfo.name}" ${A}${U}execution time: ${z-E} ns`)}})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(t,r){let o=this.backend.device,n=[];o.features.has("shader-f16")&&n.push("enable f16;");let s=Fo(r),u=t.getShaderSource(s),d=`${n.join(`\n`)}\n${s.additionalImplementations}\n${u}`,a=o.createShaderModule({code:d,label:t.name});Re("verbose",()=>`[WebGPU] ${t.name} shader code: ${d}`);let p=o.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto",label:t.name});return{programInfo:t,computePipeline:p}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,o=typeof t=="number"?1:t.y||1,n=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=s&&o<=s&&n<=s)return[r,o,n];let u=r*o*n,d=Math.ceil(Math.sqrt(u));if(d>s){if(d=Math.ceil(Math.cbrt(u)),d>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[d,d,d]}else return[d,d,1]}}});var Rc,Bc,sn,gu=Y(()=>{"use strict";vt();Uo();Lo();fu();hu();Rc=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let o=0;o<e.length;++o){let n=e[o].dataType;switch(t[o]){case"none":{r.push("");break}case"type":{r.push(`${n}`);break}case"rank":{let s=e[o].dims.length;r.push(`${n};${s}`);break}case"dims":{let s=e[o].dims.join(",");r.push(`${n};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[o]}`)}}return r.join("|")},Bc=(e,t,r)=>{let o=e.name;return e.shaderCache?.hint&&(o+="["+e.shaderCache.hint+"]"),o+=":"+r+`:${Rc(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,o},sn=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let o=[],n={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};r.features.has("timestamp-query")&&o.push("timestamp-query"),r.features.has("shader-f16")&&o.push("shader-f16"),this.device=await r.requestDevice(n),this.gpuDataManager=Go(this),this.programManager=new an(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Vo(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return this.device.features.has("timestamp-query")&&(this.env.webgpu.profiling?.mode==="default"||!this.env.webgpu.profiling?.mode&&this.env.webgpu.profilingMode==="default")}run(t,r,o,n,s){let u=[];for(let _=0;_<r.length;++_){let B=this.gpuDataManager.get(r[_].data);if(!B)throw new Error(`no GPU data for input: ${r[_].data}`);u[_]=B}let{outputs:d,dispatchGroup:a,programUniforms:p}=t.getRunData(r),h=o.length===0?d.map((_,B)=>B):o;if(h.length!==d.length)throw new Error(`Output size ${h.length} must be equal to ${d.length}.`);let v=[],g=[];for(let _=0;_<d.length;++_){if(!Number.isInteger(h[_])||h[_]<-3||h[_]>=d.length)throw new Error(`Invalid output index: ${h[_]}`);if(h[_]===-3)continue;let B=h[_]===-1,E=h[_]===-2,z=B||E?s(d[_].dataType,d[_].dims):n(h[_],d[_].dataType,d[_].dims),A=this.gpuDataManager.get(z.data);if(!A)throw new Error(`no GPU data for output: ${z.data}`);if(B&&this.temporaryData.push(A),E){let U=this.kernelPersistentData.get(this.currentKernelId);U||(U=[],this.kernelPersistentData.set(this.currentKernelId,U)),U.push(A)}v.push(z),g.push(A)}let w;if(p){let _=0,B=[];p.forEach(U=>{let V=typeof U.data=="number"?[U.data]:U.data;if(V.length===0)return;let G=V.length<=2?V.length*4:16;_=Math.ceil(_/G)*G,B.push(_),_+=V.length>4?Math.ceil(V.length/4)*16:V.length*4});let E=16;_=Math.ceil(_/E)*E;let z=new ArrayBuffer(_);p.forEach((U,V)=>{let G=B[V],Q=typeof U.data=="number"?[U.data]:U.data;U.type==="int32"?new Int32Array(z,G,Q.length).set(Q):U.type==="uint32"?new Uint32Array(z,G,Q.length).set(Q):new Float32Array(z,G,Q.length).set(Q)});let A=this.gpuDataManager.create(_,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(A.buffer,0,z,0,_),this.gpuDataManager.release(A.id),w={offset:0,size:_,buffer:A.buffer}}let y=this.programManager.normalizeDispatchGroupSize(a),S=y[1]===1&&y[2]===1,I=Bc(t,r,S),x=this.programManager.getArtifact(I);return x||(x=this.programManager.build(t,y),this.programManager.setArtifact(I,x),Re("info",()=>`[artifact] key: ${I}, programName: ${t.name}`)),Re("info",()=>`[ProgramManager] run "${t.name}" (key=${I}) with ${y[0]}x${y[1]}x${y[2]}`),this.programManager.run(x,r,v,u,g,y,w),v}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,o,n){let s=mu.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,n,s[0],[s[1],o]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let o of r)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,o){let n=this.kernels.get(t);if(!n)throw new Error(`kernel not created: ${t}`);let[s,u,d,a]=n;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${u}" is not allowed to be called recursively`);this.currentKernelId=t,a[0]&&(a[1]=a[0](a[1]),a[0]=void 0),Re("info",()=>`[WebGPU] Start to run kernel "[${s}] ${u}"...`);let p=this.env.debug;this.temporaryData=[];try{return p&&this.device.pushErrorScope("validation"),d(r,a[1]),0}catch(h){return o.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${u}" failed. ${h}`)),1}finally{p&&o.push(this.device.popErrorScope().then(h=>h?`GPU validation error for kernel "[${s}] ${u}": ${h.message}`:null));for(let h of this.temporaryData)this.gpuDataManager.release(h.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,o,n){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let u=s.get(r),d=this.gpuDataManager.registerExternalBuffer(o,n,u?.[1]);return s.set(r,[d,o]),d}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,o){return async()=>{let n=await In(this,t,r);return Wo(n.buffer,o)}}}});var yu={};Pr(yu,{init:()=>Mc});var mr,Zn,Mc,bu=Y(()=>{"use strict";Ue();gu();vt();$e();mr=class e{constructor(t,r,o,n){this.module=t;this.dataType=r;this.data=o;this.dims=n}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=D.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=D.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=D.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(D.size(t)!==D.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Zn=class{constructor(t,r,o){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let n=t.HEAPU32,s=o>>2;this.opKernelContext=n[s++];let u=n[s++];this.outputCount=n[s++],this.customDataOffset=n[s++],this.customDataSize=n[s++];let d=[];for(let a=0;a<u;a++){let p=n[s++],h=n[s++],v=n[s++],g=[];for(let w=0;w<v;w++)g.push(n[s++]);d.push(new mr(t,p,h,g))}this.inputs=d}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let o=r?.inputs?.map(d=>typeof d=="number"?this.inputs[d]:d)??this.inputs,n=r?.outputs??[],s=(d,a,p)=>new mr(this.module,a,this.output(d,p),p),u=(d,a)=>{let p=ur(d);if(!p)throw new Error(`Unsupported data type: ${d}`);let h=p*D.size(a);return new mr(this.module,d,this.backend.gpuDataManager.create(h).id,a)};return this.backend.run(t,o,n,s,u)}output(t,r){let o=this.module.stackSave();try{let n=this.module.stackAlloc((1+r.length)*4),s=n>>2;this.module.HEAPU32[s++]=r.length;for(let u=0;u<r.length;u++)this.module.HEAPU32[s++]=r[u];return this.module._JsepOutput(this.opKernelContext,t,n)}catch(n){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(o)}}},Mc=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let o=new sn;await o.initialize(t),r(o,n=>o.alloc(n),n=>o.free(n),(n,s,u,d=!1)=>{if(d)Re("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${n}, dst=${s}, size=${u}`),o.memcpy(n,s);else{Re("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${n}, gpuDataId=${s}, size=${u}`);let a=e.HEAPU8.subarray(n,n+u);o.upload(s,a)}},async(n,s,u)=>{Re("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${s}, size=${u}`),await o.download(n,()=>e.HEAPU8.subarray(s,s+u))},(n,s,u)=>o.createKernel(n,s,u,t.debug||o.isQueryEnabled()?e.UTF8ToString(e._JsepGetNodeName(s)):`${s}`),n=>o.releaseKernel(n),(n,s,u,d)=>{Re("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${n}, contextDataOffset=${s}`);let a=new Zn(e,o,s);return o.computeKernel(n,a,d)})}}});var ko;ko=$o();var Yu=To(),$n,Sn=!1,Rr=!1,Oo=!1,Zu=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},Xu=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Qu=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Po=async e=>{if(Sn)return Promise.resolve();if(Rr)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Oo)throw new Error("previous call to \'initializeWebAssembly()\' failed.");Rr=!0;let t=e.initTimeout,r=e.numThreads,o=e.simd,n=r>1&&Zu(),s=o&&Xu(),u=e.wasmPaths,d=typeof u=="string"?u:void 0,a=Qu(s,n),p=typeof u=="object"?u[a]:void 0,h=!1,v=[];if(t>0&&v.push(new Promise(g=>{setTimeout(()=>{h=!0,g()},t)})),v.push(new Promise((g,w)=>{let y=n?Yu:ko,S={locateFile:(I,x)=>{if(n&&I.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Eo()],{type:"text/javascript"}));if(I.endsWith(".wasm")){if(p)return p;let _=d??x;return a==="ort-wasm-simd.wasm"?_+"ort-wasm-simd.jsep.wasm":a==="ort-wasm-simd-threaded.wasm"?_+"ort-wasm-simd-threaded.jsep.wasm":_+a}return x+I}};if(n)if(typeof Blob>"u")S.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let I=`var ortWasmThreaded=${y.toString()};`;S.mainScriptUrlOrBlob=new Blob([I],{type:"text/javascript"})}y(S).then(I=>{Rr=!1,Sn=!0,$n=I,g()},I=>{Rr=!1,Oo=!0,w(I)})})),await Promise.race(v),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},De=()=>{if(Sn&&$n)return $n;throw new Error("WebAssembly is not initialized yet.")};var We=(e,t)=>{let r=De(),o=r.lengthBytesUTF8(e)+1,n=r._malloc(o);return r.stringToUTF8(e,n,o),t.push(n),n},sr=(e,t,r,o)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([n,s])=>{let u=t?t+n:n;if(typeof s=="object")sr(s,u+".",r,o);else if(typeof s=="string"||typeof s=="number")o(u,s.toString());else if(typeof s=="boolean")o(u,s?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof s}`)})},Ee=e=>{let t=De(),r=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let n=t.HEAP32[o/4],s=t.HEAPU32[o/4+1],u=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${u}`)}finally{t.stackRestore(r)}};var Ro=e=>{let t=De(),r=0,o=[],n=e||{};try{if(e?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(n.terminate=!1);let s=0;return e?.tag!==void 0&&(s=We(e.tag,o)),r=t._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,s),r===0&&Ee("Can\'t create run options."),e?.extra!==void 0&&sr(e.extra,"",new WeakSet,(u,d)=>{let a=We(u,o),p=We(d,o);t._OrtAddRunConfigEntry(r,a,p)!==0&&Ee(`Can\'t set a run config entry: ${u} - ${d}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),o.forEach(u=>t._free(u)),s}};var Ju=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},el=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},tl=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},rl=(e,t,r)=>{for(let o of t){let n=typeof o=="string"?o:o.name;switch(n){case"xnnpack":n="XNNPACK";break;case"webnn":if(n="WEBNN",typeof o!="string"){let u=o;if(u?.deviceType){let d=We("deviceType",r),a=We(u.deviceType,r);De()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ee(`Can\'t set a session config entry: \'deviceType\' - ${u.deviceType}.`)}if(u?.numThreads){let d=u.numThreads;(typeof d!="number"||!Number.isInteger(d)||d<0)&&(d=0);let a=We("numThreads",r),p=We(d.toString(),r);De()._OrtAddSessionConfigEntry(e,a,p)!==0&&Ee(`Can\'t set a session config entry: \'numThreads\' - ${u.numThreads}.`)}if(u?.powerPreference){let d=We("powerPreference",r),a=We(u.powerPreference,r);De()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ee(`Can\'t set a session config entry: \'powerPreference\' - ${u.powerPreference}.`)}}break;case"webgpu":if(n="JS",typeof o!="string"){let u=o;if(u?.preferredLayout){if(u.preferredLayout!=="NCHW"&&u.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${u.preferredLayout}`);let d=We("preferredLayout",r),a=We(u.preferredLayout,r);De()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ee(`Can\'t set a session config entry: \'preferredLayout\' - ${u.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let s=We(n,r);De()._OrtAppendExecutionProvider(e,s)!==0&&Ee(`Can\'t append execution provider: ${n}.`)}},Bo=e=>{let t=De(),r=0,o=[],n=e||{};tl(n);try{let s=Ju(n.graphOptimizationLevel??"all"),u=el(n.executionMode??"sequential"),d=typeof n.logId=="string"?We(n.logId,o):0,a=n.logSeverityLevel??2;if(!Number.isInteger(a)||a<0||a>4)throw new Error(`log serverity level is not valid: ${a}`);let p=n.logVerbosityLevel??0;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log verbosity level is not valid: ${p}`);let h=typeof n.optimizedModelFilePath=="string"?We(n.optimizedModelFilePath,o):0;if(r=t._OrtCreateSessionOptions(s,!!n.enableCpuMemArena,!!n.enableMemPattern,u,!!n.enableProfiling,0,d,a,p,h),r===0&&Ee("Can\'t create session options."),n.executionProviders&&rl(r,n.executionProviders,o),n.freeDimensionOverrides)for(let[v,g]of Object.entries(n.freeDimensionOverrides)){if(typeof v!="string")throw new Error(`free dimension override name must be a string: ${v}`);if(typeof g!="number"||!Number.isInteger(g)||g<0)throw new Error(`free dimension override value must be a non-negative integer: ${g}`);let w=We(v,o);t._OrtAddFreeDimensionOverride(r,w,g)!==0&&Ee(`Can\'t set a free dimension override: ${v} - ${g}.`)}return n.extra!==void 0&&sr(n.extra,"",new WeakSet,(v,g)=>{let w=We(v,o),y=We(g,o);t._OrtAddSessionConfigEntry(r,w,y)!==0&&Ee(`Can\'t set a session config entry: ${v} - ${g}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),o.forEach(u=>t._free(u)),s}};Ue();var vu=!1,Dc=e=>{let t=De(),r=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&Ee("Can\'t get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(r)}},zc=(e,t)=>{De()._OrtInit(e,t)!==0&&Ee("Can\'t initialize onnxruntime.")},$u=async e=>{zc(e.wasm.numThreads,lr(e.logLevel));{let t=(bu(),Wt(yu)).init;await t(De(),e)}vu=!0},fr=new Map,Su=()=>vu,Xn=e=>{let t=De(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},Qn=(e,t)=>{let r=De(),o=0,n=0,s=0,u=[],d=[],a=[];try{[n,u]=Bo(t),o=r._OrtCreateSession(e[0],e[1],n),o===0&&Ee("Can\'t create a session.");let[p,h]=Dc(o),v=[],g=[],w=[];for(let S=0;S<p;S++){let I=r._OrtGetInputName(o,S);I===0&&Ee("Can\'t get an input name."),d.push(I),v.push(r.UTF8ToString(I))}for(let S=0;S<h;S++){let I=r._OrtGetOutputName(o,S);I===0&&Ee("Can\'t get an output name."),a.push(I);let x=r.UTF8ToString(I);g.push(x);{let _=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[x]??"cpu";if(_!=="cpu"&&_!=="cpu-pinned"&&_!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${_}.`);w.push(_)}}let y=null;return w.some(S=>S==="gpu-buffer")&&(s=r._OrtCreateBinding(o),s===0&&Ee("Can\'t create IO binding."),y={handle:s,outputPreferredLocations:w,outputPreferredLocationsEncoded:w.map(S=>Cn(S))}),fr.set(o,[o,d,a,y]),[o,v,g]}catch(p){throw d.forEach(h=>r._OrtFree(h)),a.forEach(h=>r._OrtFree(h)),s!==0&&r._OrtReleaseBinding(s),o!==0&&r._OrtReleaseSession(o),p}finally{r._free(e[0]),n!==0&&r._OrtReleaseSessionOptions(n),u.forEach(p=>r._free(p))}},xu=(e,t)=>{let r=Xn(e);return Qn(r,t)},Cu=e=>{let t=De(),r=fr.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,n,s,u]=r;u&&t._OrtReleaseBinding(u.handle),t.jsepUnregisterBuffers?.(e),n.forEach(d=>t._OrtFree(d)),s.forEach(d=>t._OrtFree(d)),t._OrtReleaseSession(o),fr.delete(e)},wu=(e,t,r,o,n)=>{if(!e){t.push(0);return}let s=De(),u=e[0],d=e[1],a=e[3],p,h;if(u==="string"&&a==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(a==="gpu-buffer"){let w=e[2].gpuBuffer,y=ur(xn(u));h=d.reduce((S,I)=>S*I,1)*y,p=s.jsepRegisterBuffer(o,n,w,h)}else{let w=e[2];if(Array.isArray(w)){h=4*w.length,p=s._malloc(h),r.push(p);let y=p/4;for(let S=0;S<w.length;S++){if(typeof w[S]!="string")throw new TypeError(`tensor data at index ${S} is not a string`);s.HEAPU32[y++]=We(w[S],r)}}else h=w.byteLength,p=s._malloc(h),r.push(p),s.HEAPU8.set(new Uint8Array(w.buffer,w.byteOffset,h),p)}let v=s.stackSave(),g=s.stackAlloc(4*d.length);try{let w=g/4;d.forEach(S=>s.HEAP32[w++]=S);let y=s._OrtCreateTensor(xn(u),p,h,g,d.length,Cn(a));y===0&&Ee(`Can\'t create tensor for input/output. session=${o}, index=${n}.`),t.push(y)}finally{s.stackRestore(v)}},_u=async(e,t,r,o,n,s)=>{let u=De(),d=fr.get(e);if(!d)throw new Error(`cannot run inference. invalid session id: ${e}`);let[a,p,h,v]=d,g=t.length,w=o.length,y=0,S=[],I=[],x=[],_=[],B=u.stackSave(),E=u.stackAlloc(g*4),z=u.stackAlloc(g*4),A=u.stackAlloc(w*4),U=u.stackAlloc(w*4);try{[y,S]=Ro(s);for(let J=0;J<g;J++)wu(r[J],I,_,e,t[J]);for(let J=0;J<w;J++)wu(n[J],x,_,e,g+o[J]);let V=E/4,G=z/4,Q=A/4,R=U/4;for(let J=0;J<g;J++)u.HEAPU32[V++]=I[J],u.HEAPU32[G++]=p[t[J]];for(let J=0;J<w;J++)u.HEAPU32[Q++]=x[J],u.HEAPU32[R++]=h[o[J]];if(v){let{handle:J,outputPreferredLocations:we,outputPreferredLocationsEncoded:Z}=v;if(p.length!==g)throw new Error(`input count from feeds (${g}) is expected to be always equal to model\'s input count (${p.length}).`);for(let ye=0;ye<g;ye++){let Ce=t[ye];await u._OrtBindInput(J,p[Ce],I[ye])!==0&&Ee(`Can\'t bind input[${ye}] for session=${e}.`)}for(let ye=0;ye<w;ye++){let Ce=o[ye];n[ye]?.[3]?u._OrtBindOutput(J,h[Ce],x[ye],0)!==0&&Ee(`Can\'t bind pre-allocated output[${ye}] for session=${e}.`):u._OrtBindOutput(J,h[Ce],0,Z[Ce])!==0&&Ee(`Can\'t bind output[${ye}] to ${we[ye]} for session=${e}.`)}}let q;v?q=await u._OrtRunWithBinding(a,v.handle,w,A,y):q=await u._OrtRun(a,z,E,g,U,w,A,y),q!==0&&Ee("failed to call OrtRun().");let pe=[];for(let J=0;J<w;J++){let we=u.HEAPU32[A/4+J];if(we===x[J]){pe.push(n[J]);continue}let Z=u.stackSave(),ye=u.stackAlloc(4*4),Ce=!1,fe,ce=0;try{u._OrtGetTensorData(we,ye,ye+4,ye+8,ye+12)!==0&&Ee(`Can\'t access output tensor data on index ${J}.`);let Be=ye/4,He=u.HEAPU32[Be++];ce=u.HEAPU32[Be++];let L=u.HEAPU32[Be++],ne=u.HEAPU32[Be++],he=[];for(let Me=0;Me<ne;Me++)he.push(u.HEAPU32[L/4+Me]);u._OrtFree(L);let Fe=he.reduce((Me,Ge)=>Me*Ge,1);fe=Ot(He);let Ze=v?.outputPreferredLocations[o[J]];if(fe==="string"){if(Ze==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Me=[],Ge=ce/4;for(let Ke=0;Ke<Fe;Ke++){let ot=u.HEAPU32[Ge++],Qe=Ke===Fe-1?void 0:u.HEAPU32[Ge]-ot;Me.push(u.UTF8ToString(ot,Qe))}pe.push([fe,he,Me,"cpu"])}else if(Ze==="gpu-buffer"&&Fe>0){let Me=u.jsepGetBuffer(ce),Ge=ur(He);if(Ge===void 0||!Mo(fe))throw new Error(`Unsupported data type: ${fe}`);Ce=!0,pe.push([fe,he,{gpuBuffer:Me,download:u.jsepCreateDownloader(Me,Fe*Ge,fe),dispose:()=>{u._OrtReleaseTensor(we)}},"gpu-buffer"])}else{let Me=Br(fe),Ge=new Me(Fe);new Uint8Array(Ge.buffer,Ge.byteOffset,Ge.byteLength).set(u.HEAPU8.subarray(ce,ce+Ge.byteLength)),pe.push([fe,he,Ge,"cpu"])}}finally{u.stackRestore(Z),fe==="string"&&ce&&u._free(ce),Ce||u._OrtReleaseTensor(we)}}return v&&u._OrtClearBoundOutputs(v.handle),pe}finally{u.stackRestore(B),I.forEach(V=>u._OrtReleaseTensor(V)),x.forEach(V=>u._OrtReleaseTensor(V)),_.forEach(V=>u._free(V)),y!==0&&u._OrtReleaseRunOptions(y),S.forEach(V=>u._free(V))}},Iu=e=>{let t=De(),r=fr.get(e);if(!r)throw new Error("invalid session id");let o=r[0],n=t._OrtEndProfiling(o);n===0&&Ee("Can\'t get an profile file name."),t._OrtFree(n)},Au=e=>{let t=[];for(let r of e){let o=r[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t};self.onmessage=e=>{switch(e.data.type){case"init-wasm":try{Po(e.data.in).then(()=>postMessage({type:"init-wasm"}),t=>postMessage({type:"init-wasm",err:t}))}catch(t){postMessage({type:"init-wasm",err:t})}break;case"init-ort":try{$u(e.data.in).then(()=>postMessage({type:"init-ort"}),t=>postMessage({type:"init-ort",err:t}))}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{let{model:t}=e.data.in,r=Xn(t);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{let{modeldata:t,options:r}=e.data.in,o=Qn(t,r);postMessage({type:"create_finalize",out:o})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{let{model:t,options:r}=e.data.in,o=xu(t,r);postMessage({type:"create",out:o})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{Cu(e.data.in),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{let{sessionId:t,inputIndices:r,inputs:o,outputIndices:n,options:s}=e.data.in;_u(t,r,o,n,new Array(n.length).fill(null),s).then(u=>{u.some(d=>d[3]!=="cpu")?postMessage({type:"run",err:"Proxy does not support non-cpu tensor location."}):postMessage({type:"run",out:u},Au(u))},u=>{postMessage({type:"run",err:u})})}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{let t=e.data.in;Iu(t),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}break;case"is-ort-env-initialized":try{let t=Su();postMessage({type:"is-ort-env-initialized",out:t})}catch(t){postMessage({type:"is-ort-env-initialized",err:t})}break;default:}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'});var xt,tt,Cn,ka,Ra,Sa,xa,_a,Ca,Ia,Aa,Ea,Ta,Oa,kt,Yp,_n,Cl,Il,Al,El,Pa,Tl,Ol,kl,Rl,Ba=q(()=>{"use strict";ct();xl();Qt();xt=()=>!!Ee.wasm.proxy&&typeof document<"u",Cn=!1,ka=!1,Ra=!1,_a=[],Ca=[],Ia=[],Aa=[],Ea=[],Ta=[],Oa=[],kt=()=>{if(Cn||!ka||Ra||!tt)throw new Error("worker not ready")},Yp=e=>{switch(e.data.type){case"init-wasm":Cn=!1,e.data.err?(Ra=!0,Sa[1](e.data.err)):(ka=!0,Sa[0]());break;case"init-ort":e.data.err?xa[1](e.data.err):xa[0]();break;case"create_allocate":e.data.err?_a.shift()[1](e.data.err):_a.shift()[0](e.data.out);break;case"create_finalize":e.data.err?Ca.shift()[1](e.data.err):Ca.shift()[0](e.data.out);break;case"create":e.data.err?Ia.shift()[1](e.data.err):Ia.shift()[0](e.data.out);break;case"release":e.data.err?Aa.shift()[1](e.data.err):Aa.shift()[0]();break;case"run":e.data.err?Ea.shift()[1](e.data.err):Ea.shift()[0](e.data.out);break;case"end-profiling":e.data.err?Ta.shift()[1](e.data.err):Ta.shift()[0]();break;case"is-ort-env-initialized":e.data.err?Oa.shift()[1](e.data.err):Oa.shift()[0](e.data.out);break;default:}},_n=typeof document<"u"?document?.currentScript?.src:void 0,Cl=async()=>{if(xt()){if(ka)return;if(Cn)throw new Error("multiple calls to 'initWasm()' detected.");if(Ra)throw new Error("previous call to 'initWasm()' failed.");return Cn=!0,Ee.wasm.wasmPaths===void 0&&_n&&_n.indexOf("blob:")!==0&&(Ee.wasm.wasmPaths=_n.substr(0,+_n.lastIndexOf("/")+1)),new Promise((e,t)=>{tt?.terminate();let r=URL.createObjectURL(new Blob([_l()],{type:"text/javascript"}));tt=new Worker(r,{name:"ort-wasm-proxy-worker"}),tt.onerror=n=>t(n),tt.onmessage=Yp,URL.revokeObjectURL(r),Sa=[e,t];let a={type:"init-wasm",in:Ee.wasm};tt.postMessage(a)})}else return Ni(Ee.wasm)},Il=async e=>{if(xt())return kt(),new Promise((t,r)=>{xa=[t,r];let a={type:"init-ort",in:e};tt.postMessage(a)});await gl(e)},Al=async e=>xt()?(kt(),new Promise((t,r)=>{_a.push([t,r]);let a={type:"create_allocate",in:{model:e}};tt.postMessage(a,[e.buffer])})):va(e),El=async(e,t)=>xt()?(kt(),new Promise((r,a)=>{Ca.push([r,a]);let n={type:"create_finalize",in:{modeldata:e,options:t}};tt.postMessage(n)})):$a(e,t),Pa=async(e,t)=>{if(xt()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return kt(),new Promise((r,a)=>{Ia.push([r,a]);let n={type:"create",in:{model:e,options:t}};tt.postMessage(n,[e.buffer])})}else return bl(e,t)},Tl=async e=>{if(xt())return kt(),new Promise((t,r)=>{Aa.push([t,r]);let a={type:"release",in:e};tt.postMessage(a)});wl(e)},Ol=async(e,t,r,a,n,o)=>{if(xt()){if(r.some(u=>u[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(n.some(u=>u))throw new Error("pre-allocated output tensor is not supported for proxy.");return kt(),new Promise((u,l)=>{Ea.push([u,l]);let i=r,c={type:"run",in:{sessionId:e,inputIndices:t,inputs:i,outputIndices:a,options:o}};tt.postMessage(c,Sl(i))})}else return vl(e,t,r,a,n,o)},kl=async e=>{if(xt())return kt(),new Promise((t,r)=>{Ta.push([t,r]);let a={type:"end-profiling",in:e};tt.postMessage(a)});$l(e)},Rl=async()=>xt()?(kt(),new Promise((e,t)=>{Oa.push([e,t]);let r={type:"is-ort-env-initialized"};tt.postMessage(r)})):yl()});var In,Pl,Zp,An,Bl=q(()=>{"use strict";ct();Ba();We();Pl=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},Zp=e=>{switch(e[3]){case"cpu":return new Ke(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!en(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:a,dispose:n}=e[2];return Ke.fromGpuBuffer(r,{dataType:t,dims:e[1],download:a,dispose:n})}default:throw new Error(`invalid data location: ${e[3]}`)}},An=class{async createSessionAllocate(t){let r=await fetch(t);if(r.status!==200)throw new Error(`failed to load model: ${t}`);let a=await r.arrayBuffer();return Al(new Uint8Array(a))}async loadModel(t,r){if(await Rl()||(In||(In=Il(Ee)),await In,In=void 0),typeof t=="string")if(typeof process<"u"&&process.versions&&process.versions.node){let a=await(void 0)(t);[this.sessionId,this.inputNames,this.outputNames]=await Pa(a,r)}else{let a=await this.createSessionAllocate(t);[this.sessionId,this.inputNames,this.outputNames]=await El(a,r)}else[this.sessionId,this.inputNames,this.outputNames]=await Pa(t,r)}async dispose(){return Tl(this.sessionId)}async run(t,r,a){let n=[],o=[];Object.entries(t).forEach(m=>{let w=m[0],b=m[1],$=this.inputNames.indexOf(w);if($===-1)throw new Error(`invalid input '${w}'`);n.push(b),o.push($)});let u=[],l=[];Object.entries(r).forEach(m=>{let w=m[0],b=m[1],$=this.outputNames.indexOf(w);if($===-1)throw new Error(`invalid output '${w}'`);u.push(b),l.push($)});let i=n.map((m,w)=>Pl(m,()=>`input "${this.inputNames[o[w]]}"`)),c=u.map((m,w)=>m?Pl(m,()=>`output "${this.outputNames[l[w]]}"`):null),f=await Ol(this.sessionId,o,i,l,c,a),g={};for(let m=0;m<f.length;m++)g[this.outputNames[l[m]]]=u[m]??Zp(f[m]);return g}startProfiling(){}endProfiling(){kl(this.sessionId)}}});var Qp,En,Ml=q(()=>{"use strict";ct();Ba();Bl();Qp=()=>{if((typeof Ee.wasm.initTimeout!="number"||Ee.wasm.initTimeout<0)&&(Ee.wasm.initTimeout=0),typeof Ee.wasm.simd!="boolean"&&(Ee.wasm.simd=!0),typeof Ee.wasm.proxy!="boolean"&&(Ee.wasm.proxy=!1),typeof Ee.wasm.numThreads!="number"||!Number.isInteger(Ee.wasm.numThreads)||Ee.wasm.numThreads<=0){let e=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;Ee.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},En=class{async init(){Qp(),await Cl()}async createInferenceSessionHandler(t,r){let a=new An;return await a.loadModel(t,r),Promise.resolve(a)}}});var zl={};Vt(zl,{wasmBackend:()=>Xp});var Xp,Dl=q(()=>{"use strict";Ml();Xp=new En});var ef={};Vt(ef,{InferenceSession:()=>$i,Tensor:()=>Ke,TrainingSession:()=>Ci,default:()=>Jp,env:()=>Ee,registerBackend:()=>St});ct();ct();ct();var Ai="1.17.0";var Jp=Wn;{let e=(Dl(),At(zl)).wasmBackend;typeof navigator<"u"&&navigator.gpu&&St("webgpu",e,5),St("cpu",e,10),St("wasm",e,10),St("xnnpack",e,9),St("webnn",e,9)}Object.defineProperty(Ee.versions,"web",{value:Ai,enumerable:!0});return At(ef);})();
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
//# sourceMappingURL=ort.webgpu.min.js.map
